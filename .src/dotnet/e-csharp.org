 #+TITLE: C♯


* 历史

- Visual J++ 被放弃，[[https://baike.baidu.com/item/%E5%AE%89%E5%BE%B7%E6%96%AF%C2%B7%E6%B5%B7%E5%B0%94%E6%96%AF%E4%BC%AF%E6%A0%BC][安德斯·海尔斯伯格]]带领团队从 2000 年左右开始开发了 C#，到 2002 年的的时候，开始提交给 ECMA 成为了标准
- 因为安德斯他的个人经历，所以 C# 深受 Pascal/C++/Java 的影响
- 到现在，C# 已经成为了一种多范式的语言。首先它是一门纯粹的面向对象的语言 (封装、继承、多态)，提供了面向组件编程的一些改进 (属性、委托、事件)

C# 版本演化:
- 1.0 纯粹的面向对象 (2002)
- 2.0 增加了泛型的概念 (2005)
- 3.0 增加了 LINQ 功能 (2008)
- 4.0 增加了命名参数和可选参数的功能，并添加了动态编程的支持 (2010)
- 5.0 增加了 async/await 的异步编程范式 (2012)
- 6.0 推进了跟 .NET Core 的语言共享 (2015)
- 7.0 添加了函数式编程的一些特性，如果模式匹配、元组等等，包括其他一些优化 (2017)
- 8.0 开始支持默认接口方法，可空引用类型，switch 表达式等 (2019)
- 9.0 增加了 Record 类型，继续对 switch 表达式等进行简化跟优化 (2021)

* [语言与类型]

在 C# 等面向对象的语言中，*类型 (Type)* 是第一位的
- 在 C# 中，不外乎做两件事，第一件是引入别人的类型，第二件是声明自己的类型
- 也就是说，整个 C# 项目，是由不同的 *类型声明* 组成的
- 在整个 C# 项目中，需要 *有且只有一个* 特殊的方法，就是 Main 方法。它是程序执行的起点
- 通过引入 *命名空间 (namespace)* 的概念，用来组织各种类型，从而避免命名冲突

#+ATTR_HTML: :width 400px
[[file:img/types.png]]

#+ATTR_HTML: :width 400px
[[file:img/types-2.png]]

** Main

#+begin_src csharp
  static int Main (string[] args)
  {
      return 如果正常返回则是 0，否则是一个整数代表错误编号;
  }

  static void Main (string[] args)
  {
      // 如果真的不关心返回的错误编号的话，可以将返回值设置为 void

      // 可以使用 args 来捕获从控制台输入的参数 (用空格分隔的元素)
      if (args.Length > 0 && args[0] == "--help")
      {
          Console.WriteLine("使用方式: ./Program");
      }
  }

  static void Main ()
  {
      // 如果你真的不在乎传入参数的话，那么将 args 省略掉也可以
  }

  static async void Main()
  {
      await CCCAync();
      await AAA();
      await BBB();
      DDD();
  }
#+end_src

args 使用的另一个示例:
#+begin_src csharp
  static void Main(string[] args)
  {
      if (args.Length == 1)
      {
          if (args[0] == "--help")
          {

              Console.WriteLine("使用方法: dotnet run 2223");
          }
          else
          {
              double bill = double.Parse(args[0]);
              var calc = new TipCalculator(bill);
              calc.PrintToConsole();
          }
      }
      else
      {
          Console.WriteLine("参数错误.");
      }
  }
#+end_src

** 命名空间

- 用来解决类型名字的冲突
- 用来合理组织类型

*** 使用

#+begin_src csharp
  // 类型的使用，可以通过 namespace.类型 来访问到 / full name
  System.String aaa = System.IO.File.ReadAllText("e:\\aaa.txt");
  System.Console.WriteLine(aaa);
  System.Console.WriteLine("hello");

  // 可以借助 using 命名空间的方式，简化类型的使用
  using System;
  using System.IO;
  string aaa = File.ReadAllText("e:\\aaa.txt");
  Console.WriteLine(aaa);
  Console.WriteLine("hello");

  // 可以使用 using static 的语法继续进行简化
  using static System.Console;
  using static System.IO.File;
  string aaa = ReadAllText("e:\\aaa.txt");
  WriteLine(aaa);
  WriteLine("hello");

  // 可以使用 using = 的方式，为命名空间起一个别名。这种方式一般用来解决冲突
  using SI = System.IO;
  using HisSystem;
  SI.File.xxx();  // System.IO.File.xxx();
  File.xxx();     // HisSystem.FIle.xxx();
#+end_src

*** 定义

支持嵌套，支持使用 . 的形式进行简写:
#+begin_src csharp
  using SI = System.IO; // File

  namespace TaxCalculator
  {
      namespace Hi
      {
          namespace Ih // TaxCalculator.Hi.Ih.Boy
          {
              class Boy
              {
              }
          }
          class Girl // TaxCalculator.Hi.Girl
          {
          }
      }

      namespace A.B.C.D.E.F
      {
          namespace G.H.X
          {
              using static System.Console;
              namespace Y
              {
                  class Hello
                  {
                      void Say()
                      {
                          WriteLine("hello");
                      }
                  }
              }
          }
      }

      namespace B
      {
          using System;
          class Program // TaxCalculator.Program
          {
              static void Main()
              {
                  string aaa = SI.File.ReadAllText("e:\\aaa.txt");
                  Console.WriteLine(aaa);
                  Console.WriteLine("hello");
              }
          }
      }
  }
#+end_src

*** BCL/System

System 命名空间:
- System.IO (Input/Output), 文件的处理
- System.Drawing, 绘制图片
- System.Collections，集合类型
- System.Net，网络访问
- System.Text，跟文本相关的内容，比如正则表达式
- System.Threading，多线程
- System.Threading.Tasks，异步编程

** 模板 vs 实例

类型就是用来创建数据结构的一种 *模板*：
- 类型本身并不是真正的数据，它只是描述了数据应该怎么被构造出来
- 类型它需要有名字，占用的空间，包括一系列的属性和行为

通过某个类型模板创建实际的对象，称作 *实例化* 该类型:
- 它就是真正的数据。类型的实例，类型的对象。所有的数据都是要根据类型创建出来的
- 类型的话，要么是平台预定义的，要么是 BCL/FCL 中定义的，要么是你自己声明的

#+begin_src csharp
  // 1 声明
  class xxx
  {
      int age;
      string name;
  }
  class yyy
  {
      int i;
      xxx xxx; // 2 使用
  }

  new yyy(); // 2 使用

  int a = 333; // 不需要声明，直接实例化
#+end_src

** 值类型 vs 引用类型

内存分为两部分:
- 栈 (Stack)，速度快
- 堆 (Heap)，容积大

#+ATTR_HTML: :width 500px
[[file:img/value-type-ref-type.png]]

* 预定义/数值类型
** 整数

为了表示显示世界中的计算，人们发明了数字的记法:
- 通用的计算方式是 *十进制* (因为人自古来来，都有十根手指头)
- 计算机内部使用的是 *二进制* (因为使用电子元件状态表达 0/1 是最简单的)
- 人们一般使用 *十六进制* 来描述计算机中的二进制 (其表达能力更强，且能跟字节为单位的二进制形成对应关系)

为了能在计算机中有效存储整数，C# 中预定义了如下类型:
- byte (字节，使用 8bit 表示，它的表现能力最差，只有 0 ~ 255)
- short (短整数，使用 2Byte 表示，能表示到 3 万大小)
- int (整数，4B 长度，能表达到 20 多亿)
- long (长整数，16B 长度，能表达到亿亿的单位)

另外，考虑是否设置符号位 (Sign/Unsign)，上面的类型又有对应的类型:
- sbyte
- ushort
- uint
- ulong

上述的类型都是用来创建整数数据的模板，它们的区别在于占用空间和表达里。
选择类型的根据是:
- 占用小的，表达能力差；占用大的，表达能力强
- 在业务的允许范围内，尽量选择占用空间小的类型
- 如果不好决定使用声明类型，优先使用 int

整数:
#+begin_src csharp
  byte aa = 0;
  byte az = 255;
  sbyte ba = -128;
  sbyte bz = 127;

  short s1 = -32768;
  short s2 = 32767;
  ushort s3 = 0;
  ushort s4 = 65535;

  int i1 = -2147483648;
  int i2 = 21_4748_3647;
  uint i3 = 42_9496_7295;

  long l1 = 3232323232335555355;
  ulong l2 = 23333333333333333;

  Console.WriteLine(0.1 + 0.2);
  Console.WriteLine(100 * 0.28);
  Console.WriteLine(100 * 0.27);

  byte a = 1;
  short b = 1;
  int c = 1;
  long d = 1;

  // C# 现在允许使用分隔符描述数字，这样具备更好的可读性
  long xxx = 11_1161_1311_4441_2323;
  int yyy = 2323;
#+end_src

可以直接使用二进制/十六进制的方式描述数字:
#+begin_src csharp
  byte zzz = 0b11111111;
  Console.WriteLine(zzz);

  // 16 进制 10 2 
  // 0,1,10,11,100,101,110,111
  // 1,2,..9,10,11,12..19
  // 1, 2,...9, a, b, c, d, e, f / 15, 1111
  // 10, 11, 12 .. 1e, 1f     0001_1111
  // 20,...............2f
  // 30................3f
  //                   9f
  // a0................af
  // b0................bf
  // c0................cf
  // d0................df
  // e0................ef
  // f0..............fe.ff 256 1111_1111
  // 100 .. 101. .....

  Console.WriteLine(0b11111111_11111110_11111111);
  Console.WriteLine(0x1e);
  Console.WriteLine(0xff_fe_ab_12);
  Console.WriteLine(2222323);
#+end_src

#+ATTR_HTML: :width 400px
[[file:img/integers.png]]

** 浮点数

- 根据存储形式，分为单精度 (float) 和双精度 (double)
- *float* 使用 32bit 来存储 (1 个符号位 8 个指数位 23 个尾数)
- *double* 使用 64bit 来存储 (1 个符号位 11 个指数位 52 个尾数)
- 一个小数，转换为计算机存储的形式，难免会有精度的损失。因此
  + 0.1 + 0.2 ≠ 0.3
  + 0.6 + 0.7 = 1.2999999999999998
  + 0.28 * 100 = 28.000000000000004
- 可以使用 *decimal* 类型，来表示更加精确的数值计算
  + 它的优点是，可以进行精确的计算
  + 它的缺点是，它需要占用更大的存储空间 (128bit)

#+ATTR_HTML: :width 500px
[[file:img/float-type.png]]

** Literate (字面量表达)

#+begin_src csharp
  // 字面量
  // 1112 int
  // 1112L long
  // 1112UL Unsigned Long
  // 1112F float
  // 1112.0 double
  // 1112M decimal
  Console.WriteLine(0.1M + 0.2M);

  double a = 2222;
  float b1 = 33332332323233;
  float b2 = 2323F;
  decimal c = 3.222M;

  int x = 333;
  long y1 = 54444;
  long y2 = 54444L;
#+end_src

* 预定义/非数值·值类型
** 字符类型 (char)

字符集/编码格式:
+ 最原始的英文中的 *ASCII* 编码
+ 后来出现的，各个国家的，比如 *GBK/Big5*
+ 为了消除字符集冲突，出现的 *Unicode* 组织跟字符集。并根据字符集出现了 *UTF-16/UTF-8* 等编码格式

Q & A:
- ucs-2 vs UTF-16 ????
- UTF8 怎么的格式 ????

#+ATTR_HTML: :width 500px
[[file:img/unicode.png]]

因此，在 C# 中内部，字符是使用 UTF-16 格式存储的。
#+begin_src csharp
  char a = 'x';

  char a = 'x';
  char b = '中';
  char c = '☺';
  char d = '⁞';
#+end_src

** 布尔类型 (bool)

#+begin_src cs
  bool a = true;
  bool b = false;
  
  bool c = 1 > 2; // > < == >= <=
  bool d = 1 == 2;
  
  a = !!!!!a; // 反
  a || b;     // 或
  a && b;     // 与
  
  a = true; b = false; d = true; e = false;
  f = true; g = true; h = false;
  
  ((a || b) && (c && d)) || e && (f || g) || h;
#+end_src

*** [条件分支] 在某种条件之下，做某件事

- if/else if/else
- switch (statement/expression)

if:
#+begin_src cs  
  // 1
  if (aaa)
  {
      Console.WriteLine("满足则执行，否则跳过");
  }
  Console.WriteLine("您说我什么条件会被执行?");
  
  // 2
  int score = 59; // 分数
  if (score > 70)
  {
      Console.WriteLine($"现在你的成绩是: {score}");
  }
  else
  {
      Console.WriteLine("您的成绩还可以啦，请下一次更加优秀哦.");
  }
  
  // 3
  int score = 59;
  if (score > 70)
  {
      Console.WriteLine($"现在你的成绩是: {score}");
  }
  else
  {
      if (score < 30)
      {
          Console.WriteLine("您太棒了，把您爸爸妈妈请过来一起分享这份荣耀吧.");
      }
      else
      {
          if (score > 60)
          {
              Console.WriteLine("您的成绩还可以啦，请下一次更加优秀哦.");
          }
          else
          {
              Console.WriteLine("您的成绩还可以啦...");
          }
      }
  }
  
  // 4
  if (score > 70)
  {
      Console.WriteLine($"现在你的成绩是: {score}");
  }
  else if (score > 60)
  {
      Console.WriteLine("您的成绩还可以啦，请下一次更加优秀哦.");
  }
  else if (score > 30)
  {
      Console.WriteLine("您的成绩还可以啦...");
  }
  else
  {
      Console.WriteLine("您太棒了，把您爸爸妈妈请过来一起分享这份荣耀吧.");
  }
#+end_src

switch (是 else if 语法的一种精简版):
#+begin_src cs
  switch (c)
  {
      case 'A':
      case 'B':
          color = ConsoleColor.Yellow;
          break;
      case 'C':
          color = ConsoleColor.Green;
          break;
      case 'D':
          color = ConsoleColor.Blue;
          break;
      default:
          color = ConsoleColor.Black;
          break;
  }
#+end_src

switch statement (语句) 和 expression (表达式):
#+begin_src cs
  // 语句，每个分支去做点啥事
  ConsoleColor color;
  switch (c)
  {
      case 'A':
          color = ConsoleColor.Red;
          break;
      case 'B':
          color = ConsoleColor.Yellow;
          break;
      case 'C':
          color = ConsoleColor.Green;
          break;
      case 'D':
          color = ConsoleColor.Blue;
          break;
      default:
          color = ConsoleColor.Black;
          break; 
  }
  
  // 表达式，返回值
  ConsoleColor c1 = c switch
  {
      'A' => ConsoleColor.Red,
      'B' => ConsoleColor.Yellow,
      'C' => ConsoleColor.Green,
      'D' => ConsoleColor.Blue,
      _   => ConsoleColor.Black
  };
#+end_src

*** [循环迭代] 重复做某件事

- for
- while
- do while
- foreach

遍历字符串:
#+begin_src csx
  string s = "hello world";
  
  foreach (var c in s)
  {
      Console.WriteLine(c);
  }
  
  for (int i = 0; i < s.Length; i++)
  {
      Console.WriteLine(s[i]);
  }
  
  int i = 0;
  while (i < s.Length)
  {
      Console.WriteLine(s[i]);
      i++;
  }
  
  int j = 0;
  do
  {
      Console.WriteLine(s[j]);
      j++;
  } while (j < s.Length);
#+end_src  


使用不同的方式，实现从 1 加到 10000 的和:
#+begin_src csx
  // 命名不规范
  // - 方法名，需要遵循 Pascal 语法 !!!
  // - 变量的命名，要让代码具备自解释性 (望文生义)
  // - 变量的名字/参数的变量，需要是驼峰写法
  // 从 1 到 10000 <不等于> 从 0 到 10000。循环的过程一定要注意边界条件
  // 合理设计方法 (返回值)
  // 充分考虑到可变性，将一些值抽取为参数
  
  static void Main(string[] args)
  {
      int i = 10000;
      Console.WriteLine(SumWithFor(i) / 2);
      Console.WriteLine(SumWithWhile(i));
      Console.WriteLine(SumWithDoWhile(i));
  }
  
  static int SumWithFor(int top)
  {
      int sum = 0;
      for (int i = 1; i <= top; i++)
      {
          sum += i;
      }
      return sum;
  }
  
  static int SumWithWhile(int top)
  {
      int sum = 0;
  
      int i = 1;
      while (i <= top)
      {
          sum += i;
          i++;
      }
  
      return sum;
  }
  
  static int SumWithDoWhile(int top)
  {
      int sum = 0;
  
      int i = 1;
      do
      {
          sum += i;
          i++;
      } while (i <= top);
  
      return sum;
  }
#+end_src


通过循环的方式，处理下面字符串:
#+begin_src cs
  // 将字符串进行反转
  // 将所有的大写字母都提到前面
  string a = "hekjsdkfSldAfjKksjsjkKFfjHkl";
  
  static string Fanzhuan(string str)
  {
      string result = "";
      for (int i = str.Length-1; i>=0 ; i--)
      {
          result += str[i];
      }
  
      return result;
  }
  
  static string DaxieTiDaoQianMianWithFor(string str)
  {
      StringBuilder xiaoxie = new StringBuilder();
      StringBuilder daxie = new StringBuilder();
      for (int i = 0; i < str.Length; i++)
      {
          if (str[i] >= 'a' && str[i] <= 'z')
          {
              xiaoxie.Append(str[i]);
          }
          else
          {
              daxie.Append(str[i]);
          }
      }
      daxie.Append(xiaoxie);
      return daxie.ToString();
  } 
#+end_src

*** 语句 (Statement) vs 表达式 (Expression)


提问: @@html: <span style="color: red">表达式和语句有社么区别?</span>@@

语句 (Statement):
#+begin_src csharp
  int r = new Random().Next(0, 100);
  
  int i;
  if (r > 50)
      i = 111;
  else
      i = 222;
  
  Console.WriteLine(i);
#+end_src

表达式 (Expression):
#+begin_src csharp
  int r = new Random().Next(0, 100);
  
  int i = (
      if (r > 50)
          111;
      else
          222;
  );
  
  Console.WriteLine(i); // if 不能作为表达式使用
#+end_src

* 预定义/非数值·引用类型
** string

字符串，是由字符序列组成的一种数据结构。

*** 字符串的初始化

#+begin_src csharp
  string g1 = "Hello World!";
  System.String g2 = "Hello World!";
  var g3 = "Hello World!";

  string message1;
  string message2 = null;
  string message3 = String.Empty; // string message3 = "";
  string oldPath = "Path:\nc:\\Program Files\\Microsoft Visual Studio 8.0";
  string newPath = @"Path:
  c:\Program Files\Microsoft Visual Studio 9.0";

  char[] letters = { 'A', 'B', 'C' };
  string alphabet = new string(letters);
#+end_src

*** 字符串的不可变性 (Immutable)
**** what & why

#+begin_src csharp
  int a;
  string b;


  int i = 1; // int i; i = 1;
  int j = 23;
  i += j; // i = i + j; i = 24;

  string s = "h";
  string t = "w";
  s += t; // s = s + t;
#+end_src

#+ATTR_HTML: :width 400px
[[file:img/string-immute.png]]


字符串是不可更改的:
#+begin_src csharp
  string s = "hello";
  Console.WriteLine(s[1]); // 可以通过这种方式读取字符串的某个位置
  s[1] = 'x';              // 这一句是错误的
#+end_src

思考:
- 为什么要搞成不可变的 ?
- 不可变能带来什么好处 ?

**** System.Text.StringBuilder

这是 BCL 中提供的一个类，专门使用在 *字符串拼接* 的场景下。

因为，在预定义的字符串实现中，字符串拼接 (+=) 是非常低效的一种行为 (要去理解为什么)。

#+ATTR_HTML: :width 500px
[[file:img/string-vs-stringbuilder.png]]

#+begin_src csharp
  using System.Text;

  // 解析一下，为什么这段代码会为内存带来大量的垃圾
  string s = "hello";
  for (int i = 0; i < 1000; i++)
  {
      s += ".";
      Console.WriteLine(s);
  }

  // 要理解，为什么 StringBuilder 会占用更少的空间
  // 如何理性看待 String vs StringBuilder 两种类型
  StringBuilder sb = new StringBuilder("hello");
  for (int i = 0; i < 1000; i++)
  {
      sb.Append(".");
      Console.WriteLine(sb);
  }

  if (s == sb.ToString())
  {
      Console.WriteLine("哈哈，一样啊");
  }
#+end_src

**** String Intern Pool (字符串池)

因为字符串是不可变的，所以在字符串的操作中，会产生很多临时字符串 (垃圾)。

在实际使用中，有很多字符串我们会反复去使用的，所以为了避免重复进行字符串的创建，
会对字符串操作过程中产生的字符串进行缓存管理，即创建一个字符串池管理它们。

后续进行字符串的声明时，会优先到池中寻找，如果已经存在，那么直接使用它。

字符串池的根本原因是，字符串是不可变的。

#+begin_src csharp
  string a = "hello";
  string b = "hel";
  string c = "lo";
  string d = b + c;
  string e = "hello";
  
  // 使用 == 判断，两个字符串的值是不是一样的
  Console.WriteLine(a == d); // True
  Console.WriteLine(a == e); // True
  
  // 使用 object.ReferenceEquals 判定是否占用了相同的内存空间
  Console.WriteLine(object.ReferenceEquals(a, d)); // False
  Console.WriteLine(object.ReferenceEquals(a, e)); // True
  
  // 注意，类比 Java:
  // a == b 判断的是 a 跟 b 是否是同一个引用
  // a.equals(b) 用来判断 a 跟 b 的值是不是一样的
  //
  // string a = null;
  // string b = "hello";
  // a.equals(b) -> b.equals(a);
  // "hello".equal(a); (1)
  // if (a != null) a.equal("hello"); (2)
#+end_src

*** [API] 基本操作

API (Application Programming Interface) 应用程序编程接口。

#+begin_src csharp
  string s1 = "aaa";
  string s2 = "您好aaa";
  string s3 = "𠈓好aaa";

  Console.WriteLine(s1.Length); // 由多少个字符组成
  Console.WriteLine(s2.Length);
  Console.WriteLine(s3.Length); // 这个为什么是 6 ?

  string s4 = "中国𠈓您好𠈓blahblaah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjf";
  Console.WriteLine(s4.Length);
  Console.WriteLine(new StringInfo(s4).LengthInTextElements);
#+end_src

*** [API] 拼接 + 格式化

#+begin_src csharp
  string name = "tom";
  string friend = "jerry";
  int age = 30;
  decimal sal = 200.12345M;
  
  string r1 = name + "的朋友是"
                   + friend + "，它虽然只有" 
                   + age + "岁，但是它的收入能到达到"
                   + sal + "刀";
  
  string r2 = new StringBuilder()
      .Append(name)
      .Append("的朋友是")
      .Append(friend)
      .Append("，它虽然只有")
      .Append(age)
      .Append("岁，但是它的收入能到达到")
      .Append(sal)
      .Append("刀")
      .ToString();
  
  string r3 = string.Format("{0}的朋友是{1}，它虽然只有{2}岁，但是它的收入达到{3:C}", name, friend, age, sal);
  
  // {变量,对齐多少长度:格式}
  // [对齐] 正数表示右对齐，负数表示左对齐
  // [格式] P 百分比 C 货币 E 科学计数法 D 补齐长度 F/N 小数点多少位 X 十六进制
  string r4 = $"{name}的朋友是{friend}，它虽然只有{age:d5}岁，但是它的收入达到{sal:C}!";
  
  // 语言-国家或区域
  // zh-CN
  // en-US
  // en-EN
  string ss = sal.ToString("C", new CultureInfo("en-US"));
  string r5 = $"{name}的朋友是{friend}，它虽然只有{age:d5}岁，但是它的收入达到{ss}!";
  
  Console.WriteLine(r5);
#+end_src

*** [API] 子字符串

#+begin_src csharp
  string s1 = "000o。OOOoOO0O0Ooo000o";
  
  // 取
  char c = s1[1]; // 取字符
  string s2 = s1.Substring(1, 2); // 位置，长度 : el
  string s3 = s1.Substring(2);    // 从某个位置到最后
  string s4 = s1.Substring(2, 0); // String.Empty ""
  
  // 判
  bool b1 = s1.Contains("o0");    // 是否包含一个子字符串
  bool b2 = s1.StartsWith("o");   // 是不是以 x 开始
  bool b3 = s1.EndsWith("o");     // 是不是以 x 结束的
  
  // 序
  int i1 = s1.IndexOf("O");
  int i2 = s1.LastIndexOf("O");
  int i3 = s1.IndexOfAny(new []{'o', 'O'});
  
  // 结合
  string path = "C:/aaa/work.x/hello.txt";
  string drive = path.Substring(0, path.IndexOf(":"));
  string dir = path.Substring(0, path.LastIndexOf("/") + 1);
  string file = path.Substring(path.LastIndexOf("/") + 1);
  string ext = path.Substring(path.LastIndexOf(".") + 1);
  
  // 自定义版本的 LastIndexOf
  int p = 0;
  for (int i = path.Length - 1; i >= 0; i--)
  {
      if (path[i] == '/')
      {
          p = i;
          break;
      }
  }
  string dir2 = path.Substring(0, p);
  
  Console.WriteLine(dir2);
#+end_src

*** [API] 字符串的修改

#+begin_src csharp
  // 谨记:
  // 修改不会作用在原先的字符串上
  // 所有的修改，都是返回了一个完全崭新的字符串
  
  string s1 = "  000o。OOOoOO0O，0Ooo000o--";
  
  string s2 = s1.Insert(3, ">>>");
  string s3 = s1.Remove(2, 1);
  string s4 = s1.Replace("。", ".");
  string s5 = s1.Replace('，', '_');
  string s6 = s1.Replace("OoO", "111");
  string s7 = s1.Replace("OoO", "222", true, new CultureInfo("zh-CN"));
  
  string s8 = s1.PadLeft(100);
  string s9 = s1.PadLeft(100, '-');
  string sa = s1.PadRight(100, '-');
  
  string sb = s1.Trim();
  string sc = s1.Trim('-');
  string sd = s1.TrimStart();
  string de = s1.TrimStart().TrimEnd('-').PadLeft(50, ':');

  string df = s1.ToLower();
  string dg = s1.ToUpper();
  
  Console.WriteLine(de);
#+end_src

*** [API] String 跟 Array 的转换

#+begin_src csharp
  string s1 = "  000o。OOOoOO0O，0Ooo000o--";
  
  // 字符串到 [数组] 的转换
  char[] a1 = s1.ToCharArray();
  char[] a2 = s1.ToCharArray(2, 10);
  
  // [数组] 到字符串的转换
  char[] a3 = new[] {'a', 'o', 'e'};
  string s2 = new string(a3);
  
  // StringBuild vs String
  string s3 = new StringBuilder().Append("hello").ToString();
  StringBuilder sb = new StringBuilder(s1);
#+end_src

** object

#+begin_src csx
  int i = 20;
  string s = "hello";
  
  object i1 = 20;
  object s1 = "hello";
  
  object i2;
  object s2;
  
  i2 = 20;
  s2 = "hello";
#+end_src

** dynamic

- 静态语言
- 动态语言 (动态一时爽，重构hzc)
  
#+begin_src csx
  int i = 20;
  string s = "hello";
  
  object i1 = 20;
  object s1 = "hello";
  
  object i2;
  object s2;
  
  i2 = 20;
  s2 = "hello";
#+end_src

#+begin_src cs
  // 动态语言的搞法，s 是啥不确定，运行到哪里可以能就变了
  var s;
  s = 2323;     // 整数
  s = "kdjkfd"; // 字符串
  Console.WriteLine(s.Length);
  s = [2, 3];   // 数组
  
  // 静态类型，s 是啥，出生定终身
  var s = "hello";
  
  // C# 对动态类型的支持
  dynamic a = 1111;
  a = "hello";
  a = new FileInfo("");
#+end_src

* 用户自定义类型
** class

类

** interface

接口

** delegate

委托

** array

数组

** record

记录

** struct

结构体

** enum

枚举

* 类型转换

基本类型的转换:
- 如果涉及到转换之后不会存在任何的精度损失的话，会进行隐式转换 (implicit)
  : int a; byte b; a = b;
- 如果可能存在精度损失的话，这个时候，必须进行强制转换 (explicit)
  : int a; byte b; b = (int)a;
- 如果强制转换过程中，出现精度损失的话，默认情况下会按照某种规则截断。注意，不会报错
- 我们可以使用 ~checked~ 关键词将转换的语句包围住，然后在转换中出现精度损失的话，会抛出异常
  : int a; byte b; b = check((int)a);

引用类型的转换:
- 引用类型同样存在 implicit/explicit 抓换
  : Person p = new Student();
  : Student s = (Student) p;
- 引用类型的转换，如果转换失败，默认会抛出异常
- 使用 ~is~ 语句，判断是否属于某种类型。经常会跟显式转换配合使用:
  #+begin_src cs
    Student s;
    if (p is Student)
    {
        s = (Student) p;
    }
    else
    {
        s = null;
    }
    Console.WriteLine(s);
  #+end_src
- 可以使用 ~as~ 语句，简化上述的判断跟转换。这是一种很甜的糖:
  #+begin_src cs
    Student s = p as Student;
    if (s == null) ...
  #+end_src

装箱/拆箱 (boxing/unboxing):
- *装箱* 是将值类型转换为 object 类型或由此值类型实现的任何接口类型的过程
- 在 C# 中，基本类型也是 object 的实例。
  但是为了效率，基本类型都被直接存储在栈上，存储的形式不是对象的形式。
  因此，如果想将基本类型当作对象，来进行方法调用的时候，需要将其转换为对象存储形式
  为了简化上述过程，在对基本类型进行方法调用的时候，CLR 会自动进行上述转换。
  这种隐式转换的机制，叫做自动装箱 (auto-boxing)
- 反向的过程叫拆箱

** 隐式转换/强制转换

#+begin_src cs
  char a = 'A';
  byte ab = (byte)a;
  
  int s1 = ab + 13; // byte + int
  ab = (byte) (((int) ab) + 13); // int + int = int
  ab = (byte) (ab + 13);
  
  /////
  char a = 'A';
  byte a1 = (byte) a;
  char a2 = (char) (a1 + 13);
  Console.WriteLine($"{a} -> {a1} -> {a2}");
#+end_src

使用 checked 来释放危险:
#+begin_src cs
  int a = 1;
  byte b = 0;
  byte c = 0;
  byte d = 0;
  
  // 潜在的危险
  b = (byte) a;
  c = (byte) a;
  d = (byte) a;
  
  // 主动释放危险
  b = checked((byte) a);
  c = checked((byte) a);
  d = checked((byte) a);
  Console.WriteLine(b);
  
  // 指定危险区域
  checked
  {
      b = (byte)a;
      c = (byte)a;
      d = (byte)a;
      Console.WriteLine(b);
  }
#+end_src

** 引用类型的隐式和强制转换

#+begin_src cs
  class Person {}
  class Student : Person {}
  
  Person p = new Person();
  Student s = new Student();
  
  Person p1 = new Student();
  
  object a = new Student();
  a = 2122;
  // a: object
  Student s2 = (Student)a;
#+end_src

** 装箱/拆箱 (auto-boxing)

#+begin_src csx
  // 自动装箱
  int i = 1;
  object o = null;
  o = i;
  
  Console.WriteLine($"i: {i}, o: {o}");
  
  // 装箱使用的是数据的副本
  i = 5;
  o = 6;
  Console.WriteLine($"i: {i}, o: {o}");
  
  // 拆箱
  i = (int)o;
#+end_src

#+RESULTS:
| i: 1 | o: 1 |
| i: 5 | o: 6 |

** 自定义转换规则

#+begin_src cs
  class Program
  {
      static void Main(string[] args)
      {
  
          Person p = new Person();
          Student s = new Student();
  
          Person p1 = new Student();
  
          object a = new Student();
          Student s2 = (Student)a;
  
          // 在 C# 中，类型转换的规则，是可以自定义的
          Student ss = new Student();
          ss.id = 222;
          int i = ss;
          Console.WriteLine(i);
  
          Student st = (Student)333;
          Console.WriteLine(st);
      }
  
      class Person { }
  
      class Student : Person
      {
          public int id;
  
          public static implicit operator int (Student s)
          {
              return s.id;
          }
          public static explicit operator Student(int si)
          {
              var s = new Student();
              s.id = si;
              return s;
          }
      }
  }
#+end_src

学号 - 学生，转换的示例:
#+begin_src cs
  // 普通使用
  int id = 2323232323;
  s = new Student();
  s.id = id;
  s.xxx = ksdfj;
  s.yyy = kjskdfj;
  
  // 抽出为方法
  Student MakeStudent(int id)
  {
      s = new Student();
      s.id = i;
      s.xxx = ksdfj;
      s.yyy = kjskdfj;
  }
  S = MakeStudent(id);
  
  // 抽出为类型转换
  Student s = (Student) id;
#+end_src

** 基于 *字符串* 之间的互相转换

- 核心两种方法: ~string.Format~ 用来转换为字符串，~type.Parse~ 用来从字符串转化
- 可以使用 ~ToString/TryParse~ 对上面的两个方法进行补充

简而言之:  
- 将其他类型转换为字符串: ~string.Format/ToString~
- 将字符串转换为其他类型: ~xxx.Parse/TryParse~
- BCL 中提供了一个叫 ~Convert~ 的类，可以实现更多更复杂的转换

*** string.Format

#+begin_src cs
  string r3 = string.Format("{0}的朋友是{1}，它虽然只有{2}岁，但是它的收入达到{3:C}", name, friend, age, sal);
#+end_src

*** type.ToString

因为，string 类型是如此重要，所以在 *所有类的基类，即 object 中*,
包含了一个默认的 ToString 方法。

#+begin_src cs
  class Person
  {
      private int sal = 1000000;
  
      void Hahaha()
      {
          Console.WriteLine("hdskfjksjfksjdfkke");
      }
  }
  
  Person p = new Person();
  Console.WriteLine(p.ToString()); // Program+Person
#+end_src

#+begin_src cs
  class Person
  {
      private int sal = 1000000;
  
      void Hahaha()
      {
          Console.WriteLine("hdskfjksjfksjdfkke");
      }
  
      public override string ToString()
      {
          return "我就是我，不一样的烟火.我的工资: " + this.sal;
      }
  }
  
  Person p = new Person();
  Console.WriteLine(p);
#+end_src

#+begin_src cs
  // int
  int i = 112323;
  string s1 = i.ToString("X");
  Console.WriteLine(s1);
  
  // datetime
  DateTime now = DateTime.Now;
  string s2 = now.ToString();
  Console.WriteLine(s2);
  string s3 = now.ToString("现在时间: yyyy年MM月dd日，不告诉你几点");
  Console.WriteLine(s3);
  CultureInfo ci = new CultureInfo("zh-CN");
  string s4 = now.ToString("现在时间: yyyy年MMM ddd，不告诉你几点", ci);
  Console.WriteLine(s4);
#+end_src

*** type.Parse/TryParse

#+begin_src cs
  // int
  string s1 = "1234343";
  int i = int.Parse(s1) + 1;
  Console.WriteLine(i);
  
  // double
  string s2 = "2322222";
  double d = double.Parse(s2);
  Console.WriteLine(d);
  
  // DateTime
  string s3 = "1999-02-13";
  DateTime dt = DateTime.Parse(s3);
  Console.WriteLine(dt.Year);
#+end_src

转换失败，会抛异常:
#+begin_src cs
  string s4 = "hello";
  int i2 = int.Parse(s4);
  
  try
  {
      string s4 = "hello";
      int i2 = int.Parse(s4);
  }
  catch (e)
  {
      // 转换不了怎么办
  }
#+end_src

可以使用 TryParse 进行转化，如果转换失败，会返回 False:
#+begin_src cs
  string s4 = "hello";

  if (int.TryParse(s4, out int result))
  {
      Console.WriteLine(result);
  }
  
  bool TryMyParse(string s, out int result)
  {
      try
      {
          result = int.Parse(s4);
          return true;
      }
      catch
      {
          result = 0;
          return false;
      }
  }#+end_src

*** Convert

#+begin_src cs
  string s1 = Convert.ToString(82738283782, 2);
  string s2 = Convert.ToString(82738283782, 8);
  Console.WriteLine(s2);
  
  Convert.TryFromBase64String();
#+end_src

* 类 (Class)
** 字段 (Field)

- 作为一个字段，最重要的是 (类型) (名字) = (值)
- 可以 *选择性* 使用其他修饰符，为字段增加 *额外* 的功能或限制:
  + 访问修饰符: private/public/protected/internal 等，用来给予外部的访问限制
  + 只读/常量修饰符: const/readonly，用来防止数据被误修改
  + 静态修饰符: static 的作用是，将这个字段的归属权给予类

** 方法 (Method)
*** Basic

方法是一个具备名字的代码块:
- 通过 ~方法名()~ 的方式实现方法调用，
  也就是在调用的地方将方法名代表的代码块里的代码进行运行
- 方法的三要素:
  1. 一个名字 (方法名)
  2. 传入的数据 (传入参数) 入参写在方法名后面的括号里。如果没有入参，括号保持为空即可
  3. 传出的数据 (返回值) 方法内部，使用 return 表示返回的数据。在方法名前面，添加返回的类型。
     如果方法内部没有任何 return 表示方法没有返回值，需要在方法前面添加 void 表示这种情况

*** 方法的重载 (overload)

- 一个类中，可以有同名的方法。需要有不同的参数 (这样才能区分调用)
- 请叙述一下 overload 和 override 有什么区别

方法的示例:
#+begin_src csharp
  class Program
  {
      // 方法的声明、定义
      int 增加 (int a)  // 方法名为 [增加]，入参为 [a]
      {
          return a + 1;  // 返回值为 [a + 1]
      }
      double 加法 (double a, double b) // 可以有多个入参
      {
          return a + b;
      }
      double 没有入参 () // 可以没有入参
      {
          return 111.111; // 返回 double 类型的数据
      }
      void 没有返回数据 (string name) // 没有返回数据使用 void 表示
      {
          Console.WriteLine(name); // 方法体内，没有任何 return 语句，所以方法没有返回任何数据
      }
      void 没有返回值也没有入参 () // 这个方法，就是没有返回值也没有入参
      {
          Console.WriteLine("hello, world");
      }

      // 方法的调用
      // 使用方法的名字调用方法:
      // - 入参的个数和顺序要跟上述定义的一致
      // - 返回值的类型要跟上述定义的一致，如果 void 类型的函数是不能接受其返回值的
      // 上述方法定义中的参数，又叫形式参数 (形参)
      // 这里调用时传入的参数，又叫实际参数 (实参)
      // 也就是，实参要跟形参相对应!
      int a = 增加(11);
      double b = 加法(11, 33);
      double c = 没有入参();
      没有返回数据("H&M");
      没有返回值也没有入参();
  }
#+end_src

*** 参数 (值参数/ref/out)

值参数 (默认的):
#+begin_src cs
    static void Main(string[] args)
    {
        int i = 5;
        Person p = new Person();

        TestZhi(i, p);
        Console.WriteLine($"out: i: {i}, age: ${p.Age}");
    }

    static void TestZhi(int ii, Person pp)
    {
        ii = ii + 1;
        pp.Age = pp.Age + 18;
        Console.WriteLine($"in:  i: {ii}, age: ${pp.Age}");
    }

    class Person
    {
        public int Age = 18;
    }
#+end_src

ref:
#+begin_src cs
  static void Main(string[] args)
  {
      int i = 5;
      Person p = new Person();
  
      TestZhi(ref i, p);
      Console.WriteLine($"out: i: {i}, age: ${p.Age}");
  }
  
  static void TestZhi(ref int ii, Person pp)
  {
      ii = ii + 1;
      pp.Age = pp.Age + 18;
      Console.WriteLine($"in:  i: {ii}, age: ${pp.Age}");
  }
  
  class Person
  {
      public int Age = 18;
  }
#+end_src

out:
#+begin_src cs
  static void Main(string[] args)
  {
      int i;
      Person p = new Person();
  
      TestZhi(out i, p);
      Console.WriteLine($"out: i: {i}, age: ${p.Age}");
  }
  
  static void TestZhi(out int ii, Person pp)
  {
      ii = 999;
      pp.Age = pp.Age + 18;
      Console.WriteLine($"in:  i: {ii}, age: ${pp.Age}");
  }
  
  class Person
  {
      public int Age = 18;
  }
#+end_src

#+ATTR_HTML: :width 400px
[[file:img/method-parameter.png]]


*** out 参数: 用来模拟方法返回多个值的场景

如果不用 out，可以使用 Class 的方式返回多个值，这种方式比较重:
#+begin_src cs
  static void Main(string[] args)
  {
      string name;
      int age;
      double sal;
  
      Person p = GetYourInformation();
      name = p.Name;
      age = p.Age;
      sal = p.Sal;
  }
  
  static Person GetYourInformation()
  {
      return new Person
      {
          Name = "Kitty",
          Age = 19,
          Sal = 2323323
      };
  }
  
  class Person
  {
      public string Name;
      public int Age;
      public double Sal;
  }
#+end_src

而 out 的方法比较轻量级:
#+begin_src cs
  static void Main(string[] args)
  {
      string name;
      int age;
      double sal;
  
      name = GetYourInformation(out age, out sal);
      Console.WriteLine($"{name} 的年龄为 {age} 收入为 {sal}，您可满意?");
  }
  
  static string GetYourInformation(out int age, out double sal)
  {
      age = 19;
      sal = 23232;
      return "Kitty";
  }
#+end_src

甚至可以更简化:
#+begin_src cs
  static void Main(string[] args)
  {
      string name = GetYourInformation(out int age, out double sal);
      Console.WriteLine($"{name} 的年龄为 {age} 收入为 {sal}，您可满意?");
  }
  
  static string GetYourInformation(out int age, out double sal)
  {
      age = 19;
      sal = 23232;
      return "Kitty";
  }
#+end_src

*** 数组参数 (params)

实现累加:
#+begin_src cs
  static void Main(string[] args)
  {
      // 加法
      int r1 = MyAdd2(2, 3);
      int r2 = MyAdd3(2, 3, 4);
  }
  
  static int MyAdd2(int a, int b)
  {
      return a + b;
  }
  
  static int MyAdd3(int a, int b, int c)
  {
      return a + b + c;
  }
#+end_src

使用数组改良的结果:
#+begin_src cs
  static void Main(string[] args)
  {
      int r1 = MyAdd(new int[] {2, 3});
      int r2 = MyAdd(new int[] {2, 3, 4, 5, 6, 7});
  }
  
  static int MyAdd(int [] nums)
  {
      int r = 0;
      for (int i = 0; i < nums.Length; i++)
      {
          r += nums[i];
      }
  
      return r;
  }
#+end_src

可以使用 params 修饰数组，达到进一步简化调用语法的目的:
#+begin_src cs
  static void Main(string[] args)
  {
      int r1 = MyAdd(2, 3);
      int r2 = MyAdd(2, 3, 4, 5, 6, 7);
      Console.WriteLine($"{r1} / {r2}");
  }
  
  static int MyAdd(params int [] nums)
  {
      int r = 0;
      for (int i = 0; i < nums.Length; i++)
      {
          r += nums[i];
      }
  
      return r;
  }
#+end_src

数组参数需要放到后面:
#+begin_src cs
  static void Main(string[] args)
  {
      MyAdd("最后求取的和是: 0x{0:X}", 232, 3, 10);
  }
  
  static void MyAdd(string fmt, params int [] nums)
  {
      int r = 0;
      for (int i = 0; i < nums.Length; i++)
      {
          r += nums[i];
      }
  
      Console.WriteLine(fmt, r);
  }
#+end_src

*** 可选参数/命名参数

#+begin_src cs
  static void Main(string[] args)
  {
      Hello();
      Hello("Hiii!");
      Hello("Hi", "Xiaoming");
  }
  
  static void Hello(string action = "Hello", string who = "World")
  {
      Console.WriteLine($"{action} {who}");
  }
#+end_src

可以使用命名参数，简化多个可选参数存在的情况下的赋值:
#+begin_src cs
  static void Main(string[] args)
  {
      Hello(who: "XM");
      Hello(who: "Xiaoming", action: "out...");
  }
  
  static void Hello(string action = "Hello", string who = "World")
  {
      Console.WriteLine($"{action} {who}");
  }
#+end_src

** 属性 (Property)

属性本身就是 [private Field + public Method] 一种语法糖:
- 它能减少太多冗余的模板代码；它能简化对实例中数据的可控性的访问，让代码更简洁
- 但是不要忘了，它跟 getter/setter 方法的本质是一样的。最后编译器还是将我们写的属性代码转换成了 getter/setter 方法的形式
- 也就是说 ~r.Width = 333~ 这样的属性赋值，本质就是方法调用

示例:
#+begin_src csharp
  class Rect
  {
      public double Width { get; set; }
      public double Height { get; set; }
      public double Area
      {
          get
          {
              return Width * Height;
          }
      }

      // private double Height;
      // public double GetHeight ()
      // {
      //     return Height;
      // }
      // public void SetHeight (double h);
      // {
      //     Height = h;
      // }
  }

  class Program
  {
      static void Main()
      {
          Rect r = new Rect();
          r.Width = 2000;
          r.Height = 333;
          Console.WriteLine("面积是: {0}", r.Area);
      }
  }
#+end_src

** 构造方法/构造器 (Constructor)
*** 对象的实例化

对象的实例化，分为下面几个步骤:
1. 在内存中，分配相应的空间
2. 按照类型进行相关字段的初始化工作
3. 调用相应的 *构造方法*，进行相关初始化工作

*** 构造器

所谓的构造方法，就是类中定义的一个特殊方法。它用来对实例空间进行若干初始化工作:   
- 构造方法可以写多个，即可以重载 (overload)
- 我们也可以不写任何构造方法，那么编译器在编译的时候，会自动帮我们插入一个 *无参的空的*。
  但是，如果你在类中，定义了任何的构造方法，那么编译器就不会帮你再生成了

#+begin_src csharp
  class X
  {
      public X()
      {
      }
      public X(int a, int b) // 2
      {
      }
  }

  class Program
  {
      static void Main()
      {
          new X(); // 如果没有参数，那么会调用无参构造器 1
          new X(1, 2); // 回去调用相应的具备两个参数，并且类型正确的构造器 2
      }
  }
#+end_src

*** 构造器链

- 如果不显式继承某个类，那么继承的将是 object。即可以忽略掉 ~: Object~
- 如果不显式添加构造器，那么编译器会自动插入一个无参的。即可以省略掉 ~public Son() {}~
- 如果不显式指定构造器顺序，那么任意构造器都会首先执行父类的无参构造器。即可以省略掉 ~: base()~
- 显式指定构造器顺序，需要手动添加 ~: base(xxx)~ 或者 ~: this(xxx)~
- 基本的规则是: 从下往上寻找，然后从上往下执行。这样就构成了 *构造器链*

#+begin_src csharp
  class GP
  {
      public GP() : base() // 4
      {
          Console.WriteLine("我是你爷爷");
      }
      public GP(string address) : base()
      {
          Console.WriteLine("爷爷我的地址是 {0}", address);
      }
      public GP(string name, string address) : base()
      {
          Console.WriteLine("爷爷 {0} 的地址是 {0}", name, address);
      }
  }
  class PP : GP
  {
      public PP() : base()
      {
          Console.WriteLine("我是爸爸");
      }
      public PP(string address) : base() // 3
      {
          Console.WriteLine("爸爸我的地址是 {0}", address);
      }
      public PP(string name, string address) : base()
      {
          Console.WriteLine("爸爸 {0} 的地址是 {0}", name, address);
      }

  }
  class You : PP
  {
      public You() : base()
      {
          Console.WriteLine("我的儿子");
      }
      public You(string name) : this(name, "广西") // 1
      {
          Console.WriteLine(name);
      }
      public You(string name, string addr) : base(addr) // 2
      {
          Console.WriteLine("{0} 的 {1}", addr, name);
      }

  }
  class Son : You
  {
  }

  You u = new You("张三");
#+end_src

*** 静态构造器

- 构造器是用来初始化 *对象* 的
- 静态构造器是用来初始化 *类* 的
- 对象的初始化工作，是在代码中通过 new Class 的方式触发的
- 类的初始化工作，是由 CLR 自动执行的，一般来说，你第一次使用到某个类的时候，这个类就会 *被* 自动加载
- 静态的构造器，只能有一个，而且不能带任何参数

#+begin_src csharp
  class TipCalculator : CalculatorBase
  {
      static TipCalculator()
      {
          Console.WriteLine("我是一个带 static 的构造器");
      }
  }
#+end_src

** 析构方法/析构器 (Deconstructor)

#+begin_src csharp
  ~TipCalculator()
  {
      Console.WriteLine("我死的好惨啊");
  }

  ~文件()
  {
      this.Close();
  }
#+end_src

** 静态方法 (Static)

将归属权，交给类。调用的时候，使用 ~类名.xxx~ 方式。

** 将数据设置为不变的 (const/readonly)

: 通过 private 等操作符可以保护数据的外部访问安全
: 通过 const/readonly 可以防止内鬼

const:
- 即常量
- 基于编译期的替换，运行期是没有任何这个变量的信息的
- 相对来说，它不需要占用存储，而且不需要运行时检查，所以效率高
- 它的使用限制较多，比如，只能将一些简单的值赋予它
- 不能添加 static 修饰，但可以使用 ~类名.PI~ 来访问

readonly:
- 限定变量只能读，不能修改
- 可以修饰任何的字段，不管是不是静态的
- 相对来说，需要占用空间、需要运行时检查，效率会低一些
- *注意*，使用 readonly 修饰数组等变量，虽然可以防止数组被重新赋值，但不能避免里面的元素被修改

有内鬼，停止交易:
#+begin_src csharp
  class Congming
  {
      private const double PI = 3.1415926;
      private readonly double pppi = 3.14;

      public double QiuMianJi(double r)
      {
          pppi = 333;  // x
          PI = 333;    // x
          return pppi * r * r;
      }
  }
#+end_src

** 继承 (Inheritance)

- 继承表示，我的是我的，你的也是我的。使用 ~:~ 语法表示继承关系
- 继承主要用来消除冗余，让逻辑得以 *复用*。逻辑上来说，跟自然界的分门别类是对应一致的
- new 对象的时候，会 *开辟空间、初始化字段、调用构造器*。如果存在继承关系的话，创建的实例是分为多部分的
- 调用实例上的某个方法 A，如果 A 调用了另一个方法 B，这时候，优先会使用 A 自身部分上面定义的 B。
  如果想让 A 调用的 B 是派生类 *最下面* 的 B 的话，使用 ~virutal/override~ 将 B 设置为 *虚函数* 即可。
  子类中存在的相同方法，如果不是 override 的，那么将会是 new 的。new 可以不写
- 在 C# 中，只允许有一个父类，即 *单继承*
- 所有类的根基类是 *object*。object 中定义了 ToString/GetType/Equal 等方法。因此，所有的对象都拥有这几个方法
- 在方法中，使用 *this* 表示当前的对象，使用 *base* 表示父类部分。base.Xxx 表示调用父类部分的 Xxx
- 使用 private 修饰的数据不能被继承使用，这时候应该使用 *protected*

基本语法:
#+begin_src csharp
  class A : object { void Say() {Console.WriteLine("hello");} }
  class B : A {}
  class C : B { void Say() {Console.WriteLine("world");} }
  class D : C {}
  D d = new D();
  d.Say();
#+end_src

*** 虚方法 (virtual/override)

虚函数:
#+begin_src csharp
  class A
  {
      public string Name() { return "hello"; }
      public void Say() { Console.WriteLine(this.Name()); }
  }
  class B : A
  {
      public virtual string Name() { return "world"; }
      public new void Say() { Console.WriteLine("heihei" + Name()); base.Say(); }
  }
  class C : B
  {
      public override string Name() { return "who"; }
      public virtual void Say() { Console.WriteLine("hahaha" + Name()); }
  }
  class D : C
  {
      public override string Name() { return "ryou"; }
  }
  var d = new D();
  d.Say();
#+end_src

虚不虚?
#+begin_src csharp
  class A
  {
      public string Name() { return "hello"; }
      public virtual void Say() { Console.WriteLine(this.Name()); }
  }
  class B : A
  {
      public new virtual string Name() { return "world"; }
      public override void Say() { Console.WriteLine("heihei" + Name()); base.Say(); }
  }
  class C : B
  {
      public override string Name() { return "who"; }
      public override void Say() { Console.WriteLine("hahaha" + Name()); }
  }
  class D : C
  {
      public override string Name() { return "ryou"; }
  }

  A a = new D();
  a.Say();
#+end_src

#+begin_src csharp
  class GrandPP
  {

  }
  class PP : GrandPP
  {

  }
  class You : PP
  {
      public You()
      {
          Console.WriteLine(".");
      }
      public You(string name)
      {
          Console.WriteLine(name);
      }
      public You(string name, string addr)
      {
          Console.WriteLine(name + ":" + addr);
      }

  }
  new You();
  new You("张三");
  new You("张三", "湖南");
#+end_src

*** 抽象方法 (abstract)

- 继承下来的，不一定是权利，也有可能是义务。俗语有云 *父债子偿*
- 通过在父类中，将某个方法用 ~abstract~ 修饰，表示它是债务...
- 抽象方法可以 (1) 约束子类的行为 (2) 将父类中无法实现的功能，交给子类去实现
- 抽象类是不能被实例化的

#+begin_src csharp
  abstract class Baba
  {
      public double Money = 0.1;

      public virtual void Sanjuhua()
      {
          Console.WriteLine("漂亮的女孩子都比较危险");
          Console.WriteLine("我有很多钱，藏在某个地方");
          Console.WriteLine("但我不告诉你在哪里");
      }

      public abstract void 花光这些钱();
  }

  class You : Baba
  {
      public override void Sanjuhua()
      {
          Console.WriteLine("漂亮的女孩子是值得我们花一生去追求的");
          Console.WriteLine("我有很多钱，就放在中国银行的钱库里");
          Console.WriteLine("但不要把钱放眼里，作为真男人，要敢于 996，奉献人生价值");
      }

      public override void 花光这些钱()
      {
          Console.WriteLine("第一天，花了 3 亿");
          Console.WriteLine("第二天，花了 33 亿");
          Console.WriteLine("第三天，花了 333 亿");
          Console.WriteLine("第四天，梦醒了");
      }
  }
#+end_src

** 多态 (Polymorphism)

多态是一个来自生物学上的概念，[[https://baike.baidu.com/item/%E5%A4%9A%E6%80%81%E7%8E%B0%E8%B1%A1][参见百度百科]]:
- 在语言中，多态指调用同一个类型的相同方法/属性，会产生不同结果的现象。
  产生不同结果的原因是方法实质调用了不同派生类中的不同实现。
- 虚方法是实现多态性的主要手段，接口和抽象类是多态的充分体现

#+begin_src csharp
  // 批量处理 (关心的是共性)

  Animal[] animals = new Animal[3];
  animals[0] = new Animal();
  animals[1] = new 美女();
  animals[2] = new 野兽();

  for (int i = 0; i < animals.Length; i++)
  {
      Animal a = animals[i];
      a.Eat();
      a.Sleep();
      a.WakeUp();
      a.Drink();
  }

  // 适配的参数类型
  interface 能干活的东西 { void 干活(); }
  class 人 : 能干活的东西 { void 干活 () { ... }; }
  class 猪 : 能干活的东西 { void 干活 () { ... }; }

  void 招聘 (能干活的东西 x) {
      x.干活();
  }
  招聘(人);
  招聘(猪);

  // 适配的返回值 (约定跟实现的和谐)

  Dog GiveADog()
  {
      return new 二哈();
  }
  Animal aaa = GiveADog();

  // 接口与多态

  IHelpable xxx = new TipCalculator(222);
  xxx.Help();
#+end_src

** 静态类/static

限制里面所有的方法，必须是静态的。典型的代表是 Math 类。

** 密封类/sealed

这就从语法上，避免了某个类被继承的可能。

** 分部类/partial

让类可以写成多部分。在编译的环节，编译器将会帮助我们自动合并之后再编译。

#+begin_src csharp
  partial class MyLove
  {
      public void 你想我吗()
      {
      }
  }

  partial class MyLove
  {
      public void 我想你()
      {
      }
  }
#+end_src

** 基类 Object
*** ToString

#+begin_src csharp
  class TipCalculator : CalculatorBase
  {
      public override string ToString()
      {
          return $"我是一个账单类，传入的参数是 {Bill}";
      }
  }
  Console.WriteLine("{0}", new TipCalculator(200));
#+end_src

* 接口 (Interface)

- 接口本质就是一个可以进行 *多继承* 的纯的抽象类。它是单继承的一种例外
- 使用 interface 关键词声明接口，接口里面只能包含方法。按照习惯，一般使用 IXxx 的方式命名接口
- 不需要使用 public 修饰符，因为接口里所有方法默认都是公开的。方法不需要有方法体
- 接口实际上就是一种 *合同*，它起到的作用是制定统一的 *规则*
- 接口有很多好处: blahblahblah... 面向接口编程是一种好的编程实践

** IComparable 接口使用示例

IComparable 用来为两个对象进行比较提供比较的规则:
#+begin_src csharp
  class Person : IComparable
  {
      public string Name { get; set; }
      public double Salary { get; set; }
      public int Age { get; set; }

      public Person(string name, double sal, int age)
      {
          Name = name;
          Salary = sal;
          Age = age;
      }

      public int CompareTo(object? obj)
      {
          var wo = this;
          var ni = (Person) obj;

          // if (wo.Salary > ni.Salary) return -1;
          // if (wo.Salary < ni.Salary) return 1;
          // return 0;
          return wo.Salary - ni.Salary;
      }
  }

  static void Main(string[] args)
  {
      var p1 = new Person("a-小明", 20000, 50);
      var p2 = new Person("c-小张", 7000, 25);
      var p3 = new Person("b-小王", 15000, 35);
      var p4 = new Person("d-小红", 7500, 19);
      var p5 = new Person("e-小强", 5000, 22);

      var persons = new Person[] {p1, p2, p3, p4, p5};

      Array.Sort(persons);

      foreach (var p in persons)
      {
          Console.WriteLine($"{p.Name}: {p.Age} 岁, 收入为 {p.Salary}");
      }
  }
#+end_src

* 结构体 (Struct)

- 它跟 class 非常像，但它是值类型
- 由于是值类型，所以效率高:
  + 栈上，用完退栈，不需要垃圾回收
  + 对象内部
- 实际上，我们的常见预定义类型，都是实现为 struct (int/float)
- 结构体，默认是密封的，因此，它不能继承
- 它支持 partial 的用法
- 它支持使用构造器:
  + 在构造器中，需要确保为每个成员赋值
  + 包含一个默认构造器，里面会对所有成员进行初始化，我们不能将其覆盖掉
- 它不需要，也不能有析构方法

#+begin_src cs
  static void Main(string[] args)
  {
      TestStuct();
      Console.WriteLine("结束了");
  }
  
  static void TestStuct()
  {
      YellowMan a = new YellowMan();
      a.Name = "小黄人甲";
      a.Score = 333.4;
  
      YellowMan b = new YellowMan();
      b.Name = "小黄人乙";
      b.Score = 133.4;
  
      b.ZiWoJieShao();
      Console.WriteLine(b);
  
      var d = new YellowMan("kkk", 222);
      Console.WriteLine(d.Name);
  }
  
  struct YellowMan
  {
      public string Name;
      public double Score;
      public int Age;
  
      public YellowMan(string n, double s)
      {
          Name = n;
          Score = s;
          Age = 23;
      }
  
      public void ZiWoJieShao()
      {
          Console.WriteLine($"我是 {Name},我的可爱程度为 {Score}");
      }
  
      public override string ToString()
      {
          return "hello, 小黄人";
      }
  }
  
  class B
  {
      private YellowMan c = new YellowMan();
  }
#+end_src

* 枚举 (Enum)

int/1 2 3 .. ..  3
double .....
bool: true/false

Gender (男/女/未知)

** 基本使用

#+begin_src csharp
  static void Main(string[] args)
  {
      checked
      {
          Console.WriteLine((int)Gender3.女);
          Console.WriteLine((int)Gender3.男);
          Console.WriteLine((int)Gender3.我也不知道是男是女它到底是男是女呢谁知道呢不管他了);
      }
  
      if (Gender4.我也不知道是男是女它到底是男是女呢谁知道呢不管他了 == Gender4.男)
      {
          Console.WriteLine("Yes.");
      }
  }
  
  enum MyBool
  {
      True,
      False
  }
  
  enum Gender
  {
      男,
      女,
      我也不知道是男是女它到底是男是女呢谁知道呢不管他了
  }
  
  enum Gender2
  {
      男 = 0,
      女 = 1,
      我也不知道是男是女它到底是男是女呢谁知道呢不管他了 = 2
  }
  
  enum Gender3
  {
      男 = 110,
      女,
      我也不知道是男是女它到底是男是女呢谁知道呢不管他了 = 120
  }
  
  enum Gender4
  {
      男 = 110,
      女,
      我也不知道是男是女它到底是男是女呢谁知道呢不管他了 = 男
  }
  
  enum Gender5 : short
  {
      男 = 110,
      女,
      我也不知道是男是女它到底是男是女呢谁知道呢不管他了 = 男
  }
  
  class MyGender
  {
      public const int 男 = 0;
      public const int 女 = 1;
      public const int 我也不知道是男是女它到底是男是女呢谁知道呢不管他了 = 2;
  }
#+end_src

** Flags (TODO)

#+begin_src cs
  [Flags]
  enum FeichangJincouDeLeixing
  {
      A = 0x12,
      B = 0x13
  }
  
  111111
  101001
#+end_src

** 基本 API

#+begin_src cs
  foreach (string name in Enum.GetNames(typeof(Gender)))
  {
      Console.WriteLine(name);
  }
  foreach (var v in Enum.GetValues(typeof(Gender)))
  {
      Console.WriteLine((int)v);
  }
#+end_src

* 委托 (Delegate)

写一个方法 MyAdd ，求取 *若干数* 的和。
#+begin_src cs
  static void Main(string[] args)
  {
      // Console.ForegroundColor = ConsoleColor.Red;
      // Console.WriteLine(sum);
      // Console.ResetColor();
      // 将上面三局，放到一个对象里，然后
      object o1 = null;
  
      int r1 = MyAdd(o1, 12, 32, 1112232, 43, 1112212, 3232323, 123);
      int r2 = MyAdd(o2, 222, 333, 444);
      int r3 = MyAdd(o3, 11, 2323, 4344);
  }
  
  public static int MyAdd(object gaosuwogaigansm, params int[] nums)
  {
      int sum = 0;
      for (int i = 0; i < nums.Length; i++)
      {
          sum += nums[i];
      }
      // Console.ForegroundColor = ConsoleColor.Red;
      // Console.WriteLine(sum);
      // Console.ResetColor();
  
      // Console.BackgroundColor = ConsoleColor.Red;
      // Console.WriteLine("和为："+sum);
      // Console.ResetColor();
  
      // File.AppendAllText(@"E:\jiafa.txt", sum + "\r\n");
  
      // SpeechSynthesizer synth = new SpeechSynthesizer();
      // synth.Speak(sum.ToString());
      // synth.Dispose();
  
      Bitmap image = new Bitmap(256, 256);
      using (Graphics g = Graphics.FromImage(image))
      {
          g.FillRectangle(Brushes.Yellow, 0, 0, 256, 256);
          g.DrawString(sum.ToString(), new Font("Monospace", 26), Brushes.DarkGreen, 10, 10);
      }
      image.Save(@"e:\hello.jpg");
  
      return sum;
  }
#+end_src

通过一个 Flag 来通知 MyAdd 要去调用什么逻辑:
#+begin_src cs
  class Program
  {
      static void Main(string[] args)
      {
          int r1 = MyAdd(1, 12, 32, 1112232, 43, 1112212, 3232323, 123);
          int r2 = MyAdd(2, 222, 333, 444);
          int r3 = MyAdd(4, 11, 2323, 4344);
      }
  
      public static int MyAdd(int flag, params int[] nums)
      {
          int sum = 0;
          for (int i = 0; i < nums.Length; i++)
          {
              sum += nums[i];
          }
  
          if (flag == 1)
          {
              Print1(sum);
          }
          else if (flag == 2)
          {
              Print2(sum);
          }
          else if (flag == 3)
          {
              ToFile(sum);
          }
          else if (flag == 4)
          {
              Speech(sum);
          }
          else
          {
              Draw(sum);
          }
  
          return sum;
      }
  
      static void Print1(int sum)
      {
          Console.ForegroundColor = ConsoleColor.Red;
          Console.WriteLine(sum);
          Console.ResetColor();
      }
  
      static void Print2(int sum)
      {
          Console.BackgroundColor = ConsoleColor.Red;
          Console.WriteLine("和为：" + sum);
          Console.ResetColor();
      }
  
      static void ToFile(int sum)
      {
          File.AppendAllText(@"E:\jiafa.txt", sum + "\r\n");
      }
  
      static void Speech(int sum)
      {
          SpeechSynthesizer synth = new SpeechSynthesizer();
          synth.Speak(sum.ToString());
          synth.Dispose();
      }
  
      static void Draw(int sum)
      {
          Bitmap image = new Bitmap(256, 256);
          using (Graphics g = Graphics.FromImage(image))
          {
              g.FillRectangle(Brushes.Yellow, 0, 0, 20, 20);
              g.DrawString(sum.ToString(), new Font("Monospace", 26), Brushes.DarkGreen, 10, 10);
          }
          image.Save(@"e:\hello.jpg");
      }
  }
#+end_src

* BCL (Base-Class Library) 基础类库
** Console/控制台

相关方法和属性:
- Console.Write/WriteLine，用来向控制台输出内容
- Console.Clear，用来清空屏幕内容
- Console.ForegroundColor/BackgroudColor/ResetColor，用来设置控制台颜色
- Console.ReadLine，用来从控制台读取用户输入的字符串
- Console.ReadKey，用来读取按键，返回一个 ConsoleKeyInfo 对象
- Console.Beep，用来让控制台发出声音

相关类和结构:
- Console
- ConsoleColor
- ConsoleKey/ConsoleKeyInfo

示例:
#+begin_src csharp -n
  Console.WriteLine();
  while (true) // 通过 while 循环可以实现不断输入不断看到输入结果的过程
  {
      // ReadKey 是微软封装在 Console 里的一个方法，用来读取控制台上的按键
      // 我们不需要关心它怎么实现的，我们只需要关心它如何使用
      // 微软在实现里，将我们按下的键的信息，封装到了一个叫 ConsoleKeyInfo 的数据包里 (实例对象)
      // 调用 ReadKey 之后，就可以通过这个实例对象 key 所提供的可访问接口判断按键信息了
      ConsoleKeyInfo key = Console.ReadKey(true); // true 的意思是，不在屏幕上显示键入的字符
      if (key.Key == ConsoleKey.D1)
      {
          Console.WriteLine("您输入了一个 1");
      }
      else if (key.Key == ConsoleKey.S)
      {
          Console.Beep(); // Beep 是微软实现在 Console 里的一个方法，用来让控制台发出声音
      }
      else if (key.KeyChar == 'd')
      {
          Console.Beep(600, 200); // Beep 方法是重载的，它可以携带参数
      }
      else if (key.KeyChar == 'f')
      {
          Console.Beep(200, 200);
      }
      else if (key.Key == ConsoleKey.Enter)
      {
          break;
      }
      else
      {
          Console.WriteLine($"key: {key}, keyChar: {key.KeyChar}, key: {key.Key}");
      }
  }
#+end_src

** Random/Thread

#+begin_src csharp
  ConsoleColor[] colors = new ConsoleColor[]
  {
      ConsoleColor.Red, ConsoleColor.Green, ConsoleColor.Yellow
  };

  int i = 0;
  while (true)
  {
      // Console.WriteLine("hello {0}", DateTime.Now);
      // var timer = new Timer(null, TimeSpan(1), TimeSpan(2));
      Thread.Sleep(1000); // 题外话，这个 1000 毫秒并不是非常准确
      // Task.Delay(1000).Wait();

      //Console.WriteLine(colors[i]);
      //i = i + 1;
      //if (i == 3) i = 0;

      //Console.WriteLine(colors[i]);
      //i = (i + 1) % 3;

      //Console.WriteLine(colors[(i++) % 3]);

      System.Random random = new System.Random();
      int r = random.Next(colors.Length); // Next(3): 0, 1, 2
      Console.WriteLine(colors[r]);

      Console.Clear(); // 清空屏幕
      Console.ResetColor(); // 重置颜色
  }
#+end_src

** IDisposable/资源

- 资源，是指需要在操作系统中打开，用完之后，需要手动释放的对象
- 为什么需要手动释放呢？因为 .NET 平台不是万能的。虽然 .NET 平台有垃圾回收器，你不再需要的
  对象，它会自动帮你清理掉，但是有些东西它是无法确定你到底还需不需要，所以无法帮助你自动处理。
  你也只能手动释放或关闭
- 对于一些资源，必须要手动释放或关闭

对于普通的对象，是可以被 GC 自动回收的:
#+begin_src csharp
  // 创建的任何对象，都是可以被垃圾回收器 (GC) 自动释放
  // 因此，我们只需要 new 然后使用就可以了，其他的内存管理无需你关心
  for (int i = 0; i < 100000000; i++)
  {
      var a = new Book(); // 创建多少个都会被自动释放，绝对安全
  }
#+end_src

但是对于一些依赖系统的资源，必须要手动释放:
#+begin_src csharp
  // 像文件这样的资源，打开之后，必须要手动释放
  var fs = File.OpenRead(fileName);
  Console.WriteLine(5/0); // 代表使用 (2)
  fs.Close();             // 手动关闭/释放

  // 上述的代码是有问题的，因为，如果 (2) 出现错误的话，那么释放的语句就无法执行
  // 为了解决这个问题，可以使用 finally 语法，对整个资源释放的代码进行重构
  FileStream fs = null;
  try
  {
      fs = File.OpenRead(fileName);
      Console.WriteLine(fs);
      Console.WriteLine(5/0);
      Console.WriteLine("其他你所需要做的事情");
  }
  finally
  {
      if (fs != null)
      {
          try
          {
              fs.Close();
          }
          catch
          {
              Console.WriteLine("关闭失败");
          }
      }
  }

  // 可以使用 using 对上述代码进行简化
  // 必须让 FileStream 里面实现一个叫 Dispose 的方法
  // 为了保证你必须实现一个 Dispose 方法，你必须要实现 IDisposable 接口
  using (FileStream fs = File.OpenRead(fileName))
  {
      Console.WriteLine(fs);
      Console.WriteLine(5/0);
  }

  // 最新的 C# 版本又给了新的糖
  using FileStream fs = File.OpenRead(fileName); // fs 在后面碰到 } 后，会自动释放
  Console.WriteLine(fs);
  Console.WriteLine(5/0);
#+end_src

* 技巧和示例
** 求余

求余经常用来将某个数 *转换* 为 0-N 区间的一个数。

示例一，结合循环使用:
#+begin_src csharp -n
  for (int i = 0; i < 1000; i++)
  {
      int f = ((i % 8) * 30) + 100;
      Console.Beep(f, 50);
      Thread.Sleep(800 - (i % 8) * 50);
  }
#+end_src

示例二，求余和数组的结合使用:
#+begin_src csharp -n
  int[] freqs = new int[] { 200, 300, 100, 600 };

  for (int i = 0; i < 1000; i++)
  {
      int f = freqs[i % freqs.Length];
      Console.Beep(f, 50);
      Thread.Sleep(800 - (i % freqs.Length) * 50);
  }
#+end_src

示例三:
#+begin_src csharp -n
  // 除了声音外，添加视觉效果
  // 原理是一样的
  int[] freqs = new [] { 200, 300, 100, 600 };
  ConsoleColor[] colors = new[] { ConsoleColor.Red, ConsoleColor.Green, ConsoleColor.Blue, ConsoleColor.Yellow };

  for (int i = 0; i < 1000; i++)
  {
      int p = i % freqs.Length;
      for (int j = 0; j < freqs.Length; j++)
      {
          if (j == p)
          {
              Console.ForegroundColor = colors[p];
          }
          else
          {
              Console.ResetColor();
          }
          Console.SetCursorPosition(j * 3, 0);
          Console.Write("●");
      }
      Console.Beep(freqs[p], 50);

      Thread.Sleep(500 - (p) * 50);
  }
  Console.WriteLine();
#+end_src

* 模拟题
** 继承相关

请问下面程序的输出是什么:
#+begin_src csharp
  class A
  {
      public string name = "aaa";

      public void Name()
      {
          Console.WriteLine("我是 {0}", name);
      }

      public void 自我介绍()
      {
          Name();
      }
  }

  class B : A
  {
      void Name()
      {
          Console.WriteLine("你是 {0}", name);
      }

      string name = "bbb";

      public void 自我介绍()
      {
          this.Name();
          Console.WriteLine("----");
          base.Name();
      }
  }

  class Program
  {
      static void Main()
      {
          B b = new B();
          b.自我介绍();
      }
  }
#+end_src


** 重载 (overload) 和 重写 (override) 有啥区别 (15 分)

重构 = 重新构造 = 将代码进行重写，让结构发生变化的行为
= 一般来说，是因为现有的代码不合理，所以呢，重新调整一下
= 一般来说，重构只是为了改变代码结构或代码质量，它不会对程序的运行逻辑进行改变

* 问题 (仅作参考)
** string 和 StringBuilder 有什么区别

- string 是一种预定义类型，它表达的是字符的有序组合
- StringBuilder 是定义在 BCL 中的类型，它主要用来进行字符串的拼接
- string 是不可变的，所以在进行拼接等操作的时候，效率会非常低
- StringBuilder 是可变的一种类型，所以在字符串拼接的时候，效率相对高多了
- 因此，在进行字符串拼接的操作的时候，我们一般使用 StringBuilder 进行构建，从而提升效率

** 什么是抽象类，抽象类有什么用处
** 什么是接口，什么是面向接口编程，面向接口编程有什么好处
** 什么是静态类，什么是密封类，什么是分部类
** 什么是类，什么是对象，对象的实例化过程是怎么样的
** 什么是面向对象编程，面向对象有什么特点，有什么好处
** 什么是字段，什么是方法，什么是属性。属性有什么好处
** 什么是封装，什么是继承，什么是多态
** 什么是虚方法，它有什么用处
** 什么是组合，它跟继承有什么区别，分别用在什么场景
** 什么是 DRY，代码复用的手段有哪些
** Parse/TryParse 有啥区别

- 这两个都是用来将字符串转换为其他类型
- 遇到转换失败的时候
- Parse 会直接抛出异常
- 而 TryParse，会根据是否转换成功返回 True/False,
  它不会抛出异常

** 什么是装箱拆箱

- 装箱是将值类型转换为 object 的过程
- 拆箱是将装箱后的 object 转换为对应的值类型的过程

** 什么是值类型/引用类型

- 变量位置保存的是类型实例自身，这样的类型叫 *值类型*
- 变量位置保存的是类型实例的引用，这样的类型叫 *引用类型*  

** is/as 分别是干啥的

- is 用来判断左边的实例是否是右边的类型。是的 true，不是的话 false。
  它常用来跟显式转换配合使用
- as 和显式转换相似，但它不会抛出异常，如果成功返回转换结果，失败返回 null

