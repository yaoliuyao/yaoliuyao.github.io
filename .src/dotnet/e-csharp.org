#+TITLE: C♯


* 历史

- Visual J++ 被放弃，[[https://baike.baidu.com/item/%E5%AE%89%E5%BE%B7%E6%96%AF%C2%B7%E6%B5%B7%E5%B0%94%E6%96%AF%E4%BC%AF%E6%A0%BC][安德斯·海尔斯伯格]]带领团队从 2000 年左右开始开发了 C#，到 2002 年的的时候，开始提交给 ECMA 成为了标准
- 因为安德斯他的个人经历，所以 C# 深受 Pascal/C++/Java 的影响
- 到现在，C# 已经成为了一种多范式的语言。首先它是一门纯粹的面向对象的语言 (封装、继承、多态)，提供了面向组件编程的一些改进 (属性、委托、事件)

C# 版本演化:
- 1.0 纯粹的面向对象 (2002)
- 2.0 增加了泛型的概念 (2005)
- 3.0 增加了 LINQ 功能 (2008)
- 4.0 增加了命名参数和可选参数的功能，并添加了动态编程的支持 (2010)
- 5.0 增加了 async/await 的异步编程范式 (2012)
- 6.0 推进了跟 .NET Core 的语言共享 (2015)
- 7.0 添加了函数式编程的一些特性，如果模式匹配、元组等等，包括其他一些优化 (2017)
- 8.0 开始支持默认接口方法，可空引用类型，switch 表达式等 (2019)
- 9.0 增加了 Record 类型，继续对 switch 表达式等进行简化跟优化 (2021)
  
* [语言与类型]

在 C# 等面向对象的语言中，*类型 (Type)* 是第一位的
- 在 C# 中，不外乎做两件事，第一件是引入别人的类型，第二件是声明自己的类型
- 也就是说，整个 C# 项目，是由不同的 *类型声明* 组成的
- 在整个 C# 项目中，需要 *有且只有一个* 特殊的方法，就是 Main 方法。它是程序执行的起点
- 通过引入 *命名空间 (namespace)* 的概念，用来组织各种类型，从而避免命名冲突

#+ATTR_HTML: :width 400px
[[file:img/types.png]]

#+ATTR_HTML: :width 400px
[[file:img/types-2.png]]

** Main

#+begin_src csharp
  static int Main (string[] args)
  {
      return 如果正常返回则是 0，否则是一个整数代表错误编号;
  }

  static void Main (string[] args)
  {
      // 如果真的不关心返回的错误编号的话，可以将返回值设置为 void

      // 可以使用 args 来捕获从控制台输入的参数 (用空格分隔的元素)
      if (args.Length > 0 && args[0] == "--help")
      {
          Console.WriteLine("使用方式: ./Program");
      }
  }

  static void Main ()
  {
      // 如果你真的不在乎传入参数的话，那么将 args 省略掉也可以
  }

  static async void Main()
  {
      await CCCAync();
      await AAA();
      await BBB();
      DDD();
  }
#+end_src

args 使用的另一个示例:
#+begin_src csharp
  static void Main(string[] args)
  {
      if (args.Length == 1)
      {
          if (args[0] == "--help")
          {

              Console.WriteLine("使用方法: dotnet run 2223");
          }
          else
          {
              double bill = double.Parse(args[0]);
              var calc = new TipCalculator(bill);
              calc.PrintToConsole();
          }
      }
      else
      {
          Console.WriteLine("参数错误.");
      }
  }
#+end_src

** 命名空间

- 用来解决类型名字的冲突
- 用来合理组织类型

*** 使用

#+begin_src csharp
  // 类型的使用，可以通过 namespace.类型 来访问到 / full name
  System.String aaa = System.IO.File.ReadAllText("e:\\aaa.txt");
  System.Console.WriteLine(aaa);
  System.Console.WriteLine("hello");

  // 可以借助 using 命名空间的方式，简化类型的使用
  using System;
  using System.IO;
  string aaa = File.ReadAllText("e:\\aaa.txt");
  Console.WriteLine(aaa);
  Console.WriteLine("hello");

  // 可以使用 using static 的语法继续进行简化
  using static System.Console;
  using static System.IO.File;
  string aaa = ReadAllText("e:\\aaa.txt");
  WriteLine(aaa);
  WriteLine("hello");

  // 可以使用 using = 的方式，为命名空间起一个别名。这种方式一般用来解决冲突
  using SI = System.IO;
  using HisSystem;
  SI.File.xxx();  // System.IO.File.xxx();
  File.xxx();     // HisSystem.FIle.xxx();
#+end_src

*** 定义

支持嵌套，支持使用 . 的形式进行简写:
#+begin_src csharp
  using SI = System.IO; // File

  namespace TaxCalculator
  {
      namespace Hi
      {
          namespace Ih // TaxCalculator.Hi.Ih.Boy
          {
              class Boy
              {
              }
          }
          class Girl // TaxCalculator.Hi.Girl
          {
          }
      }

      namespace A.B.C.D.E.F
      {
          namespace G.H.X
          {
              using static System.Console;
              namespace Y
              {
                  class Hello
                  {
                      void Say()
                      {
                          WriteLine("hello");
                      }
                  }
              }
          }
      }

      namespace B
      {
          using System;
          class Program // TaxCalculator.Program
          {
              static void Main()
              {
                  string aaa = SI.File.ReadAllText("e:\\aaa.txt");
                  Console.WriteLine(aaa);
                  Console.WriteLine("hello");
              }
          }
      }
  }
#+end_src

*** BCL/System

System 命名空间:
- System.IO (Input/Output), 文件的处理
- System.Drawing, 绘制图片
- System.Collections，集合类型
- System.Net，网络访问
- System.Text，跟文本相关的内容，比如正则表达式
- System.Threading，多线程
- System.Threading.Tasks，异步编程

** 模板 vs 实例

类型就是用来创建数据结构的一种 *模板*：
- 类型本身并不是真正的数据，它只是描述了数据应该怎么被构造出来
- 类型它需要有名字，占用的空间，包括一系列的属性和行为

通过某个类型模板创建实际的对象，称作 *实例化* 该类型:
- 它就是真正的数据。类型的实例，类型的对象。所有的数据都是要根据类型创建出来的
- 类型的话，要么是平台预定义的，要么是 BCL/FCL 中定义的，要么是你自己声明的

#+begin_src csharp
  // 1 声明
  class xxx
  {
      int age;
      string name;
  }
  class yyy
  {
      int i;
      xxx xxx; // 2 使用
  }

  new yyy(); // 2 使用

  int a = 333; // 不需要声明，直接实例化
#+end_src

** 值类型 vs 引用类型

内存分为两部分:
- 栈 (Stack)，速度快
- 堆 (Heap)，容积大

#+ATTR_HTML: :width 500px
[[file:img/value-type-ref-type.png]]

* 预定义数值类型
** 整数

为了表示显示世界中的计算，人们发明了数字的记法:
- 通用的计算方式是 *十进制* (因为人自古来来，都有十根手指头)
- 计算机内部使用的是 *二进制* (因为使用电子元件状态表达 0/1 是最简单的)
- 人们一般使用 *十六进制* 来描述计算机中的二进制 (其表达能力更强，且能跟字节为单位的二进制形成对应关系)

为了能在计算机中有效存储整数，C# 中预定义了如下类型:
- byte (字节，使用 8bit 表示，它的表现能力最差，只有 0 ~ 255)
- short (短整数，使用 2Byte 表示，能表示到 3 万大小)
- int (整数，4B 长度，能表达到 20 多亿)  
- long (长整数，16B 长度，能表达到亿亿的单位)

另外，考虑是否设置符号位 (Sign/Unsign)，上面的类型又有对应的类型:
- sbyte
- ushort
- uint
- ulong

上述的类型都是用来创建整数数据的模板，它们的区别在于占用空间和表达里。
选择类型的根据是:
- 占用小的，表达能力差；占用大的，表达能力强
- 在业务的允许范围内，尽量选择占用空间小的类型
- 如果不好决定使用声明类型，优先使用 int

整数:
#+begin_src csharp
  byte aa = 0;
  byte az = 255;
  sbyte ba = -128;
  sbyte bz = 127;

  short s1 = -32768;
  short s2 = 32767;
  ushort s3 = 0;
  ushort s4 = 65535;

  int i1 = -2147483648;
  int i2 = 21_4748_3647;
  uint i3 = 42_9496_7295;

  long l1 = 3232323232335555355;
  ulong l2 = 23333333333333333;

  Console.WriteLine(0.1 + 0.2);
  Console.WriteLine(100 * 0.28);
  Console.WriteLine(100 * 0.27);

  byte a = 1;
  short b = 1;
  int c = 1;
  long d = 1;

  // C# 现在允许使用分隔符描述数字，这样具备更好的可读性
  long xxx = 11_1161_1311_4441_2323;
  int yyy = 2323;
#+end_src

可以直接使用二进制/十六进制的方式描述数字:
#+begin_src csharp
  byte zzz = 0b11111111;
  Console.WriteLine(zzz);

  // 16 进制 10 2 
  // 0,1,10,11,100,101,110,111
  // 1,2,..9,10,11,12..19
  // 1, 2,...9, a, b, c, d, e, f / 15, 1111
  // 10, 11, 12 .. 1e, 1f     0001_1111
  // 20,...............2f
  // 30................3f
  //                   9f
  // a0................af
  // b0................bf
  // c0................cf
  // d0................df
  // e0................ef
  // f0..............fe.ff 256 1111_1111
  // 100 .. 101. .....

  Console.WriteLine(0b11111111_11111110_11111111);
  Console.WriteLine(0x1e);
  Console.WriteLine(0xff_fe_ab_12);
  Console.WriteLine(2222323);
#+end_src

#+ATTR_HTML: :width 400px
[[file:img/integers.png]]

** 浮点数

- 根据存储形式，分为单精度 (float) 和双精度 (double)
- *float* 使用 32bit 来存储 (1 个符号位 8 个指数位 23 个尾数)
- *double* 使用 64bit 来存储 (1 个符号位 11 个指数位 52 个尾数)
- 一个小数，转换为计算机存储的形式，难免会有精度的损失。因此
  + 0.1 + 0.2 ≠ 0.3
  + 0.6 + 0.7 = 1.2999999999999998
  + 0.28 * 100 = 28.000000000000004
- 可以使用 *decimal* 类型，来表示更加精确的数值计算
  + 它的优点是，可以进行精确的计算
  + 它的缺点是，它需要占用更大的存储空间 (128bit)

#+ATTR_HTML: :width 500px
[[file:img/float-type.png]]

** Literate (字面量表达)

#+begin_src csharp
  // 字面量
  // 1112 int
  // 1112L long
  // 1112UL Unsigned Long
  // 1112F float
  // 1112.0 double
  // 1112M decimal
  Console.WriteLine(0.1M + 0.2M);

  double a = 2222;
  float b1 = 33332332323233;
  float b2 = 2323F;
  decimal c = 3.222M;

  int x = 333;
  long y1 = 54444;
  long y2 = 54444L;
#+end_src

* 预定义/非数值·值类型
** 字符类型 (char)

字符集/编码格式:
+ 最原始的英文中的 *ASCII* 编码
+ 后来出现的，各个国家的，比如 *GBK/Big5*
+ 为了消除字符集冲突，出现的 *Unicode* 组织跟字符集。并根据字符集出现了 *UTF-16/UTF-8* 等编码格式

Q & A:
- ucs-2 vs UTF-16 ????
- UTF8 怎么的格式 ????

#+ATTR_HTML: :width 500px
[[file:img/unicode.png]]

因此，在 C# 中内部，字符是使用 UTF-16 格式存储的。
#+begin_src csharp
  char a = 'x';

  char a = 'x';
  char b = '中';
  char c = '☺';
  char d = '⁞';
#+end_src

** 布尔类型 (bool)

#+begin_src cs
  bool a = true;
  bool b = false;
  
  bool c = 1 > 2; // > < == >= <=
  bool d = 1 == 2;
  
  a = !!!!!a; // 反
  a || b;     // 或
  a && b;     // 与
  
  a = true; b = false; d = true; e = false;
  f = true; g = true; h = false;
  
  ((a || b) && (c && d)) || e && (f || g) || h;
#+end_src

*** [条件分支] 在某种条件之下，做某件事

- if/else if/else
- switch (statement/expression)

if:
#+begin_src cs  
  // 1
  if (aaa)
  {
      Console.WriteLine("满足则执行，否则跳过");
  }
  Console.WriteLine("您说我什么条件会被执行?");
  
  // 2
  int score = 59; // 分数
  if (score > 70)
  {
      Console.WriteLine($"现在你的成绩是: {score}");
  }
  else
  {
      Console.WriteLine("您的成绩还可以啦，请下一次更加优秀哦.");
  }
  
  // 3
  int score = 59;
  if (score > 70)
  {
      Console.WriteLine($"现在你的成绩是: {score}");
  }
  else
  {
      if (score < 30)
      {
          Console.WriteLine("您太棒了，把您爸爸妈妈请过来一起分享这份荣耀吧.");
      }
      else
      {
          if (score > 60)
          {
              Console.WriteLine("您的成绩还可以啦，请下一次更加优秀哦.");
          }
          else
          {
              Console.WriteLine("您的成绩还可以啦...");
          }
      }
  }
  
  // 4
  if (score > 70)
  {
      Console.WriteLine($"现在你的成绩是: {score}");
  }
  else if (score > 60)
  {
      Console.WriteLine("您的成绩还可以啦，请下一次更加优秀哦.");
  }
  else if (score > 30)
  {
      Console.WriteLine("您的成绩还可以啦...");
  }
  else
  {
      Console.WriteLine("您太棒了，把您爸爸妈妈请过来一起分享这份荣耀吧.");
  }
#+end_src

switch (是 else if 语法的一种精简版):
#+begin_src cs
  switch (c)
  {
      case 'A':
      case 'B':
          color = ConsoleColor.Yellow;
          break;
      case 'C':
          color = ConsoleColor.Green;
          break;
      case 'D':
          color = ConsoleColor.Blue;
          break;
      default:
          color = ConsoleColor.Black;
          break;
  }
#+end_src

switch statement (语句) 和 expression (表达式):
#+begin_src cs
  // 语句，每个分支去做点啥事
  ConsoleColor color;
  switch (c)
  {
      case 'A':
          color = ConsoleColor.Red;
          break;
      case 'B':
          color = ConsoleColor.Yellow;
          break;
      case 'C':
          color = ConsoleColor.Green;
          break;
      case 'D':
          color = ConsoleColor.Blue;
          break;
      default:
          color = ConsoleColor.Black;
          break; 
  }
  
  // 表达式，返回值
  ConsoleColor c1 = c switch
  {
      'A' => ConsoleColor.Red,
      'B' => ConsoleColor.Yellow,
      'C' => ConsoleColor.Green,
      'D' => ConsoleColor.Blue,
      _   => ConsoleColor.Black
  };
#+end_src

*** [循环迭代] 重复做某件事

- for
- while
- do while
- foreach

遍历字符串:
#+begin_src csx
  string s = "hello world";
  
  foreach (var c in s)
  {
      Console.WriteLine(c);
  }
  
  for (int i = 0; i < s.Length; i++)
  {
      Console.WriteLine(s[i]);
  }
  
  int i = 0;
  while (i < s.Length)
  {
      Console.WriteLine(s[i]);
      i++;
  }
  
  int j = 0;
  do
  {
      Console.WriteLine(s[j]);
      j++;
  } while (j < s.Length);
#+end_src  


使用不同的方式，实现从 1 加到 10000 的和:
#+begin_src csx
  // 命名不规范
  // - 方法名，需要遵循 Pascal 语法 !!!
  // - 变量的命名，要让代码具备自解释性 (望文生义)
  // - 变量的名字/参数的变量，需要是驼峰写法
  // 从 1 到 10000 <不等于> 从 0 到 10000。循环的过程一定要注意边界条件
  // 合理设计方法 (返回值)
  // 充分考虑到可变性，将一些值抽取为参数
  
  static void Main(string[] args)
  {
      int i = 10000;
      Console.WriteLine(SumWithFor(i) / 2);
      Console.WriteLine(SumWithWhile(i));
      Console.WriteLine(SumWithDoWhile(i));
  }
  
  static int SumWithFor(int top)
  {
      int sum = 0;
      for (int i = 1; i <= top; i++)
      {
          sum += i;
      }
      return sum;
  }
  
  static int SumWithWhile(int top)
  {
      int sum = 0;
  
      int i = 1;
      while (i <= top)
      {
          sum += i;
          i++;
      }
  
      return sum;
  }
  
  static int SumWithDoWhile(int top)
  {
      int sum = 0;
  
      int i = 1;
      do
      {
          sum += i;
          i++;
      } while (i <= top);
  
      return sum;
  }
#+end_src


通过循环的方式，处理下面字符串:
#+begin_src cs
  // 将字符串进行反转
  // 将所有的大写字母都提到前面
  string a = "hekjsdkfSldAfjKksjsjkKFfjHkl";
  
  static string Fanzhuan(string str)
  {
      string result = "";
      for (int i = str.Length-1; i>=0 ; i--)
      {
          result += str[i];
      }
  
      return result;
  }
  
  static string DaxieTiDaoQianMianWithFor(string str)
  {
      StringBuilder xiaoxie = new StringBuilder();
      StringBuilder daxie = new StringBuilder();
      for (int i = 0; i < str.Length; i++)
      {
          if (str[i] >= 'a' && str[i] <= 'z')
          {
              xiaoxie.Append(str[i]);
          }
          else
          {
              daxie.Append(str[i]);
          }
      }
      daxie.Append(xiaoxie);
      return daxie.ToString();
  } 
#+end_src

*** 语句 (Statement) vs 表达式 (Expression)


提问: @@html: <span style="color: red">表达式和语句有社么区别?</span>@@

语句 (Statement):
#+begin_src csharp
  int r = new Random().Next(0, 100);
  
  int i;
  if (r > 50)
      i = 111;
  else
      i = 222;
  
  Console.WriteLine(i);
#+end_src

表达式 (Expression):
#+begin_src csharp
  int r = new Random().Next(0, 100);
  
  int i = (
      if (r > 50)
          111;
      else
          222;
  );
  
  Console.WriteLine(i); // if 不能作为表达式使用
#+end_src

* 预定义/非数值·引用类型
** string

字符串，是由字符序列组成的一种数据结构。

*** 字符串的初始化

#+begin_src csharp
  string g1 = "Hello World!";
  System.String g2 = "Hello World!";
  var g3 = "Hello World!";

  string message1;
  string message2 = null;
  string message3 = String.Empty; // string message3 = "";
  string oldPath = "Path:\nc:\\Program Files\\Microsoft Visual Studio 8.0";
  string newPath = @"Path:
  c:\Program Files\Microsoft Visual Studio 9.0";

  char[] letters = { 'A', 'B', 'C' };
  string alphabet = new string(letters);
#+end_src

*** 字符串的不可变性 (Immutable)
**** what & why

#+begin_src csharp
  int a;
  string b;


  int i = 1; // int i; i = 1;
  int j = 23;
  i += j; // i = i + j; i = 24;

  string s = "h";
  string t = "w";
  s += t; // s = s + t;
#+end_src

#+ATTR_HTML: :width 400px
[[file:img/string-immute.png]]


字符串是不可更改的:
#+begin_src csharp
  string s = "hello";
  Console.WriteLine(s[1]); // 可以通过这种方式读取字符串的某个位置
  s[1] = 'x';              // 这一句是错误的
#+end_src

思考:
- 为什么要搞成不可变的 ?
- 不可变能带来什么好处 ?

**** System.Text.StringBuilder

这是 BCL 中提供的一个类，专门使用在 *字符串拼接* 的场景下。

因为，在预定义的字符串实现中，字符串拼接 (+=) 是非常低效的一种行为 (要去理解为什么)。

#+ATTR_HTML: :width 500px
[[file:img/string-vs-stringbuilder.png]]

#+begin_src csharp
  using System.Text;

  // 解析一下，为什么这段代码会为内存带来大量的垃圾
  string s = "hello";
  for (int i = 0; i < 1000; i++)
  {
      s += ".";
      Console.WriteLine(s);
  }

  // 要理解，为什么 StringBuilder 会占用更少的空间
  // 如何理性看待 String vs StringBuilder 两种类型
  StringBuilder sb = new StringBuilder("hello");
  for (int i = 0; i < 1000; i++)
  {
      sb.Append(".");
      Console.WriteLine(sb);
  }

  if (s == sb.ToString())
  {
      Console.WriteLine("哈哈，一样啊");
  }
#+end_src

**** String Intern Pool (字符串池)

因为字符串是不可变的，所以在字符串的操作中，会产生很多临时字符串 (垃圾)。

在实际使用中，有很多字符串我们会反复去使用的，所以为了避免重复进行字符串的创建，
会对字符串操作过程中产生的字符串进行缓存管理，即创建一个字符串池管理它们。

后续进行字符串的声明时，会优先到池中寻找，如果已经存在，那么直接使用它。

字符串池的根本原因是，字符串是不可变的。

#+begin_src csharp
  string a = "hello";
  string b = "hel";
  string c = "lo";
  string d = b + c;
  string e = "hello";
  
  // 使用 == 判断，两个字符串的值是不是一样的
  Console.WriteLine(a == d); // True
  Console.WriteLine(a == e); // True
  
  // 使用 object.ReferenceEquals 判定是否占用了相同的内存空间
  Console.WriteLine(object.ReferenceEquals(a, d)); // False
  Console.WriteLine(object.ReferenceEquals(a, e)); // True
  
  // 注意，类比 Java:
  // a == b 判断的是 a 跟 b 是否是同一个引用
  // a.equals(b) 用来判断 a 跟 b 的值是不是一样的
  //
  // string a = null;
  // string b = "hello";
  // a.equals(b) -> b.equals(a);
  // "hello".equal(a); (1)
  // if (a != null) a.equal("hello"); (2)
#+end_src

*** [API] 基本操作

API (Application Programming Interface) 应用程序编程接口。

#+begin_src csharp
  string s1 = "aaa";
  string s2 = "您好aaa";
  string s3 = "𠈓好aaa";

  Console.WriteLine(s1.Length); // 由多少个字符组成
  Console.WriteLine(s2.Length);
  Console.WriteLine(s3.Length); // 这个为什么是 6 ?

  string s4 = "中国𠈓您好𠈓blahblaah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjf";
  Console.WriteLine(s4.Length);
  Console.WriteLine(new StringInfo(s4).LengthInTextElements);
#+end_src

*** [API] 拼接 + 格式化

#+begin_src csharp
  string name = "tom";
  string friend = "jerry";
  int age = 30;
  decimal sal = 200.12345M;
  
  string r1 = name + "的朋友是"
                   + friend + "，它虽然只有" 
                   + age + "岁，但是它的收入能到达到"
                   + sal + "刀";
  
  string r2 = new StringBuilder()
      .Append(name)
      .Append("的朋友是")
      .Append(friend)
      .Append("，它虽然只有")
      .Append(age)
      .Append("岁，但是它的收入能到达到")
      .Append(sal)
      .Append("刀")
      .ToString();
  
  string r3 = string.Format("{0}的朋友是{1}，它虽然只有{2}岁，但是它的收入达到{3:C}", name, friend, age, sal);
  
  // {变量,对齐多少长度:格式}
  // [对齐] 正数表示右对齐，负数表示左对齐
  // [格式] P 百分比 C 货币 E 科学计数法 D 补齐长度 F/N 小数点多少位 X 十六进制
  string r4 = $"{name}的朋友是{friend}，它虽然只有{age:d5}岁，但是它的收入达到{sal:C}!";
  
  // 语言-国家或区域
  // zh-CN
  // en-US
  // en-EN
  string ss = sal.ToString("C", new CultureInfo("en-US"));
  string r5 = $"{name}的朋友是{friend}，它虽然只有{age:d5}岁，但是它的收入达到{ss}!";
  
  Console.WriteLine(r5);
#+end_src

*** [API] 子字符串

#+begin_src csharp
  string s1 = "000o。OOOoOO0O0Ooo000o";
  
  // 取
  char c = s1[1]; // 取字符
  string s2 = s1.Substring(1, 2); // 位置，长度 : el
  string s3 = s1.Substring(2);    // 从某个位置到最后
  string s4 = s1.Substring(2, 0); // String.Empty ""
  
  // 判
  bool b1 = s1.Contains("o0");    // 是否包含一个子字符串
  bool b2 = s1.StartsWith("o");   // 是不是以 x 开始
  bool b3 = s1.EndsWith("o");     // 是不是以 x 结束的
  
  // 序
  int i1 = s1.IndexOf("O");
  int i2 = s1.LastIndexOf("O");
  int i3 = s1.IndexOfAny(new []{'o', 'O'});
  
  // 结合
  string path = "C:/aaa/work.x/hello.txt";
  string drive = path.Substring(0, path.IndexOf(":"));
  string dir = path.Substring(0, path.LastIndexOf("/") + 1);
  string file = path.Substring(path.LastIndexOf("/") + 1);
  string ext = path.Substring(path.LastIndexOf(".") + 1);
  
  // 自定义版本的 LastIndexOf
  int p = 0;
  for (int i = path.Length - 1; i >= 0; i--)
  {
      if (path[i] == '/')
      {
          p = i;
          break;
      }
  }
  string dir2 = path.Substring(0, p);
  
  Console.WriteLine(dir2);
#+end_src

*** [API] 字符串的修改

#+begin_src csharp
  // 谨记:
  // 修改不会作用在原先的字符串上
  // 所有的修改，都是返回了一个完全崭新的字符串
  
  string s1 = "  000o。OOOoOO0O，0Ooo000o--";
  
  string s2 = s1.Insert(3, ">>>");
  string s3 = s1.Remove(2, 1);
  string s4 = s1.Replace("。", ".");
  string s5 = s1.Replace('，', '_');
  string s6 = s1.Replace("OoO", "111");
  string s7 = s1.Replace("OoO", "222", true, new CultureInfo("zh-CN"));
  
  string s8 = s1.PadLeft(100);
  string s9 = s1.PadLeft(100, '-');
  string sa = s1.PadRight(100, '-');
  
  string sb = s1.Trim();
  string sc = s1.Trim('-');
  string sd = s1.TrimStart();
  string de = s1.TrimStart().TrimEnd('-').PadLeft(50, ':');

  string df = s1.ToLower();
  string dg = s1.ToUpper();
  
  Console.WriteLine(de);
#+end_src

*** [API] String 跟 Array 的转换

#+begin_src csharp
  string s1 = "  000o。OOOoOO0O，0Ooo000o--";
  
  // 字符串到 [数组] 的转换
  char[] a1 = s1.ToCharArray();
  char[] a2 = s1.ToCharArray(2, 10);
  
  // [数组] 到字符串的转换
  char[] a3 = new[] {'a', 'o', 'e'};
  string s2 = new string(a3);
  
  // StringBuild vs String
  string s3 = new StringBuilder().Append("hello").ToString();
  StringBuilder sb = new StringBuilder(s1);
#+end_src

** object

#+begin_src csx
  int i = 20;
  string s = "hello";
  
  object i1 = 20;
  object s1 = "hello";
  
  object i2;
  object s2;
  
  i2 = 20;
  s2 = "hello";
#+end_src

** dynamic

- 静态语言
- 动态语言 (动态一时爽，重构hzc)
  
#+begin_src csx
  int i = 20;
  string s = "hello";
  
  object i1 = 20;
  object s1 = "hello";
  
  object i2;
  object s2;
  
  i2 = 20;
  s2 = "hello";
#+end_src

#+begin_src cs
  // 动态语言的搞法，s 是啥不确定，运行到哪里可以能就变了
  var s;
  s = 2323;     // 整数
  s = "kdjkfd"; // 字符串
  Console.WriteLine(s.Length);
  s = [2, 3];   // 数组
  
  // 静态类型，s 是啥，出生定终身
  var s = "hello";
  
  // C# 对动态类型的支持
  dynamic a = 1111;
  a = "hello";
  a = new FileInfo("");
#+end_src

* 用户自定义类型

1. 声明类型
2. 实例化
3. 使用

** class

类

** interface

接口

** delegate

委托

** array

数组

** struct

结构体

** enum

枚举

* 类型转换

基本类型的转换:
- 如果涉及到转换之后不会存在任何的精度损失的话，会进行隐式转换 (implicit)
  : int a; byte b; a = b;
- 如果可能存在精度损失的话，这个时候，必须进行强制转换 (explicit)
  : int a; byte b; b = (int)a;
- 如果强制转换过程中，出现精度损失的话，默认情况下会按照某种规则截断。注意，不会报错
- 我们可以使用 ~checked~ 关键词将转换的语句包围住，然后在转换中出现精度损失的话，会抛出异常
  : int a; byte b; b = check((int)a);

引用类型的转换:
- 引用类型同样存在 implicit/explicit 抓换
  : Person p = new Student();
  : Student s = (Student) p;
- 引用类型的转换，如果转换失败，默认会抛出异常
- 使用 ~is~ 语句，判断是否属于某种类型。经常会跟显式转换配合使用:
  #+begin_src cs
    Student s;
    if (p is Student)
    {
        s = (Student) p;
    }
    else
    {
        s = null;
    }
    Console.WriteLine(s);
  #+end_src
- 可以使用 ~as~ 语句，简化上述的判断跟转换。这是一种很甜的糖:
  #+begin_src cs
    Student s = p as Student;
    if (s == null) ...
  #+end_src

装箱/拆箱 (boxing/unboxing):
- *装箱* 是将值类型转换为 object 类型或由此值类型实现的任何接口类型的过程
- 在 C# 中，基本类型也是 object 的实例。
  但是为了效率，基本类型都被直接存储在栈上，存储的形式不是对象的形式。
  因此，如果想将基本类型当作对象，来进行方法调用的时候，需要将其转换为对象存储形式
  为了简化上述过程，在对基本类型进行方法调用的时候，CLR 会自动进行上述转换。
  这种隐式转换的机制，叫做自动装箱 (auto-boxing)
- 反向的过程叫拆箱

** 隐式转换/强制转换

#+begin_src cs
  char a = 'A';
  byte ab = (byte)a;
  
  int s1 = ab + 13; // byte + int
  ab = (byte) (((int) ab) + 13); // int + int = int
  ab = (byte) (ab + 13);
  
  /////
  char a = 'A';
  byte a1 = (byte) a;
  char a2 = (char) (a1 + 13);
  Console.WriteLine($"{a} -> {a1} -> {a2}");
#+end_src

使用 checked 来释放危险:
#+begin_src cs
  int a = 1;
  byte b = 0;
  byte c = 0;
  byte d = 0;
  
  // 潜在的危险
  b = (byte) a;
  c = (byte) a;
  d = (byte) a;
  
  // 主动释放危险
  b = checked((byte) a);
  c = checked((byte) a);
  d = checked((byte) a);
  Console.WriteLine(b);
  
  // 指定危险区域
  checked
  {
      b = (byte)a;
      c = (byte)a;
      d = (byte)a;
      Console.WriteLine(b);
  }
#+end_src

** 引用类型的隐式和强制转换

#+begin_src cs
  class Person {}
  class Student : Person {}
  
  Person p = new Person();
  Student s = new Student();
  
  Person p1 = new Student();
  
  object a = new Student();
  a = 2122;
  // a: object
  Student s2 = (Student)a;
#+end_src

** 装箱/拆箱 (auto-boxing)

#+begin_src csx
  // 自动装箱
  int i = 1;
  object o = null;
  o = i;
  
  Console.WriteLine($"i: {i}, o: {o}");
  
  // 装箱使用的是数据的副本
  i = 5;
  o = 6;
  Console.WriteLine($"i: {i}, o: {o}");
  
  // 拆箱
  i = (int)o;
#+end_src

#+RESULTS:
| i: 1 | o: 1 |
| i: 5 | o: 6 |

** 自定义转换规则

#+begin_src cs
  class Program
  {
      static void Main(string[] args)
      {
  
          Person p = new Person();
          Student s = new Student();
  
          Person p1 = new Student();
  
          object a = new Student();
          Student s2 = (Student)a;
  
          // 在 C# 中，类型转换的规则，是可以自定义的
          Student ss = new Student();
          ss.id = 222;
          int i = ss;
          Console.WriteLine(i);
  
          Student st = (Student)333;
          Console.WriteLine(st);
      }
  
      class Person { }
  
      class Student : Person
      {
          public int id;
  
          public static implicit operator int (Student s)
          {
              return s.id;
          }
          public static explicit operator Student(int si)
          {
              var s = new Student();
              s.id = si;
              return s;
          }
      }
  }
#+end_src

学号 - 学生，转换的示例:
#+begin_src cs
  // 普通使用
  int id = 2323232323;
  s = new Student();
  s.id = id;
  s.xxx = ksdfj;
  s.yyy = kjskdfj;
  
  // 抽出为方法
  Student MakeStudent(int id)
  {
      s = new Student();
      s.id = i;
      s.xxx = ksdfj;
      s.yyy = kjskdfj;
  }
  S = MakeStudent(id);
  
  // 抽出为类型转换
  Student s = (Student) id;
#+end_src

** 基于 *字符串* 之间的互相转换

- 核心两种方法: ~string.Format~ 用来转换为字符串，~type.Parse~ 用来从字符串转化
- 可以使用 ~ToString/TryParse~ 对上面的两个方法进行补充

简而言之:  
- 将其他类型转换为字符串: ~string.Format/ToString~
- 将字符串转换为其他类型: ~xxx.Parse/TryParse~
- BCL 中提供了一个叫 ~Convert~ 的类，可以实现更多更复杂的转换

*** string.Format

#+begin_src cs
  string r3 = string.Format("{0}的朋友是{1}，它虽然只有{2}岁，但是它的收入达到{3:C}", name, friend, age, sal);
#+end_src

*** type.ToString

因为，string 类型是如此重要，所以在 *所有类的基类，即 object 中*,
包含了一个默认的 ToString 方法。

#+begin_src cs
  class Person
  {
      private int sal = 1000000;
  
      void Hahaha()
      {
          Console.WriteLine("hdskfjksjfksjdfkke");
      }
  }
  
  Person p = new Person();
  Console.WriteLine(p.ToString()); // Program+Person
#+end_src

#+begin_src cs
  class Person
  {
      private int sal = 1000000;
  
      void Hahaha()
      {
          Console.WriteLine("hdskfjksjfksjdfkke");
      }
  
      public override string ToString()
      {
          return "我就是我，不一样的烟火.我的工资: " + this.sal;
      }
  }
  
  Person p = new Person();
  Console.WriteLine(p);
#+end_src

#+begin_src cs
  // int
  int i = 112323;
  string s1 = i.ToString("X");
  Console.WriteLine(s1);
  
  // datetime
  DateTime now = DateTime.Now;
  string s2 = now.ToString();
  Console.WriteLine(s2);
  string s3 = now.ToString("现在时间: yyyy年MM月dd日，不告诉你几点");
  Console.WriteLine(s3);
  CultureInfo ci = new CultureInfo("zh-CN");
  string s4 = now.ToString("现在时间: yyyy年MMM ddd，不告诉你几点", ci);
  Console.WriteLine(s4);
#+end_src

*** type.Parse/TryParse

#+begin_src cs
  // int
  string s1 = "1234343";
  int i = int.Parse(s1) + 1;
  Console.WriteLine(i);
  
  // double
  string s2 = "2322222";
  double d = double.Parse(s2);
  Console.WriteLine(d);
  
  // DateTime
  string s3 = "1999-02-13";
  DateTime dt = DateTime.Parse(s3);
  Console.WriteLine(dt.Year);
#+end_src

转换失败，会抛异常:
#+begin_src cs
  string s4 = "hello";
  int i2 = int.Parse(s4);
  
  try
  {
      string s4 = "hello";
      int i2 = int.Parse(s4);
  }
  catch (e)
  {
      // 转换不了怎么办
  }
#+end_src

可以使用 TryParse 进行转化，如果转换失败，会返回 False:
#+begin_src cs
  string s4 = "hello";

  if (int.TryParse(s4, out int result))
  {
      Console.WriteLine(result);
  }
  
  bool TryMyParse(string s, out int result)
  {
      try
      {
          result = int.Parse(s4);
          return true;
      }
      catch
      {
          result = 0;
          return false;
      }
  }
#+end_src

*** Convert

#+begin_src cs
  string s1 = Convert.ToString(82738283782, 2);
  string s2 = Convert.ToString(82738283782, 8);
  Console.WriteLine(s2);
  
  Convert.TryFromBase64String();
#+end_src

* 类 (Class)
** 字段 (Field)

- 作为一个字段，最重要的是 (类型) (名字) = (值)
- 可以 *选择性* 使用其他修饰符，为字段增加 *额外* 的功能或限制:
  + 访问修饰符: private/public/protected/internal 等，用来给予外部的访问限制
  + 只读/常量修饰符: const/readonly，用来防止数据被误修改
  + 静态修饰符: static 的作用是，将这个字段的归属权给予类

** 方法 (Method)
*** Basic

方法是一个具备名字的代码块:
- 通过 ~方法名()~ 的方式实现方法调用，
  也就是在调用的地方将方法名代表的代码块里的代码进行运行
- 方法的三要素:
  1. 一个名字 (方法名)
  2. 传入的数据 (传入参数) 入参写在方法名后面的括号里。如果没有入参，括号保持为空即可
  3. 传出的数据 (返回值) 方法内部，使用 return 表示返回的数据。在方法名前面，添加返回的类型。
     如果方法内部没有任何 return 表示方法没有返回值，需要在方法前面添加 void 表示这种情况

*** 方法的重载 (overload)

- 一个类中，可以有同名的方法。需要有不同的参数 (这样才能区分调用)
- 请叙述一下 overload 和 override 有什么区别

方法的示例:
#+begin_src csharp
  class Program
  {
      // 方法的声明、定义
      int 增加 (int a)  // 方法名为 [增加]，入参为 [a]
      {
          return a + 1;  // 返回值为 [a + 1]
      }
      double 加法 (double a, double b) // 可以有多个入参
      {
          return a + b;
      }
      double 没有入参 () // 可以没有入参
      {
          return 111.111; // 返回 double 类型的数据
      }
      void 没有返回数据 (string name) // 没有返回数据使用 void 表示
      {
          Console.WriteLine(name); // 方法体内，没有任何 return 语句，所以方法没有返回任何数据
      }
      void 没有返回值也没有入参 () // 这个方法，就是没有返回值也没有入参
      {
          Console.WriteLine("hello, world");
      }

      // 方法的调用
      // 使用方法的名字调用方法:
      // - 入参的个数和顺序要跟上述定义的一致
      // - 返回值的类型要跟上述定义的一致，如果 void 类型的函数是不能接受其返回值的
      // 上述方法定义中的参数，又叫形式参数 (形参)
      // 这里调用时传入的参数，又叫实际参数 (实参)
      // 也就是，实参要跟形参相对应!
      int a = 增加(11);
      double b = 加法(11, 33);
      double c = 没有入参();
      没有返回数据("H&M");
      没有返回值也没有入参();
  }
#+end_src

*** 参数 (值参数/ref/out)

值参数 (默认的):
#+begin_src cs
    static void Main(string[] args)
    {
        int i = 5;
        Person p = new Person();

        TestZhi(i, p);
        Console.WriteLine($"out: i: {i}, age: ${p.Age}");
    }

    static void TestZhi(int ii, Person pp)
    {
        ii = ii + 1;
        pp.Age = pp.Age + 18;
        Console.WriteLine($"in:  i: {ii}, age: ${pp.Age}");
    }

    class Person
    {
        public int Age = 18;
    }
#+end_src

ref:
#+begin_src cs
  static void Main(string[] args)
  {
      int i = 5;
      Person p = new Person();
  
      TestZhi(ref i, p);
      Console.WriteLine($"out: i: {i}, age: ${p.Age}");
  }
  
  static void TestZhi(ref int ii, Person pp)
  {
      ii = ii + 1;
      pp.Age = pp.Age + 18;
      Console.WriteLine($"in:  i: {ii}, age: ${pp.Age}");
  }
  
  class Person
  {
      public int Age = 18;
  }
#+end_src

out:
#+begin_src cs
  static void Main(string[] args)
  {
      int i;
      Person p = new Person();
  
      TestZhi(out i, p);
      Console.WriteLine($"out: i: {i}, age: ${p.Age}");
  }
  
  static void TestZhi(out int ii, Person pp)
  {
      ii = 999;
      pp.Age = pp.Age + 18;
      Console.WriteLine($"in:  i: {ii}, age: ${pp.Age}");
  }
  
  class Person
  {
      public int Age = 18;
  }
#+end_src

#+ATTR_HTML: :width 400px
[[file:img/method-parameter.png]]


*** out 参数: 用来模拟方法返回多个值的场景

如果不用 out，可以使用 Class 的方式返回多个值，这种方式比较重:
#+begin_src cs
  static void Main(string[] args)
  {
      string name;
      int age;
      double sal;
  
      Person p = GetYourInformation();
      name = p.Name;
      age = p.Age;
      sal = p.Sal;
  }
  
  static Person GetYourInformation()
  {
      return new Person
      {
          Name = "Kitty",
          Age = 19,
          Sal = 2323323
      };
  }
  
  class Person
  {
      public string Name;
      public int Age;
      public double Sal;
  }
#+end_src

而 out 的方法比较轻量级:
#+begin_src cs
  static void Main(string[] args)
  {
      string name;
      int age;
      double sal;
  
      name = GetYourInformation(out age, out sal);
      Console.WriteLine($"{name} 的年龄为 {age} 收入为 {sal}，您可满意?");
  }
  
  static string GetYourInformation(out int age, out double sal)
  {
      age = 19;
      sal = 23232;
      return "Kitty";
  }
#+end_src

甚至可以更简化:
#+begin_src cs
  static void Main(string[] args)
  {
      string name = GetYourInformation(out int age, out double sal);
      Console.WriteLine($"{name} 的年龄为 {age} 收入为 {sal}，您可满意?");
  }
  
  static string GetYourInformation(out int age, out double sal)
  {
      age = 19;
      sal = 23232;
      return "Kitty";
  }
#+end_src

*** 数组参数 (params)

实现累加:
#+begin_src cs
  static void Main(string[] args)
  {
      // 加法
      int r1 = MyAdd2(2, 3);
      int r2 = MyAdd3(2, 3, 4);
  }
  
  static int MyAdd2(int a, int b)
  {
      return a + b;
  }
  
  static int MyAdd3(int a, int b, int c)
  {
      return a + b + c;
  }
#+end_src

使用数组改良的结果:
#+begin_src cs
  static void Main(string[] args)
  {
      int r1 = MyAdd(new int[] {2, 3});
      int r2 = MyAdd(new int[] {2, 3, 4, 5, 6, 7});
  }
  
  static int MyAdd(int [] nums)
  {
      int r = 0;
      for (int i = 0; i < nums.Length; i++)
      {
          r += nums[i];
      }
  
      return r;
  }
#+end_src

可以使用 params 修饰数组，达到进一步简化调用语法的目的:
#+begin_src cs
  static void Main(string[] args)
  {
      int r1 = MyAdd(2, 3);
      int r2 = MyAdd(2, 3, 4, 5, 6, 7);
      Console.WriteLine($"{r1} / {r2}");
  }
  
  static int MyAdd(params int [] nums)
  {
      int r = 0;
      for (int i = 0; i < nums.Length; i++)
      {
          r += nums[i];
      }
  
      return r;
  }
#+end_src

数组参数需要放到后面:
#+begin_src cs
  static void Main(string[] args)
  {
      MyAdd("最后求取的和是: 0x{0:X}", 232, 3, 10);
  }
  
  static void MyAdd(string fmt, params int [] nums)
  {
      int r = 0;
      for (int i = 0; i < nums.Length; i++)
      {
          r += nums[i];
      }
  
      Console.WriteLine(fmt, r);
  }
#+end_src

*** 可选参数/命名参数

#+begin_src cs
  static void Main(string[] args)
  {
      Hello();
      Hello("Hiii!");
      Hello("Hi", "Xiaoming");
  }
  
  static void Hello(string action = "Hello", string who = "World")
  {
      Console.WriteLine($"{action} {who}");
  }
#+end_src

可以使用命名参数，简化多个可选参数存在的情况下的赋值:
#+begin_src cs
  static void Main(string[] args)
  {
      Hello(who: "XM");
      Hello(who: "Xiaoming", action: "out...");
  }
  
  static void Hello(string action = "Hello", string who = "World")
  {
      Console.WriteLine($"{action} {who}");
  }
#+end_src

** 属性 (Property)

属性本身就是 [private Field + public Method] 一种语法糖:
- 它能减少太多冗余的模板代码；它能简化对实例中数据的可控性的访问，让代码更简洁
- 但是不要忘了，它跟 getter/setter 方法的本质是一样的。最后编译器还是将我们写的属性代码转换成了 getter/setter 方法的形式
- 也就是说 ~r.Width = 333~ 这样的属性赋值，本质就是方法调用

示例:
#+begin_src csharp
  class Rect
  {
      public double Width { get; set; }
      public double Height { get; set; }
      public double Area
      {
          get
          {
              return Width * Height;
          }
      }

      // private double Height;
      // public double GetHeight ()
      // {
      //     return Height;
      // }
      // public void SetHeight (double h);
      // {
      //     Height = h;
      // }
  }

  class Program
  {
      static void Main()
      {
          Rect r = new Rect();
          r.Width = 2000;
          r.Height = 333;
          Console.WriteLine("面积是: {0}", r.Area);
      }
  }
#+end_src

** 索引器 (Indexer)

#+begin_src cs
  static void Main()
  {
      string a = "hello";
      char x1 = a[1];
  
      var b = new int[] {1, 2, 3, 4};
      int x2 = b[1];
  
      var c = new List<int> {1, 2, 3, 4};
      int x3 = c[1];
  
      var d = new Dictionary<string, int> {{"xm", 22}, {"xh", 24}};
      int x4 = d["xm"];
  
      var p = new Person();
      p[1] = "您好";
      p[5] = "你好";
      p[3] = "八嘎";
      Console.WriteLine(p[1]);
      Console.WriteLine(p[2]);
      Console.WriteLine(p[3]);
      Console.WriteLine(p[4]);
      Console.WriteLine(p[5]);
  }
  
  class Person
  {
      private Dictionary<int, string> hiStyles = new Dictionary<int, string>();
  
      public string this[int i]
      {
          get
          {
              if (!hiStyles.TryGetValue(i, out string hiStyle))
              {
                  hiStyle = "Hello";
              }
              return $"{hiStyle} {i}";
          }
          set
          {
              hiStyles[i] = value;
          }
      }
  }
#+end_src

** 构造方法/构造器 (Constructor)
*** 对象的实例化

对象的实例化，分为下面几个步骤:
1. 在内存中，分配相应的空间
2. 按照类型进行相关字段的初始化工作
3. 调用相应的 *构造方法*，进行相关初始化工作

*** 构造器

所谓的构造方法，就是类中定义的一个特殊方法。它用来对实例空间进行若干初始化工作:   
- 构造方法可以写多个，即可以重载 (overload)
- 我们也可以不写任何构造方法，那么编译器在编译的时候，会自动帮我们插入一个 *无参的空的*。
  但是，如果你在类中，定义了任何的构造方法，那么编译器就不会帮你再生成了

#+begin_src csharp
  class X
  {
      public X()
      {
      }
      public X(int a, int b) // 2
      {
      }
  }

  class Program
  {
      static void Main()
      {
          new X(); // 如果没有参数，那么会调用无参构造器 1
          new X(1, 2); // 回去调用相应的具备两个参数，并且类型正确的构造器 2
      }
  }
#+end_src

*** 构造器链

- 如果不显式继承某个类，那么继承的将是 object。即可以忽略掉 ~: Object~
- 如果不显式添加构造器，那么编译器会自动插入一个无参的。即可以省略掉 ~public Son() {}~
- 如果不显式指定构造器顺序，那么任意构造器都会首先执行父类的无参构造器。即可以省略掉 ~: base()~
- 显式指定构造器顺序，需要手动添加 ~: base(xxx)~ 或者 ~: this(xxx)~
- 基本的规则是: 从下往上寻找，然后从上往下执行。这样就构成了 *构造器链*

#+begin_src csharp
  class GP
  {
      public GP() : base() // 4
      {
          Console.WriteLine("我是你爷爷");
      }
      public GP(string address) : base()
      {
          Console.WriteLine("爷爷我的地址是 {0}", address);
      }
      public GP(string name, string address) : base()
      {
          Console.WriteLine("爷爷 {0} 的地址是 {0}", name, address);
      }
  }
  class PP : GP
  {
      public PP() : base()
      {
          Console.WriteLine("我是爸爸");
      }
      public PP(string address) : base() // 3
      {
          Console.WriteLine("爸爸我的地址是 {0}", address);
      }
      public PP(string name, string address) : base()
      {
          Console.WriteLine("爸爸 {0} 的地址是 {0}", name, address);
      }

  }
  class You : PP
  {
      public You() : base()
      {
          Console.WriteLine("我的儿子");
      }
      public You(string name) : this(name, "广西") // 1
      {
          Console.WriteLine(name);
      }
      public You(string name, string addr) : base(addr) // 2
      {
          Console.WriteLine("{0} 的 {1}", addr, name);
      }

  }
  class Son : You
  {
  }

  You u = new You("张三");
#+end_src

*** 静态构造器

- 构造器是用来初始化 *对象* 的
- 静态构造器是用来初始化 *类* 的
- 对象的初始化工作，是在代码中通过 new Class 的方式触发的
- 类的初始化工作，是由 CLR 自动执行的，一般来说，你第一次使用到某个类的时候，这个类就会 *被* 自动加载
- 静态的构造器，只能有一个，而且不能带任何参数

#+begin_src csharp
  class TipCalculator : CalculatorBase
  {
      static TipCalculator()
      {
          Console.WriteLine("我是一个带 static 的构造器");
      }
  }
#+end_src

** 析构方法/析构器 (Deconstructor)

#+begin_src csharp
  ~TipCalculator()
  {
      Console.WriteLine("我死的好惨啊");
  }

  ~文件()
  {
      this.Close();
  }
#+end_src

** 静态方法 (Static)

将归属权，交给类。调用的时候，使用 ~类名.xxx~ 方式。

** 将数据设置为不变的 (const/readonly)

: 通过 private 等操作符可以保护数据的外部访问安全
: 通过 const/readonly 可以防止内鬼

const:
- 即常量
- 基于编译期的替换，运行期是没有任何这个变量的信息的
- 相对来说，它不需要占用存储，而且不需要运行时检查，所以效率高
- 它的使用限制较多，比如，只能将一些简单的值赋予它
- 不能添加 static 修饰，但可以使用 ~类名.PI~ 来访问

readonly:
- 限定变量只能读，不能修改
- 可以修饰任何的字段，不管是不是静态的
- 相对来说，需要占用空间、需要运行时检查，效率会低一些
- *注意*，使用 readonly 修饰数组等变量，虽然可以防止数组被重新赋值，但不能避免里面的元素被修改

有内鬼，停止交易:
#+begin_src csharp
  class Congming
  {
      private const double PI = 3.1415926;
      private readonly double pppi = 3.14;

      public double QiuMianJi(double r)
      {
          pppi = 333;  // x
          PI = 333;    // x
          return pppi * r * r;
      }
  }
#+end_src

** 继承 (Inheritance)

- 继承表示，我的是我的，你的也是我的。使用 ~:~ 语法表示继承关系
- 继承主要用来消除冗余，让逻辑得以 *复用*。逻辑上来说，跟自然界的分门别类是对应一致的
- new 对象的时候，会 *开辟空间、初始化字段、调用构造器*。如果存在继承关系的话，创建的实例是分为多部分的
- 调用实例上的某个方法 A，如果 A 调用了另一个方法 B，这时候，优先会使用 A 自身部分上面定义的 B。
  如果想让 A 调用的 B 是派生类 *最下面* 的 B 的话，使用 ~virutal/override~ 将 B 设置为 *虚函数* 即可。
  子类中存在的相同方法，如果不是 override 的，那么将会是 new 的。new 可以不写
- 在 C# 中，只允许有一个父类，即 *单继承*
- 所有类的根基类是 *object*。object 中定义了 ToString/GetType/Equal 等方法。因此，所有的对象都拥有这几个方法
- 在方法中，使用 *this* 表示当前的对象，使用 *base* 表示父类部分。base.Xxx 表示调用父类部分的 Xxx
- 使用 private 修饰的数据不能被继承使用，这时候应该使用 *protected*

基本语法:
#+begin_src csharp
  class A : object { void Say() {Console.WriteLine("hello");} }
  class B : A {}
  class C : B { void Say() {Console.WriteLine("world");} }
  class D : C {}
  D d = new D();
  d.Say();
#+end_src

*** 虚方法 (virtual/override)

虚函数:
#+begin_src csharp
  class A
  {
      public string Name() { return "hello"; }
      public void Say() { Console.WriteLine(this.Name()); }
  }
  class B : A
  {
      public virtual string Name() { return "world"; }
      public new void Say() { Console.WriteLine("heihei" + Name()); base.Say(); }
  }
  class C : B
  {
      public override string Name() { return "who"; }
      public virtual void Say() { Console.WriteLine("hahaha" + Name()); }
  }
  class D : C
  {
      public override string Name() { return "ryou"; }
  }
  var d = new D();
  d.Say();
#+end_src

虚不虚?
#+begin_src csharp
  class A
  {
      public string Name() { return "hello"; }
      public virtual void Say() { Console.WriteLine(this.Name()); }
  }
  class B : A
  {
      public new virtual string Name() { return "world"; }
      public override void Say() { Console.WriteLine("heihei" + Name()); base.Say(); }
  }
  class C : B
  {
      public override string Name() { return "who"; }
      public override void Say() { Console.WriteLine("hahaha" + Name()); }
  }
  class D : C
  {
      public override string Name() { return "ryou"; }
  }

  A a = new D();
  a.Say();
#+end_src

#+begin_src csharp
  class GrandPP
  {

  }
  class PP : GrandPP
  {

  }
  class You : PP
  {
      public You()
      {
          Console.WriteLine(".");
      }
      public You(string name)
      {
          Console.WriteLine(name);
      }
      public You(string name, string addr)
      {
          Console.WriteLine(name + ":" + addr);
      }

  }
  new You();
  new You("张三");
  new You("张三", "湖南");
#+end_src

*** 抽象方法 (abstract)

- 继承下来的，不一定是权利，也有可能是义务。俗语有云 *父债子偿*
- 通过在父类中，将某个方法用 ~abstract~ 修饰，表示它是债务...
- 抽象方法可以 (1) 约束子类的行为 (2) 将父类中无法实现的功能，交给子类去实现
- 抽象类是不能被实例化的

#+begin_src csharp
  abstract class Baba
  {
      public double Money = 0.1;

      public virtual void Sanjuhua()
      {
          Console.WriteLine("漂亮的女孩子都比较危险");
          Console.WriteLine("我有很多钱，藏在某个地方");
          Console.WriteLine("但我不告诉你在哪里");
      }

      public abstract void 花光这些钱();
  }

  class You : Baba
  {
      public override void Sanjuhua()
      {
          Console.WriteLine("漂亮的女孩子是值得我们花一生去追求的");
          Console.WriteLine("我有很多钱，就放在中国银行的钱库里");
          Console.WriteLine("但不要把钱放眼里，作为真男人，要敢于 996，奉献人生价值");
      }

      public override void 花光这些钱()
      {
          Console.WriteLine("第一天，花了 3 亿");
          Console.WriteLine("第二天，花了 33 亿");
          Console.WriteLine("第三天，花了 333 亿");
          Console.WriteLine("第四天，梦醒了");
      }
  }
#+end_src

** 多态 (Polymorphism)

多态是一个来自生物学上的概念，[[https://baike.baidu.com/item/%E5%A4%9A%E6%80%81%E7%8E%B0%E8%B1%A1][参见百度百科]]:
- 在语言中，多态指调用同一个类型的相同方法/属性，会产生不同结果的现象。
  产生不同结果的原因是方法实质调用了不同派生类中的不同实现。
- 虚方法是实现多态性的主要手段，接口和抽象类是多态的充分体现

#+begin_src csharp
  // 批量处理 (关心的是共性)

  Animal[] animals = new Animal[3];
  animals[0] = new Animal();
  animals[1] = new 美女();
  animals[2] = new 野兽();

  for (int i = 0; i < animals.Length; i++)
  {
      Animal a = animals[i];
      a.Eat();
      a.Sleep();
      a.WakeUp();
      a.Drink();
  }

  // 适配的参数类型
  interface 能干活的东西 { void 干活(); }
  class 人 : 能干活的东西 { void 干活 () { ... }; }
  class 猪 : 能干活的东西 { void 干活 () { ... }; }

  void 招聘 (能干活的东西 x) {
      x.干活();
  }
  招聘(人);
  招聘(猪);

  // 适配的返回值 (约定跟实现的和谐)

  Dog GiveADog()
  {
      return new 二哈();
  }
  Animal aaa = GiveADog();

  // 接口与多态

  IHelpable xxx = new TipCalculator(222);
  xxx.Help();
#+end_src

** 静态类/static

限制里面所有的方法，必须是静态的。典型的代表是 Math 类。

** 密封类/sealed

这就从语法上，避免了某个类被继承的可能。

** 分部类/partial

让类可以写成多部分。在编译的环节，编译器将会帮助我们自动合并之后再编译。

#+begin_src csharp
  partial class MyLove
  {
      public void 你想我吗()
      {
      }
  }

  partial class MyLove
  {
      public void 我想你()
      {
      }
  }
#+end_src

** 基类 Object
*** ToString

#+begin_src csharp
  class TipCalculator : CalculatorBase
  {
      public override string ToString()
      {
          return $"我是一个账单类，传入的参数是 {Bill}";
      }
  }
  Console.WriteLine("{0}", new TipCalculator(200));
#+end_src

** 类的扩展机制

为某个类扩展功能的基本方式:
1. 直接修改源码，添加想要的方法
2. 通过继承的方式，你的是我的我的还是我的

如果无法修改源码、而且不能继承时，就需要下面这种扩展手段，具备特点:
- 很灵活很方便
- 但需要慎用

#+begin_src cs
  class Program
  {
      static void Main(string[] args)
      {
          Console.WriteLine(90.Repeat("-"));
          Console.WriteLine(30.Repeat("+  "));
          Console.WriteLine(30.Repeat("|  "));
          Console.WriteLine(30.Repeat("|  "));
          100.Times(() => Console.Write("IOU ")); Console.WriteLine();
          Console.WriteLine(30.Repeat("|  "));
          Console.WriteLine(30.Repeat("|  "));
          Console.WriteLine(30.Repeat("+  "));
          Console.WriteLine(90.Repeat("-"));
      }
  }
  
  public static class SuibianQigemingzi
  {
      public static void Cl0ne(this string s)
      {
          Console.WriteLine($"hello {s}!");
      }
  
      public static void ClOne(this string s)
      {
          Console.WriteLine($"hello {s}!");
      }
  
      public static void C1one(this string s)
      {
          Console.WriteLine($"hello {s}!");
      }
  
      public static void Hello(this string s)
      {
          Console.WriteLine($"hello {s}!");
      }
  
      public static void Hi(this int s, int n = 1)
      {
          Console.WriteLine($"{s} 加上 {n} 为 {s + n}!");
      }
  
      public static string Rot13(this string str)
      {
          StringBuilder sb = new StringBuilder();
          foreach (char c in str)
          {
              sb.Append(RotChar(c));
          }
          return sb.ToString();
      }
  
      static char RotChar(char c)
      {
          byte code = (byte)c;
          if (c >= 'a' && c <= 'z')
          {
              return (char)(code + 13 > 122 ? code - 13 : code + 13);
          }
  
          if (c >= 'A' && c <= 'Z')
          {
              return (char)(code + 13 > 90 ? code - 13 : code + 13);
          }
  
          return c;
      }
  
      public static string Repeat(this int count, string source)
      {
          var sb = new StringBuilder();
          for (int i = 0; i < count; i++)
          {
              sb.Append(source);
          }
  
          return sb.ToString();
      }
  
      public static void Times(this int count, Action action)
      {
          for (int i = 0; i < count; i++)
          {
              action();
          }
      }
  }
#+end_src

* 接口 (Interface)

- 接口本质就是一个可以进行 *多继承* 的纯的抽象类。它是单继承的一种例外
- 使用 interface 关键词声明接口，接口里面只能包含方法。按照习惯，一般使用 IXxx 的方式命名接口
- 不需要使用 public 修饰符，因为接口里所有方法默认都是公开的。方法不需要有方法体
- 接口实际上就是一种 *合同*，它起到的作用是制定统一的 *规则*
- 接口有很多好处: blahblahblah... 面向接口编程是一种好的编程实践

** IComparable 接口使用示例

IComparable 用来为两个对象进行比较提供比较的规则:
#+begin_src csharp
  class Person : IComparable
  {
      public string Name { get; set; }
      public double Salary { get; set; }
      public int Age { get; set; }

      public Person(string name, double sal, int age)
      {
          Name = name;
          Salary = sal;
          Age = age;
      }

      public int CompareTo(object? obj)
      {
          var wo = this;
          var ni = (Person) obj;

          // if (wo.Salary > ni.Salary) return -1;
          // if (wo.Salary < ni.Salary) return 1;
          // return 0;
          return wo.Salary - ni.Salary;
      }
  }

  static void Main(string[] args)
  {
      var p1 = new Person("a-小明", 20000, 50);
      var p2 = new Person("c-小张", 7000, 25);
      var p3 = new Person("b-小王", 15000, 35);
      var p4 = new Person("d-小红", 7500, 19);
      var p5 = new Person("e-小强", 5000, 22);

      var persons = new Person[] {p1, p2, p3, p4, p5};

      Array.Sort(persons);

      foreach (var p in persons)
      {
          Console.WriteLine($"{p.Name}: {p.Age} 岁, 收入为 {p.Salary}");
      }
  }
#+end_src

* 结构体 (Struct)

- 它跟 class 非常像，但它是值类型
- 由于是值类型，所以效率高:
  + 栈上，用完退栈，不需要垃圾回收
  + 对象内部
- 实际上，我们的常见预定义类型，都是实现为 struct (int/float)
- 结构体，默认是密封的，因此，它不能继承
- 它支持 partial 的用法
- 它支持使用构造器:
  + 在构造器中，需要确保为每个成员赋值
  + 包含一个默认构造器，里面会对所有成员进行初始化，我们不能将其覆盖掉
- 它不需要，也不能有析构方法

#+begin_src cs
  static void Main(string[] args)
  {
      TestStuct();
      Console.WriteLine("结束了");
  }
  
  static void TestStuct()
  {
      YellowMan a = new YellowMan();
      a.Name = "小黄人甲";
      a.Score = 333.4;
  
      YellowMan b = new YellowMan();
      b.Name = "小黄人乙";
      b.Score = 133.4;
  
      b.ZiWoJieShao();
      Console.WriteLine(b);
  
      var d = new YellowMan("kkk", 222);
      Console.WriteLine(d.Name);
  }
  
  struct YellowMan
  {
      public string Name;
      public double Score;
      public int Age;
  
      public YellowMan(string n, double s)
      {
          Name = n;
          Score = s;
          Age = 23;
      }
  
      public void ZiWoJieShao()
      {
          Console.WriteLine($"我是 {Name},我的可爱程度为 {Score}");
      }
  
      public override string ToString()
      {
          return "hello, 小黄人";
      }
  }
  
  class B
  {
      private YellowMan c = new YellowMan();
  }
#+end_src

* 枚举 (Enum)

int/1 2 3 .. ..  3
double .....
bool: true/false

Gender (男/女/未知)

** 基本使用

#+begin_src csharp
  static void Main(string[] args)
  {
      checked
      {
          Console.WriteLine((int)Gender3.女);
          Console.WriteLine((int)Gender3.男);
          Console.WriteLine((int)Gender3.我也不知道是男是女它到底是男是女呢谁知道呢不管他了);
      }
  
      if (Gender4.我也不知道是男是女它到底是男是女呢谁知道呢不管他了 == Gender4.男)
      {
          Console.WriteLine("Yes.");
      }
  }
  
  enum MyBool
  {
      True,
      False
  }
  
  enum Gender
  {
      男,
      女,
      我也不知道是男是女它到底是男是女呢谁知道呢不管他了
  }
  
  enum Gender2
  {
      男 = 0,
      女 = 1,
      我也不知道是男是女它到底是男是女呢谁知道呢不管他了 = 2
  }
  
  enum Gender3
  {
      男 = 110,
      女,
      我也不知道是男是女它到底是男是女呢谁知道呢不管他了 = 120
  }
  
  enum Gender4
  {
      男 = 110,
      女,
      我也不知道是男是女它到底是男是女呢谁知道呢不管他了 = 男
  }
  
  enum Gender5 : short
  {
      男 = 110,
      女,
      我也不知道是男是女它到底是男是女呢谁知道呢不管他了 = 男
  }
  
  class MyGender
  {
      public const int 男 = 0;
      public const int 女 = 1;
      public const int 我也不知道是男是女它到底是男是女呢谁知道呢不管他了 = 2;
  }
#+end_src

** Flags (TODO)

#+begin_src cs
  [Flags]
  enum FeichangJincouDeLeixing
  {
      A = 0x12,
      B = 0x13
  }
  
  111111
  101001
#+end_src

** 基本 API

#+begin_src cs
  foreach (string name in Enum.GetNames(typeof(Gender)))
  {
      Console.WriteLine(name);
  }
  foreach (var v in Enum.GetValues(typeof(Gender)))
  {
      Console.WriteLine((int)v);
  }
#+end_src

* 委托 (Delegate)

- 背景:
  + 我们需要通过参数的形式去传递一些逻辑
  + 逻辑的基本单元是方法
  + 很遗憾的是，方法在 C# 中并不是某种类型，也不具备相应的实例。因此，它不能作为参数被传递
  + 所以，我们需要通过一定方式，达到能够传递方法 (以及其中的逻辑) 的目的
  + 一种传统的方式，是将方法包含在某个类中，然后实例化并传递。但是这种方式特别麻烦
  + 因此，在 C# 中为了解决这个问题，就推出了一种类型，叫做委托 (Delegate)
- 总而言之，通过委托机制，达到 *像传递对象实例一样，传递方法* 的目的

** 写一个方法 MyAdd ，求取 *若干数* 的和
*** 原始写法

#+begin_src cs
  static void Main(string[] args)
  {
      // Console.ForegroundColor = ConsoleColor.Red;
      // Console.WriteLine(sum);
      // Console.ResetColor();
      // 将上面三局，放到一个对象里，然后
      object o1 = null;
  
      int r1 = MyAdd(o1, 12, 32, 1112232, 43, 1112212, 3232323, 123);
      int r2 = MyAdd(o2, 222, 333, 444);
      int r3 = MyAdd(o3, 11, 2323, 4344);
  }
  
  public static int MyAdd(object gaosuwogaigansm, params int[] nums)
  {
      int sum = 0;
      for (int i = 0; i < nums.Length; i++)
      {
          sum += nums[i];
      }
      // Console.ForegroundColor = ConsoleColor.Red;
      // Console.WriteLine(sum);
      // Console.ResetColor();
  
      // Console.BackgroundColor = ConsoleColor.Red;
      // Console.WriteLine("和为："+sum);
      // Console.ResetColor();
  
      // File.AppendAllText(@"E:\jiafa.txt", sum + "\r\n");
  
      // SpeechSynthesizer synth = new SpeechSynthesizer();
      // synth.Speak(sum.ToString());
      // synth.Dispose();
  
      Bitmap image = new Bitmap(256, 256);
      using (Graphics g = Graphics.FromImage(image))
      {
          g.FillRectangle(Brushes.Yellow, 0, 0, 256, 256);
          g.DrawString(sum.ToString(), new Font("Monospace", 26), Brushes.DarkGreen, 10, 10);
      }
      image.Save(@"e:\hello.jpg");
  
      return sum;
  }
#+end_src

点评:
- 不能实现不同调用的时候，具备不同逻辑

*** 通过一个 Flag 来通知 MyAdd 要去调用什么逻辑

#+begin_src cs
  class Program
  {
      static void Main(string[] args)
      {
          int r1 = MyAdd(1,    12, 32, 1112232, 43, 1112212, 3232323, 123);
          int r2 = MyAdd(2,    222, 333, 444);
          int r3 = MyAdd(4,    11, 2323, 4344);
      }
  
      public static int MyAdd(int flag, params int[] nums)
      {
          int sum = 0;
          for (int i = 0; i < nums.Length; i++)
          {
              sum += nums[i];
          }
  
          switch (flag)
          {
              case 1:
                  Print1(sum);
                  break;
              case 2:
                  Print2(sum);
                  break;
              case 3:
                  ToFile(sum);
                  break;
              case 4:
                  Speech(sum);
                  break;
              default:
                  Draw(sum);
                  break;
          }
          
          return sum;
      }
  
      static void Print1(int sum)
      {
          Console.ForegroundColor = ConsoleColor.Red;
          Console.WriteLine(sum);
          Console.ResetColor();
      }
  
      static void Print2(int sum)
      {
          Console.BackgroundColor = ConsoleColor.Red;
          Console.WriteLine("和为：" + sum);
          Console.ResetColor();
      }
  
      static void ToFile(int sum)
      {
          File.AppendAllText(@"E:\jiafa.txt", sum + "\r\n");
      }
  
      static void Speech(int sum)
      {
          SpeechSynthesizer synth = new SpeechSynthesizer();
          synth.Speak(sum.ToString());
          synth.Dispose();
      }
  
      static void Draw(int sum)
      {
          Bitmap image = new Bitmap(256, 256);
          using (Graphics g = Graphics.FromImage(image))
          {
              g.FillRectangle(Brushes.Yellow, 0, 0, 20, 20);
              g.DrawString(sum.ToString(), new Font("Monospace", 26), Brushes.DarkGreen, 10, 10);
          }
          image.Save(@"e:\hello.jpg");
      }
  }
#+end_src

点评:
- 很直观，很简洁，很清晰
- 使用 flag 很难通过数字判断出来相对应的逻辑 (可以通过 enum 的改造，改善这个问题)
- 灵活性严重不足，扩张起来麻烦死了。

*** 没有中间商赚差价，借助类和接口的方式，传递不同的方法

[[file:img/guaziershouche.png]]


#+begin_src cs
  class Program
  {
      static void Main(string[] args)
      {
          int r1 = MyAdd(new Print1(), 12, 32, 1112232, 43, 1112212, 3232323, 123);
          int r2 = MyAdd(new PrintAndWuwuwu(), 222, 333, 444);
      }
  
      public static int MyAdd(IMyAdd o, params int[] nums)
      {
          int sum = 0;
          for (int i = 0; i < nums.Length; i++)
          {
              sum += nums[i];
          }
  
          o.A(sum);
  
          return sum;
      }
  
      ////////////////////
  
      internal interface IMyAdd
      {
          void A(int sum);
      }
  
      class Print1 : IMyAdd
      {
          public void A(int sum)
          {
              Console.ForegroundColor = ConsoleColor.Red;
              Console.WriteLine(sum);
              Console.ResetColor();
          }
      }
  
      class Print2 : IMyAdd
      {
          public void A(int sum)
          {
              Console.BackgroundColor = ConsoleColor.Red;
              Console.WriteLine("和为：" + sum);
              Console.ResetColor();
          }
      }
  
      class ToFile : IMyAdd
      {
          public void A(int sum)
          {
              File.AppendAllText(@"E:\jiafa.txt", sum + "\r\n");
          }
      }
  
      class PrintAndWuwuwu : IMyAdd
      {
          public void A(int sum)
          {
              Console.BackgroundColor = ConsoleColor.Green;
              Console.WriteLine("哈哈哈，呜呜呜：" + sum);
              Console.ResetColor();
              SpeechSynthesizer synth = new SpeechSynthesizer();
              synth.Speak("呜呜呜呜呜呜呜，哈哈哈!");
              synth.Dispose();
          }
      }
  
      class Speech : IMyAdd
      {
          public void A(int sum)
          {
              SpeechSynthesizer synth = new SpeechSynthesizer();
              synth.Speak(sum.ToString());
              synth.Dispose();
          }
      }
  
      class Draw : IMyAdd
      {
          public void A(int sum)
          {
              Bitmap image = new Bitmap(256, 256);
              using (Graphics g = Graphics.FromImage(image))
              {
                  g.FillRectangle(Brushes.Yellow, 0, 0, 20, 20);
                  g.DrawString(sum.ToString(), new Font("Monospace", 26), Brushes.DarkGreen, 10, 10);
              }
              image.Save(@"e:\hello.jpg");
          }
      }
  }
#+end_src

*** 模板代码实在不爽，委托类型出现来救场

#+begin_src cs
  class Program
  {
      // 1. 声明一种数据类型，叫 MyWeiTuo，是委托类型
      public delegate void MyWeiTuo(int sum);
  
      static void Main(string[] args)
      {
          // 2. 通过 new 操作符，为这种类型创建一个实例
          MyWeiTuo v1 = new MyWeiTuo(PrintAndWuwuwu);
          // 3. 使用这个实例。这里主要用作方法的参数传递
          int r1 = MyAdd(v1, 12, 32, 1112232, 43, 1112212, 3232323, 123);
          int r2 = MyAdd(new MyWeiTuo(Print2), 222, 333, 444);
          int r3 = MyAdd(MyLove, 222, 333);
      }
  
      public static int MyAdd(MyWeiTuo o, params int[] nums)
      {
          int sum = 0;
          for (int i = 0; i < nums.Length; i++)
          {
              sum += nums[i];
          }
  
          o(sum);
  
          return sum;
      }
  
      static void Print1(int sum)
      {
          Console.ForegroundColor = ConsoleColor.Red;
          Console.WriteLine(sum);
          Console.ResetColor();
      }
  
      static void Print2(int sum)
      {
          Console.BackgroundColor = ConsoleColor.Red;
          Console.WriteLine("和为：" + sum);
          Console.ResetColor();
      }
  
      static void ToFile(int sum)
      {
          File.AppendAllText(@"E:\jiafa.txt", sum + "\r\n");
      }
  
      static void PrintAndWuwuwu(int sum)
      {
          Console.BackgroundColor = ConsoleColor.Green;
          Console.WriteLine("哈哈哈，呜呜呜：" + sum);
          Console.ResetColor();
          SpeechSynthesizer synth = new SpeechSynthesizer();
          synth.Speak("呜呜呜呜呜呜呜，哈哈哈!");
          synth.Dispose();
      }
  
      static void Speech(int sum)
      {
          SpeechSynthesizer synth = new SpeechSynthesizer();
          synth.Speak(sum.ToString());
          synth.Dispose();
      }
  
      static void Draw(int sum)
      {
          Bitmap image = new Bitmap(256, 256);
          using (Graphics g = Graphics.FromImage(image))
          {
              g.FillRectangle(Brushes.Yellow, 0, 0, 20, 20);
              g.DrawString(sum.ToString(), new Font("Monospace", 26), Brushes.DarkGreen, 10, 10);
          }
          image.Save(@"e:\hello.jpg");
      }
  
      static void MyLove(int sum)
      {
          Console.WriteLine("我就是喜欢黄色，则么了.");
      }
  }
#+end_src

** 基本语法

#+begin_src cs
  // 1. 声明 (委托类型)
  delegate void MyMethod1();
  delegate int MyMethod2(int a, int b);
  
  class Program
  {
      static void Main(string[] args)
      {
          // 2. 实例化
          MyMethod1 m1 = new MyMethod1(Hahaha);
          MyMethod2 m2 = new MyMethod2(new Program().Heiheihei);
          MyMethod1 m3 = Hahaha;
          MyMethod2 m4 = new Program().Heiheihei;
          MyMethod2 m5 = Hehehe;
  
          // 3. 使用
          m1();
          m2(1, 2);
      }
  
      static void Hahaha()
      {
          Console.WriteLine("hahaha, henkuaile.");
      }
  
      int Heiheihei(int a, int b)
      {
          return a * b;
      }
  
      static int Hehehe(int a, int b)
      {
          return a + b * a - b;
      }
  }
#+end_src

** 匿名委托

#+begin_src cs
  // 1. 声明
  delegate void MyAddWT(int sum);
  
  class Program
  {
      static void Main(string[] args)
      {
          // 2. 实例化
          MyAddWT maw = delegate(int sum)
          {
              Console.WriteLine("hahaha, henkuaile.");
          };
          // 3. 使用
          MyAdd(1, 3, maw);
  
          MyAdd(111, 333, delegate(int sum)
          {
              Console.WriteLine("我的结果是 {0}", sum);
          });
  
          MyAdd(121, 232, delegate(int sum)
          {
              Console.WriteLine("我不告诉你结果");
          });
      }
  
      static int MyAdd(int a, int b, MyAddWT maw)
      {
          int r = a + b;
          maw(r);
          return r;
      }
  }
#+end_src

** 表达式语法

#+begin_src cs
  // 1. 声明
  delegate void MyAddWT(int sum);
  delegate void MyAddWT(double sum);
  delegate string MyAddWT(double sum);
  
  class Program
  {
      static void Main(string[] args)
      {
          // MyAddWT maw1 = new MyAddWT(MyAddShixian);
          // MyAddWT maw2 = MyAddShixian;
  
          MyAddWT maw3 = delegate(int sum)
              {
                  Console.WriteLine("aaa");
              };
  
          // 2. 实例化
          MyAddWT maw4 = (int sum) =>
          {
              Console.WriteLine("aaa");
          };
  
          MyAddWT maw5 = (sum) =>
          {
              Console.WriteLine("aaa");
          };
  
          MyAddWT maw6 = sum =>
          {
              Console.WriteLine("aaa");
          };
  
          MyAddWT maw7 = sum => Console.WriteLine("aaa");
  
          // 3. 使用
          MyAdd(111, 222, maw7);
          MyAdd(222, 333, s => Console.WriteLine($"result: {s}"));
      }
  
      static int MyAdd(int a, int b, MyAddWT maw)
      {
          int r = a + b;
          maw(r);
          return r;
      }
  }
#+end_src

** 内建的委托类型 Action/Func

#+begin_src cs
  class Program
  {
      static void Main(string[] args)
      {
          //MyAdd2(222, 333, (a, b, r) => Console.WriteLine($"{a} 加上 {b} 等于 {r}"));
          //MyAdd2(222, 333, (a, b, r) => Console.WriteLine($"{a} add {b} equals {r}"));
          MyAdd2(222, 333, (a, b, r, s1, s2) => Console.WriteLine($"{a} {s1} {b} {s2} {r}"));
      }
  
      static int MyAdd1(int a, int b, Action act)
      {
          int r = a + b;
          act();
          return r;
      }
  
      static int MyAdd2(int a, int b, Action<int, int, int, string, string> act)
      {
          int r = a + b;
          act(a, b, r, "jiashang", "dengyu");
          return r;
      }
  }
#+end_src

** 多播委托

#+begin_src cs
  class Program
  {
      static void Main(string[] args)
      {
          MyWT a = new MyWT(MyAdd);
          MyWT b = new MyWT(MyMul);
          MyWT c = new MyWT(MyFuza);
  
          MyWT d = a + b + c + a + a + a + a;
          MyWT e = d + b;
          e += a;
          e -= a;
          Console.WriteLine(e(4, 5));
  
          // var d = a + b + c;
          // Console.WriteLine(d(4,5));
          // Console.WriteLine((a + b + c)(4, 5));
      }
  
      static int MyAdd(int a, int b)
      {
          int r = a + b;
          Console.WriteLine("Add: {0}", r);
          return r;
      }
  
      static int MyMul(int a, int b)
      {
          int r = a * b;
          Console.WriteLine("Mul: {0}", r);
          return r;
      }
  
      static int MyFuza(int a, int b)
      {
          int r = (int)(a * a + Math.Pow(b, 4));
          Console.WriteLine("Fuza: {0}", r);
          return r;
      }
  }
#+end_src

** [练习] 如何简化图片绘制的代码

#+begin_src cs
  class Program
  {
      static void Main(string[] args)
      {
          
      }
  
      static void DrawHello()
      {
          Bitmap image = new Bitmap(256, 256);
          using (Graphics g = Graphics.FromImage(image))
          {
              g.DrawString("Hello", new Font("Monospace", 26), Brushes.DarkGreen, 10, 10);
          }
          image.Save(@"e:\hello.jpg");
      }
  
      static void DrawWorld()
      {
          Bitmap image = new Bitmap(256, 256);
          using (Graphics g = Graphics.FromImage(image))
          {
              g.FillRectangle(Brushes.Yellow, 0, 0, 20, 20);
              g.DrawString("World", new Font("Monospace", 26), Brushes.DarkOrange, 10, 10);
          }
          image.Save(@"e:\hello.jpg");
      }
  }
#+end_src

示例:
#+begin_src cs
  class Program
  {
      static void Main(string[] args)
      {
          WithGraphics(@"e:\hello333.jpg", g =>
          {
              g.DrawString("wqwww", new Font("Aria", 46), Brushes.Aqua, 0, 300);
              g.DrawString("Hello", new Font("Monospace", 26), Brushes.DarkGreen, 10, 10);
          }, 500, 500);
  
          WithGraphics(@"e:\hello4444.jpg", pen =>
          {
              pen.FillRectangle(Brushes.Yellow, 0, 0, 20, 20);
              pen.DrawString("World", new Font("Monospace", 26), Brushes.DarkOrange, 10, 10);
          });
      }
  
      static void WithGraphics(string file, Action<Graphics> act, int width = 256, int height = 256)
      {
          if (File.Exists(file))
          {
              Console.WriteLine("文件已经存在....");
              return;
          }
  
          if (width <= 0 || height <= 0)
              throw new Exception("尺寸不能为负");
  
          // Bitmap image2 = new Bitmap(file);
          Bitmap image = new Bitmap(width, height);
  
          using (Graphics g = Graphics.FromImage(image))
          {
              act(g);
              g.DrawString("161", new Font("微软雅黑", 24), Brushes.Red, width - 50, height - 30);
          }
  
          image.Save(file);
      }
  }
#+end_src

** [练习] 如何简化输出程序执行时间的逻辑

#+begin_src cs
  class Program
  {
      static void Main(string[] args)
      {
          WithElapsedTime(() =>
          {
              WithGraphics(@"e:\hello333.jpg", g =>
              {
                  g.DrawString("wqwww", new Font("Aria", 46), Brushes.Aqua, 0, 300);
                  g.DrawString("Hello", new Font("Monospace", 26), Brushes.DarkGreen, 10, 10);
              }, 500, 500);
          });
  
  
          WithElapsedTime(() =>
              WithGraphics(@"e:\hello4444.jpg", pen =>
              {
                  pen.FillRectangle(Brushes.Yellow, 0, 0, 20, 20);
                  pen.DrawString("World", new Font("Monospace", 26), Brushes.DarkOrange, 10, 10);
              }));
      }
  
      static void WithElapsedTime(Action code)
      {
          var sw = new Stopwatch();
          sw.Start();
          code();
          Console.WriteLine("程序执行消耗的时间为: {0}", sw.ElapsedMilliseconds);
          sw.Stop();
      }
  
      static void WithGraphics(string file, Action<Graphics> act, int width = 256, int height = 256)
      {
          if (File.Exists(file))
          {
              Console.WriteLine("文件已经存在....");
              return;
          }
  
          if (width <= 0 || height <= 0)
              throw new Exception("尺寸不能为负");
  
          // Bitmap image2 = new Bitmap(file);
          Bitmap image = new Bitmap(width, height);
  
          using (Graphics g = Graphics.FromImage(image))
          {
              act(g);
              g.DrawString("161", new Font("微软雅黑", 24), Brushes.Red, width - 50, height - 30);
          }
  
          image.Save(file);
      }
  }
#+end_src

* 数组 (Array)
** 一维数组

#+begin_src cs
  // 1. 声明
  int[] arr1;
  string[] arr2;
  
  // 2. 实例化
  arr1 = new int[4];
  
  // 3. 初始值
  arr1[0] = 22;
  arr1[1] = 5;
  arr1[2] = 45;
  arr1[3] = 555;
  // arr1[4] = 777; // System.IndexOutOfRangeException
  
  // 4. 基本访问
  for (var i = 0; i < arr1.Length; i++)
  {
      Console.WriteLine(arr1[i]);
  }
  
  // string
  string[] arr2;
  arr2 = new string[5];
  arr2[3] = "hello";
  Console.WriteLine(arr2[0] == null); // true
  
  // Student
  Student[] arr3;
  arr3 = new Student[8];
  arr3[3] = new Student();
  Console.WriteLine(arr3[0] == null); // true
#+end_src


数组表示法:
#+begin_src cs
  int[] arr0;
  arr0 = new int[4];
  arr0[0] = 22;
  arr0[1] = 5;
  arr0[2] = 45;
  arr0[3] = 555;
  
  int[] arr1 = new int[4]; 
  arr1[0] = 22;
  arr1[1] = 5;
  arr1[2] = 45;
  arr1[3] = 555;
  
  int[] arr2 = new int[4] { 22, 5, 45, 555 };
  
  int[] arr3 = new int[] { 22, 5, 45, 555 };
  
  int[] arr4 = { 22, 5, 45, 555 };
  
  var arr5 = new int[]{ 22, 5, 45, 555 };
  var arr6 = new [] { 22, 5, 45, 555 };
  
  // 小结:
  int[] arr = { 22, 5, 45, 555 };
  var arr = new []{ 22, 5, 45, 555 };
#+end_src

数组的扩张:
#+begin_src cs
  int[] arr = { 22, 5, 45, 555 };
  arr[4] = 666;
  arr[5] = 777;
#+end_src

** 多维数组 (Dimensional Array)

#+begin_src cs
  int[,,] arr =
  {
      {{2, 3, 4, 1}, {2, 3, 4, 1}, {2, 3, 4, 1},{2, 3, 4, 1}},
      {{2, 3, 4, 1}, {2, 3, 4, 1}, {2, 3, 4, 1},{2, 3, 4, 1}},
      {{2, 3, 4, 1}, {2, 3, 4, 1}, {2, 3, 4, 1},{2, 3, 4, 1}},
      {{2, 3, 4, 1}, {2, 3, 4, 1}, {2, 3, 4, 1},{2, 3, 4, 1}}
  };
  Console.WriteLine(arr.Rank); // 秩
  Console.WriteLine(arr.Length);
  Console.WriteLine(arr.GetLength(0));
#+end_src

** 交错数组 (Jagged Array)

#+begin_src cs
  int[][] arr = new int[3][];
  arr[0] = new int[] {1, 2, 3, 4, 5};
  arr[1] = new int[] {3, 4};
  arr[2] = new int[] {1};
  
  int[][,] arr2 = new int[3][,];
  arr2[2] = new int[,] { {2}, {3} };
#+end_src

* 元组 (Tuple/ValueTuple)

#+begin_src cs
  class Student
  {
      public int Id;
      public string Name;
      public double Score;
      public string Tel;
  }
  
  class Program
  {
      static void Main()
      {
          // 使用数组的方式，可以存储处理相同类型的数据
          int[] ids = new int[] { 1, 2, 3, 4 };
          string[] names = new string[] { "小明", "小红", "大黄", "张三" };
          double[] scores = new double[] { 67.5, 60, 59.9, 90 };
  
          // 使用类和对象的方式，可以处理不同数据的存储 (强大，但麻烦)
          Student s1 = new Student();
          s1.Id = 2;
          s1.Name = "小红";
          s1.Score = 60;
          var s3 = new Student { Id = 1, Name = "小明", Score = 67.5 };
          var s4 = new Student { Id = 3, Name = "大黄", Score = 59, Tel = "+86110" };
  
          // 匿名类型，不需要事先声明一个类，就可以实例化出一个对象来
          var s5 = new { Xuehao = 3, Xingming = "大黄", Fenshu = 59, Dianhua = "+86110", Dizhi = "地球村" };
          Console.WriteLine(s5.Fenshu);
          Console.WriteLine(s5.GetType());
  
          // 元组 (Tuple)
          Tuple<int, int> s6 = new Tuple<int, int>(111, 2222);
          Tuple<int, string, int, string> s61 = Tuple.Create(111, "小明", 67, "110");
          xxx(s61);
          Console.WriteLine(s61.Item1);
  
          // 使用 out 的方式，处理方法的多个返回值
          string name;
          int age = yyy(out name);
  
          // 使用 Tuple 的方式
          var r = zzz();
          Console.WriteLine(r.Item1);
          Console.WriteLine(r.Item2);
  
          // ValueTuple
      }
  
      static void xxx(Tuple<int, string, int, string> sss)
      {
          Console.WriteLine($"{sss.Item2} 的成绩为 {sss.Item3}!");
      }
  
      static int yyy(out string name)
      {
          name = "zhangsan";
          int age = 16;
          return age;
      }
  
      static Tuple<int, string> zzz()
      {
          return Tuple.Create(16, "xiaohua");
      }
  }
#+end_src

ValueTuple:
#+begin_src cs
  class Program
  {
      static void Main()
      {
          // 元组 (Tuple，很丑很温柔)
          Tuple<int, int> s6 = new Tuple<int, int>(111, 2222);
          Tuple<int, string, int, string> s61 = Tuple.Create(111, "小明", 67, "110");
  
          // ValueTuple
          ValueTuple<int, int> s7 = new ValueTuple<int, int>(111, 2222);
          ValueTuple<int, string, int, string> s71 = ValueTuple.Create(111, "小明", 67, "110");
          var s72 = ValueTuple.Create(111, "小明", 67, "110");
          s72.Item3 = 77;
          Console.WriteLine(s72.Item3);
  
          // 简化，语法糖
          var s73 = (111, "小明", 67, "110");
          Console.WriteLine(s73.Item2);
  
          var s74 = (111, name: "小明", 67, "110");
          Console.WriteLine(s74.name);
          var s75 = (id: 111, name: "小明", score: 67, tel: "110");
          Console.WriteLine($"{s75.name} 的分数是 {s75.score}，快告诉ta爸爸，号码是 {s75.tel}");
  
          //var s76 = (111, "小明", 67, "110");
          //var id = s76.Item1;
          //var name = s76.Item2;
          //var score = s76.Item3;
          //var tel = s76.Item4;
          (int id, string name, double score, string tel) = (111, "小明", 67, "110");
          var (id2, name2, score2, tel2) = (111, "小明", 67, "110");
          Console.WriteLine($"{name2} 的分数是 {score2}，快告诉ta爸爸，号码是 {tel2}");
          var (_, _, _, tel3) = (111, "小明", 67, "110");
  
  
          // xxx1 的调用
          string n1;
          int a1 = xxx1(out n1);
  
          // xxx2 的调用
          var t1 = xxx2();
          Console.WriteLine(t1.Item2);
  
          // xxx3 的调用
          var (age2, name8) = xxx3();
          Console.WriteLine(age2);
  
          // xxx4 的调用
          var (aa4, nn4) = xxx3();
          Console.WriteLine($"名字是 {nn4}, 年龄是 {aa4}");
      }
  
      static int xxx1(out string name)
      {
          name = "xm";
          return 16;
      }
  
      static Tuple<int, string> xxx2()
      {
          return Tuple.Create(16, "xm");
      }
  
      static ValueTuple<int, string> xxx3()
      {
          return ValueTuple.Create(16, "xm");
      }
  
      static (int, string) xxx4()
      {
          return (16, "xm");
      }
  }
#+end_src

* 集合 (Collections)
** System.Collections
*** ArrayList

- 以数字为下标
- 有序的，自动编号
- 集合 (数据容器)

#+begin_src cs
  class Program
  {
      static void Main()
      {
          // 数组，本身长度是不能变化的
          // 因此，要往数组里添加元素，只能创建一个更长的数组取代它
          var a1 = new[] {1, 2, 3};
          var a2 = new int[a1.Length + 1];
          a2[0] = a1[0];
          a2[1] = a1[1];
          a2[2] = 4;
          a2[3] = a1[2];
          a1 = a2;
  
          // 我们可以通过自定义一个类的方式，将上述的操作封装起来
          var na1 = new NideArray();
          na1.Add(1);
          na1.Add(2);
          na1.Add(3);
  
          foreach (var o in na1.innerArray)
          {
              Console.WriteLine(o);
          }
  
          // 直接使用 BCL 中的集合类，不需要造轮子
          var al = new ArrayList();
          al.Add(1);
          al.Add(21111);
          al.Add(3);
  
          Console.WriteLine("长度 {0}", al.Count);
          al.Remove(3);
          al.RemoveAt(0);
          Console.WriteLine("长度 {0}", al.Count);
          foreach (var o in al)
          {
              Console.WriteLine(o);
          }
  
      }
  }
  
  class NideArray
  {
      public object[] innerArray = { 1, 2, 3 };
  
      public void Add(object o)
      {
          var arr = new object[innerArray.Length + 1];
          for (var i = 0; i < innerArray.Length; i++)
          {
              arr[i] = innerArray[i];
          }
  
          arr[arr.Length - 1] = o;
          innerArray = arr;
      }
  
      public void Remove(object o)
      {
  
      }
  }
#+end_src

*** Hashtable

- 以对象为下标
- k-v pair / 键值对
- 对于 key 最重要的是: 唯一性

#+begin_src cs
  class Program
  {
      static void Main()
      {
          // 序号 vs 名字
          var t1 = (123, "小明", 78.5, "110"); // t1.Item1, t1.Item2 ...
          var t2 = (id: 123, name: "小明", score: 78.5); // t2.name, t2.score
  
          // 序号
          var n1 = new ArrayList();
          n1.Add("小明"); // 0
          n1.Add("小红"); // 1
          n1.Add("小蓝"); // 2
  
          var s1 = new ArrayList();
          s1.Add(59.5); // 0
          s1.Add(97.5); // 1
          s1.Add(67.5); // 2
          Console.WriteLine("取某个值: {0}", s1[0]);
  
          for (int i = 0; i < 3; i++)
          {
              string name = n1[i].ToString();
              double score = (double)s1[i];
              Console.WriteLine($"{name} 的成绩为 {score}");
          }
  
          // 显式指定名字 (k-v)
          var s2 = new Hashtable();
          s2.Add("小明", 59.5);
          s2.Add("小红", 97.5);
          s2.Add("小蓝", 67.5);
          s2.Add("小强", 167.5);
          s2.Add("小弱", 667.5);
          Console.WriteLine("取某个值: {0}", s2["小明"]);
  
          foreach (DictionaryEntry o in s2)
          {
              Console.WriteLine($"- {o.Key}: {o.Value}");
          }
  
          foreach (var k in s2.Keys)
          {
              Console.WriteLine(k);
          }
      }
  }
#+end_src

可以以自定义对象为下标，但是 *需要重写 GetHashCode/Equals 方法*:
#+begin_src cs
  class Program
  {
      static void Main()
      {
          // 以对象为 Key
          var s3 = new Hashtable();
          s3.Add(new Student("小明"), 59.5);
          s3.Add(new Student("小红"), 97.5);
          s3.Add(new Student("小蓝"), 67.5);
          s3.Add(new Student("小强"), 167.5);
          s3.Add(new Student("小弱"), 667.5);
  
          Console.WriteLine("+ {0}", s3[new Student("小弱")]);
      }
  }
  
  class Student
  {
      public string Name { get; set; }
      public string Tel { get; set; }
  
      public Student()
      {
      }
  
      public Student(string name) => Name = name;
  
      public override int GetHashCode()
      {
          return Name.GetHashCode();
      }
  
      public override bool Equals(object? obj)
      {
          Student s = obj as Student;
          return s != null && Name == s.Name;
      }
  }
#+end_src

*** Queue

FIFO (First In First Out，先进先出):
#+begin_src cs
  var q1 = new Queue();
  q1.Enqueue(111);
  q1.Enqueue(222);
  q1.Enqueue(333);
  
  object who = q1.Dequeue();
  Console.WriteLine(who);
  Console.WriteLine(q1.Peek()); // 只看不移除
  Console.WriteLine(q1.Dequeue());
  
  Console.WriteLine(q1.Count);
  
  object[] arr = q1.ToArray();
#+end_src

*** Stack

LIFO (Last In First Out，后进先出):
#+begin_src cs
  var s1 = new Stack();
  s1.Push(111);
  s1.Push(222);
  s1.Push(333);
  
  object who = s1.Pop();
  Console.WriteLine(who);
  Console.WriteLine(s1.Peek());
  Console.WriteLine(s1.Pop());
  
  Console.WriteLine(s1.Count);
  Console.WriteLine(s1.Peek());
  
  s1.Clear();
#+end_src

实现自己的栈:
#+begin_src cs -n
  class MyStack
  {
      private int stackTop = 0; // 栈顶
      private object[] _items = new object[200];
  
      public void Push(object w)
      {
          _items[stackTop] = w;
          stackTop = stackTop + 1;
      }
  
      public object Pop()
      {
          stackTop = stackTop - 1;
          return _items[stackTop];
      }
  
      public object Peek()
      {
          return _items[stackTop - 1];
      }
  
      public int Count
      {
          get => stackTop;
      }
  
      public void Clear()
      {
          stackTop = 0;
      }
  }
#+end_src

*** SortedList/BitArray


** System.Collections.Generic
*** List<T>

#+begin_src cs
  List<string> l1 = new List<string>();
  
  var l2 = new List<string>();
  l2.Add("aaaa");
  l2.Add("bbbb");
  l2.Add("1");
  l2.Add("2");
  l2.Add("3");
  l2.Add("4");
  l2.Insert(1, "ccc");
  l2.RemoveAll(s => s.Length < 4);
  
  var l3 = new List<string> {"aaaa", "bbbb", "1", "2", "3", "4"};
  l3.Insert(1, "ccc");
  l3.RemoveAll(s => s.Length < 4);
  
  string s1 = l2[0];
  foreach (var e in l2)
  {
      Console.WriteLine(e);
  }
#+end_src

*** Dictionary<TKey, TValue>

#+begin_src cs
  var d1 = new Dictionary<string, double>();
  d1.Add("xm", 67.5);
  d1.Add("xh", 97.5);
  d1.Add("xl", 75);
  
  var d2 = new Dictionary<string, double>
  {
      {"xm", 67.5}, 
      {"xh", 97.5}, 
      {"xl", 75}
  };
  double s1 = d2["xh"];
  Console.WriteLine(s1);
  
  bool isSuccess = d2.TryAdd("xm", 100);
  Console.WriteLine(isSuccess);
  
  foreach (var value in d2.Values)
  {
      Console.WriteLine(value);
  }
#+end_src

*** Queue<T>

#+begin_src cs
  var q1 = new Queue<string>();
  q1.Enqueue("小明");
  q1.Enqueue("小兰");
  q1.Enqueue("小朱");
  
  string n1 = q1.Dequeue();
  Console.WriteLine(n1);
#+end_src

*** Stack<T>

#+begin_src cs
  var s1 = new Stack<string>();
  s1.Push("小明");
  s1.Push("小兰");
  s1.Push("小朱");
  
  string n1 = s1.Pop();
  string n2 = s1.Peek();
  
  bool shibushichenggongle = s1.TryPop(out string n3);
  Console.WriteLine(shibushichenggongle);
#+end_src

*** LinkedList<T>

https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.linkedlist-1?view=net-5.0

*** HashSet<T>

- 无序
- 唯一

#+begin_src cs
  var hs1 = new HashSet<string>();
  hs1.Add("hello");
  hs1.Add("world");
  hs1.Add("!");
  hs1.Add("!");
  
  var hs2 = new HashSet<string>();
  hs2.Add("aaa");
  hs2.Add("world");
  
  Console.WriteLine(hs1.Count);
  hs1.IntersectWith(hs2);
  hs1.UnionWith(hs2);
  
  // 去重的一种方法
  var list1 = new List<int> { 1, 2, 11, 22, 2, 3, 1, 2, 33, 44, 22 };
  var hs3 = new HashSet<int>(list1);
  foreach (var o in hs3.ToList())
  {
      Console.WriteLine(o);
  }
#+end_src

*** SortedList/Set/Dictionary<>

** System.Collections.Immutable

ImmutableList:
#+begin_src cs
  static void Main()
  {
      var list1 = new List<string>
      {
          "hello", "world", "!"
      };
      Console.WriteLine(list1.Count);
      Xxx(list1.ToImmutableList());
      Console.WriteLine(list1.Count);
  }
  
  static void Xxx(ImmutableList<string> l)
  {
      l.Add("kkkkkkk");
      l.Add("kkkkkk2");
      l = l.Add("kkkk").Add("1").Add("33");
      foreach (var s in l)
      {
          Console.WriteLine(s);
      }
  }
#+end_src



* IEnumerable/Linq

1. string/array/List/Dict 虽然不是同一种类型，但是很像，有没有内在相似的逻辑? [思考]
2. a) 容器 b) 遍历
3. 将上述两点逻辑，抽象为接口 IEnumerable/IEnumerator(MoveNext,Current)
4. 为了便于使用这个接口，出现 foreach 语法
5. 通过插件的形式，推出了 Linq 的机制 (Where/Select/OrderBy/Avg/Sum)
   + Method 语法
   + Query 表达式语法 (Linq to Object)
6. Linq Provider (Linq 供应商/提供者):
   + Linq to XML
   + Linq to SQL
   + Linq to Entity

** IEnumerable/IEnumerator/foreach

#+begin_src csharp
  class Program
  {
      static void Main(string[] args)
      {
          string s1 = "hello world";
          int[] a1 = {1, 2, 3, 4};
          List<double> l1 = new List<double> {1.2, 2.3, 4.6};
  
          Rainbow rb = new Rainbow();
  
          foreach (var e in rb)
          {
              Console.WriteLine(e);
          }
      }
  }
  
  class Rainbow : IEnumerable
  {
      private string[] colors = {"Red", "Orange", "Yellow", "Green", "Blue", "Dian", "Purple"};
  
      public void Show()
      {
          Console.WriteLine($"我有 {colors.Length} 种颜色");
      }
  
      public IEnumerator GetEnumerator()
      {
          return new MyEnumerator(colors);
      }
  
      class MyEnumerator : IEnumerator
      {
          private string[] colors;
          private int index = 0;
  
          public MyEnumerator(string[] cs)
          {
              colors = new string[cs.Length];
              for (int i = 0; i < cs.Length; i++)
              {
                  colors[i] = cs[i];
              }
          }
  
          public bool MoveNext()
          {
              if (index > colors.Length - 1 || index < 0)
              {
                  return false;
              }
  
              index++;
              return true;
          }
  
          public object Current
          {
              get
              {
                  return colors[index - 1];
              }
          }
  
          public void Reset()
          {
              index = 0;
          }
      }
  }
#+end_src

泛型版本:
#+begin_src csharp
  class Rainbow : IEnumerable<string>
  {
      private string[] colors = {"Red", "Orange", "Yellow", "Green", "Blue", "Dian", "Purple"};
  
      public void Show()
      {
          Console.WriteLine($"我有 {colors.Length} 种颜色");
      }
  
      public IEnumerator<string> GetEnumerator()
      {
          yield return "222";
          yield return "333";
          yield return "444";
      }
  
      IEnumerator IEnumerable.GetEnumerator()
      {
          return GetEnumerator();
      }
  }
#+end_src

** Iterator

语法糖。

#+begin_src csharp
  public IEnumerator GetEnumerator()
  {
      for (int i = 0; i < colors.Length; i++)
      {
          yield return colors[i];
      }
  }
#+end_src

灵活的遍历逻辑:
#+begin_src csharp
  class Program
  {
      static void Main(string[] args)
      {
          string s1 = "hello world";
          int[] a1 = {1, 2, 3, 4};
          List<double> l1 = new List<double> {1.2, 2.3, 4.6};
          Dictionary<int, string> d = new Dictionary<int, string>();
  
          Rainbow rb = new Rainbow();
  
          foreach (var e in rb.GetMyEnumerator4)
          {
              Console.WriteLine(e);
          }
      }
  }
  
  class Rainbow : IEnumerable
  {
      private string[] colors = {"Red", "Orange", "Yellow", "Green", "Blue", "Dian", "Purple"};
  
      public  void Show()
      {
          Console.WriteLine($"我有 {colors.Length} 种颜色");
      }
  
      public IEnumerator GetEnumerator()
      {
          return GetMyEnumerator1();
      }
  
      IEnumerator GetMyEnumerator1()
      {
          for (int i = 0; i < colors.Length; i++)
          {
              yield return colors[i];
          }
      }
  
      IEnumerator GetMyEnumerator2
      {
          get
          {
              yield return "赤";
              yield return "橙";
              yield return "黄";
              yield return "绿";
          }
      }
  
      public IEnumerable GetMyEnumerator3()
      {
          yield return 1;
          yield return 2;
          yield return 3;
          yield return 4;
      }
  
      public IEnumerable GetMyEnumerator4
      {
          get
          {
              yield return 666;
          }
      }
  }
#+end_src


** Linq

Linq (Language Integrated Query，语言集成扩展)：
- 基于 IEnumerable<T> 类型进行的 *扩展*
- 实现在 System.Linq.Enumerable 类中，通过扩展方法的形式实现的
- 支持两种语法: Method Syntax 和 Query Syntax

*** Method Syntax

- 筛选操作符: Where/OfType
- 投射操作符: Select/SelectMany
- 顺序操作符: OrderBy/ThenBy/OrderByDescending/ThenByDescending/Reverse
- 连接操作符: Join/GroupJoin
- 组合操作符: GroupBy/ToLookup
- 限定操作符: Any/All/Contains
- 范围操作符: Take/Skip/TakeWhile/SkipWhile
- 集合操作符: Distinct/Union/Intersect/Except/Zip
- 返回单元素: First/FirstOrDefault/Last/LastOrDefault/ElementAt/ElementAtOrDefault/Single/SingleOrDefault
- 聚合操作符: Count/Sum/Min/Max/Average/Aggregate
- 转换操作符: ToArray/AsEnumerable/ToList/ToDictionary/Cast
- 生成操作符: Empty/Range/Repeat

#+begin_src csharp
  class Program
  {
      static void Main(string[] args)
      {
          string s1 = "hello world";
          int[] a1 = {1, 2, 666, 4, 6, 7, 5, 3, 4};
          int[] a11 = {666, 777, 888};
          object[] a2 = { 1, 2, "666", 4, 6, "7", 5.5, 3, 4 };
          string[] a3 = {"Hello", "World", "where", "are", "You"};
          List<double> l1 = new List<double> {1.2, 2.3, 4.6};
          Dictionary<int, string> d = new Dictionary<int, string>();
  
          List<BookType> types = new List<BookType>
          {
              new BookType(1, "科技类"),
              new BookType(2, "科幻类"),
              new BookType(3, "科学类"),
          };
          List<Book> books = new List<Book>
          {
              new Book(1, "C# 编程语言", 222, 1),
              new Book(2, "VueJS", 22, 1),
              new Book(3, "三体", 23, 2),
              new Book(4, "星际穿越", 54, 2),
              new Book(5, "仙剑", 64, 2),
              new Book(6, "动物世界", 222, 3),
              new Book(9, "钢铁是怎么炼成的", 11, 3),
          };
  
          // 过滤、筛选
          IEnumerable<int> r1 = a1.Where(x => x > 5);
          var r2 = a2.OfType<int>();
          var r3 = a2.Where(x => x is string);
  
          // 投射
          var r4 = a1.Select(x => x > 10 ? x : x + 10);
          var r5 = a1.Select(x => $"这个数是: {x + 1}");
          var r6 = a1.Select(x => (x, $"{x + 1}"));
  
          // 排序
          var r7 = a1.Reverse();
          var r8 = a1.OrderBy(x => -x);
          var r9 = a1.OrderByDescending(x => x);
          var r10 = a3.OrderBy(x => x.Length);
          var r11 = a3.OrderBy(x => x.Length).ThenByDescending(x => x[0]);
          var r12 = books.OrderBy(x => x.Price);
          var r13 = books.Where(x => x.TypeId != 2).OrderBy(x => x.Price);
  
          // 连接
          var r14 = books.Join(
              types,
              book => book.TypeId,
              type => type.ID,
              (book, type) => (typeName: type.Name, book)
          );
          var r15 = books
              .Join(
                  types,
                  book => book.TypeId,
                  type => type.ID,
                  (book, type) => (typeName: type.Name, book)
              )
              .Where(o => o.typeName == "科幻类")
              .Select(o => o.book);
  
          // 范围
          var r16 = a1.Take(3); // limit 3
          var r17 = a1.TakeLast(3);
          var r18 = a1.TakeWhile(x => x < 5);
          var r19 = a1.Skip(2).Take(3);
          var r20 = a1.SkipLast(3).Where(x => x > 1).OrderBy(x => x);
  
          // 集合
          var r21 = a1.Except(a11);
          var r22 = a1.Union(a11);
          var r23 = a1.Distinct(); // 去重
          var r24 = a1.Zip(a1.Select(x => x + 100));
  
          // 返回单个
          var r25 = a1.Zip(a1.Select(x => x + 100)).First();
          var r26 = a1.Zip(a1.Select(x => x + 100)).Last();
          var r27 = a1.Zip(a1.Select(x => x + 100)).ElementAt(3);
          var r28 = a1.Zip(a1.Select(x => x + 100)).Take(1).Single();
          var r29 = a1.Where(x => x > 10000).FirstOrDefault();
  
          // 聚合
          var r30 = a1.Sum();
          var r31 = a1.Average();
          var r32 = a1.Max();
  
          // 转换 (IEnumerable)
          int[] r33 = a1.Take(3).ToArray();
          List<int> r34 = a1.Take(3).ToList();
          Dictionary<string, int> r35 = a1.Take(3).ToDictionary(x => $"id-{x}", x => x);
          string r36  = string.Concat("hello, world".Select(x => (char) (x + 1)));
  
          // 静态、生成
          var r37 = Enumerable.Empty<int>(); // 生成一个空的 int 的可枚举类
          IEnumerable<int> r38 = Enumerable.Range(1, 100);
          var r39 = Enumerable.Repeat("xxx", 10);
          var r40 = string.Concat(Enumerable.Repeat("-", 100));
  
          Console.WriteLine(r40);
  
          //foreach (var e in r39)
          //{
          //    Console.WriteLine(e);
          //}
      }
  }
#+end_src

*** Query Syntax/Expression

- Query 表达式，最终会被通过 Provider 提供的机制翻译成相关的方法调用。最终效果是一样的。不过 Provider 可能会进行一定程度的优化
- 在一个 Query 表达式中，from 和 select/group 是必须的，其他可选
  
#+begin_src csharp
  class Program
  {
      static void Main(string[] args)
      {
          string s1 = "hello world";
          int[] a1 = {1, 2, 666, 4, 6, 7, 5, 3, 4};
          int[] a11 = {666, 777, 888};
          object[] a2 = { 1, 2, "666", 4, 6, "7", 5.5, 3, 4 };
          string[] a3 = {"Hello", "World", "where", "are", "You"};
          
          List<BookType> types = new List<BookType>
          {
              new BookType(1, "科技类"),
              new BookType(2, "科幻类"),
              new BookType(3, "科学类"),
          };
          List<Book> books = new List<Book>
          {
              new Book(1, "C# 编程语言", 222, 1),
              new Book(2, "VueJS", 22, 1),
              new Book(3, "三体", 23, 2),
              new Book(4, "星际穿越", 54, 2),
              new Book(5, "仙剑", 64, 2),
              new Book(6, "动物世界", 222, 3),
              new Book(9, "钢铁是怎么炼成的", 11, 3),
          };
  
          IEnumerable<int> r0 = from x in a1 select x;
          var r1 = a1.Where(x => x > 5).Select(x => x);
          var r2 = from x in a1 where x > 5 select x;
          var r3 = from x in a1 where x > 5 select x + 1000;
          var r4 = from x in a1 where x > 5 select $"I am {x * x}";
  
          var r5 = from x in a1 where x > 5 orderby x select x;
          var r6 = from x in a1 where x > 5 orderby x descending select x;
  
          var r7 =
              from book in books
              join type in types
              on book.TypeId equals type.ID
              select (type.Name, book, type);
  
          var r8 = from book in books
              join type in types on book.TypeId equals type.ID
              where type.Name == "科幻类"
              select book;
  
          double avg1 = r8.Average(book => book.Price);
          double avg2 = r8.Select(book => book.Price).Average();
          double avg3 =
              (
                  from book in books
                  join type in types on book.TypeId equals type.ID
                  where type.Name == "科幻类"
                  select book
              )
              .Average(book => book.Price);
          double avg4 = (
              from book in books
              join type in types on book.TypeId equals type.ID
              where type.Name == "科幻类"
              select book.Price
          ).Average();
  
          var r9 = 
              from x in a1
              let y = x * x
              where y > 5 
              orderby y
              select y;
  
          var r10 =
              from book in books
              group book by book.TypeId;
  
          var r11 = from a in books
              join b in types on a.TypeId equals b.ID into xxx // into
              from c in xxx
              select c;
  
          int c1 = (from x in a1 where x > 5 select x).Take(3).Count();
  
          foreach (var e in r10)
          {
              Console.WriteLine(e);
          }
      }
  }
#+end_src

** Linq to XML

#+begin_src xml
  <?xml version="1.0" encoding="utf-8"?>
  
  <books>
    <book>
      <name>jQuery</name>
      <price>23</price>
    </book>
    <book>
      <name>VueJS</name>
      <price>123.5</price>
    </book>
    <book>
      <name>CSharp</name>
      <price>26.5</price>
    </book>
    <book>
      <name>Java</name>
      <price>53.5</price>
    </book>
  </books>
#+end_src

#+begin_src csharp
  class Program
  {
      static void Main()
      {
          var xml = XElement.Load(@"e:\ccc.xml");
          string price1 = ((XElement)((XElement) xml.LastNode).LastNode).Value;
  
          var count1 = xml.Elements("book").Count();
  
          var r1 = xml.Elements("book")
              .OrderByDescending(GetBookPrice)
              .Take(2)
              .Select(GetBookPrice)
              .Average();
  
          var r2 = xml.Elements("book").Select(GetBookPrice);
          var r3 = r2.OrderByDescending(x => x).Take(2).Average();
          var r4 = r2.Average();
  
          //Console.WriteLine(r3 - r4);
          //Console.WriteLine(r2.OrderByDescending(x => x).Take(2).Average() - r2.Average());
  
          // Query Expression
  
          var r5 = from book in xml.Elements("book")
                   where GetBookName(book) != "jQuery"
                   orderby GetBookPrice(book)
                   select (GetBookName(book), GetBookPrice(book));
  
          var r6 = (from book in xml.Elements("book")
                    where GetBookName(book) != "jQuery"
                    orderby GetBookPrice(book)
                    select GetBookPrice(book)).Average();
  
          var r7 = from book in xml.Elements("book") where GetBookName(book) != "jQuery" select GetBookPrice(book);
          var r8 = r7.OrderByDescending(x => x).Take(2).Average();
          var r9 = r7.Average();
  
          foreach (var r in r5)
          {
              Console.WriteLine(r);
          }
  
          foreach (var book in XElement.Load(@"e:\ccc.xml").Elements("book"))
          {
              Console.WriteLine(book.Elements("name").First().Value);
          }
          
          (
              from book in XElement.Load(@"e:\ccc.xml").Elements("book")
              let name = GetBookName(book)
              let price = GetBookPrice(book)
              where price > 100 orderby price
              select (name, price)
          ).ToList().ForEach(x => Console.WriteLine($"{x.name} 的价格为 {x.price}"));          
      }
  
      static double GetBookPrice(XElement bookElement)
      {
          return double.Parse(bookElement.Descendants("price").First().Value);
      }
  
      static string GetBookName(XElement bookElement)
      {
          return bookElement.Descendants("name").First().Value;
      }
  }
#+end_src

* 泛型 (Generic)

#+begin_src cs
  class Program
  {
      static void Main()
      {
          var ps = new MyStack();
          ps.Push(new Person());
          ps.Push(2222);
          ps.Push(new Person());
  
          // 不简洁，需要手动转型
          // 不安全
          // 低效率
  
          Person p = (Person)ps.Pop();
          Console.WriteLine(p);
          ((Person)ps.Pop()).Say();
  
  
          // 自然而然的解决方案: 为每种类型创建一个单独的 Stack
  
          var ps2 = new PersonStack();
          ps2.Push(new Person());
          ps2.Push(new Person());
  
          Person p1= ps2.Pop();
          p1.Say();
  
          var ps3 = new StudentStack();
          ps3.Push(new Student());
          ps3.Push(new Student());
  
          Console.WriteLine(ps3.Pop());
  
          // 上述的方案可以解决所有问题，但带来了新的问题: 每次重复定义这些类型很麻烦
          // 那能不能通过某种方法，自动生成这些类型呢
          // CSharp 给出的解决方案是: 泛型
  
          var ps4 = new MyStack<Person>();
          var ps5 = new MyStack<Student>();
          MyStack<int> ps6 = new MyStack<int>();
          var ps7 = new MyStack<double>();
          var ps9 = new MyStack<FileInfo>();
          var ps8 = new MyStack<Stack>();
          var ps0 = new MyStack<bool>();
  
          ps4.Push(new Person());
          ps4.Push(new Person());
          Person p9 = ps4.Pop();
      }
  }
  
  class Person
  {
      public void Say()
      {
          Console.WriteLine("Hello");
      }
  }
  
  class Student
  {
  
  }
  
  class MyStack<X> // 模板
  {
      private int stackTop = 0; // 栈顶
      private X[] _items = new X[200];
  
      public void Push(X w)
      {
          _items[stackTop] = w;
          stackTop = stackTop + 1;
      }
  
      public X Pop()
      {
          stackTop = stackTop - 1;
          return _items[stackTop];
      }
  
      public X Peek()
      {
          return _items[stackTop - 1];
      }
  
      public int Count
      {
          get => stackTop;
      }
  
      public void Clear()
      {
          stackTop = 0;
      }
  }
  
  class PersonStack
  {
      private int stackTop = 0; // 栈顶
      private Person[] _items = new Person[200];
  
      public void Push(Person w)
      {
          _items[stackTop] = w;
          stackTop = stackTop + 1;
      }
  
      public Person Pop()
      {
          stackTop = stackTop - 1;
          return _items[stackTop];
      }
  
      public Person Peek()
      {
          return _items[stackTop - 1];
      }
  
      public int Count
      {
          get => stackTop;
      }
  
      public void Clear()
      {
          stackTop = 0;
      }
  }
  
  class StudentStack
  {
      private int stackTop = 0; // 栈顶
      private Student[] _items = new Student[200];
  
      public void Push(Student w)
      {
          _items[stackTop] = w;
          stackTop = stackTop + 1;
      }
  
      public Student Pop()
      {
          stackTop = stackTop - 1;
          return _items[stackTop];
      }
  
      public Student Peek()
      {
          return _items[stackTop - 1];
      }
  
      public int Count
      {
          get => stackTop;
      }
  
      public void Clear()
      {
          stackTop = 0;
      }
  }
#+end_src

** 方法泛型

#+begin_src csharp
  public static int Count<TSource>(this IEnumerable<TSource> source)
  {
  
  }
#+end_src

* 事件 (Event)

- 不是现在发生的事，而是未来发生的
- 满足某个条件之后，才会发生的
- 满足一定条件时，要执行的代码逻辑
- 比如，你们要毕业，你们要做些什么
- 比如，如果发生火灾，你要做些什么
- 比如，在页面上，用户做了某些动作，会导致执行什么逻辑
- 这种被动式被执行的逻辑，称作事件

每个同学毕业的时候，都有自己的计划。这就是 [毕业事件]:
- 达成的条件是，毕业的日期到了
- 条件达成后，每个同学有不同的计划

** 如果使用一般的写法

每个同学，需要不停判断，毕业的时间有没有达成。如果达成了，就做某件事。反复判断。

自己判断，自己触发:
#+begin_src csharp
  // A 同学
  var t1 = new Thread(() =>
  {
      while (true)
      {
          if (DateTime.Now.Second % 10 == 5)
          {
              Console.WriteLine("继承家产");
          }
          Thread.Sleep(100);
      }
  });
  
  // B 同学
  var t2 = new Thread(() =>
  {
      while (true)
      {
          if (DateTime.Now.Second % 10 == 5)
          {
              Console.WriteLine("回家啃老");
          }
          Thread.Sleep(100);
      }
  });
  
  // C、D、E... 同学都是相似的逻辑
  
  t1.Start();
  t2.Start();
  
  t1.Join();
  t2.Join();
#+end_src

** 上述的写法虽然没有错误，但是存在一些问题

- 逻辑重复严重，冗余很大
- 不停判断条件是否达成的代码过于繁琐，每个同学自己维护这段代码，有些不合理

因此，我们需要 1) 将重复的代码剥离出来 2) 条件的判断只需要交付一个专门的人处理就可以了

专人判断，集中逻辑:
#+begin_src csharp
  var t1 = new Thread(() =>
  {
      while (true)
      {
          if (DateTime.Now.Second % 10 == 5)
          {
              Console.WriteLine("回家继承家产"); // A
              Console.WriteLine("搬砖");        // B
              Console.WriteLine("创业");        // C
              Console.WriteLine("回家啃老");    // D
              Console.WriteLine("结婚");        // E...
          }
          Thread.Sleep(100);
      }
  });
  t1.Start();
  t1.Join();
#+end_src

** 上述代码虽然简洁了，但是条件和最后要执行的逻辑写在一起，耦合度太大

因此，我们需要一种方式，将它们分开。这时候我们想到，委托是实现逻辑分离最佳的工具。

专人判断，分离目标:
#+begin_src csharp
  var BiYe = new Action(() => { });
  
  // 专门负责判断条件是否达成 (发布事件的 Publisher)
  var t1 = new Thread(() =>
  {
      while (true)
      {
          if (DateTime.Now.Second % 10 == 5)
          {
              BiYe();
          }
          Thread.Sleep(100);
      }
  });
  
  // 只需要向相应委托内添加自己的计划辑 (订阅上述事件 Subcriber)
  BiYe += () => Console.WriteLine("搬砖");
  BiYe += () => Console.WriteLine("结婚");
  BiYe += () => Console.WriteLine("啃老");
  
  t1.Start();
  t1.Join();
#+end_src

** 接下来，可以将第一段代码单独抽出来，作为单独的 Publisher，从而实现更好的分离

#+begin_src csharp
  // 事件的发布者，暴露了一个叫 BiYe 的事件
  public class Teacher
  {
      public Action BiYe;
  
      public void Start()
      {
          var t1 = new Thread(() =>
          {
              while (true)
              {
                  if (DateTime.Now.Second % 10 == 5)
                  {
                      BiYe();
                  }
                  Thread.Sleep(100);
              }
          });
          t1.Start();
      }
  }
  
  // 使用者，只需要订阅，完全不需要关心发布者是怎么实现的内在逻辑
  // 完美的解耦合 (分离)
  var t = new Teacher();
  t.BiYe += (s, e) => Console.WriteLine("回家吃饭");
  t.BiYe += (s, e) => Console.WriteLine("回家抱娃");
  t.Start();
#+end_src

** 通过上述实现，我们可以看到事件是通过委托实现的，但还是有些缺点

- Action 等名字不够直观，没法做到望文生义
- 按道理，订阅者没有权力在外部去操作 BiYe 的执行。但现在的权限控制完全做不到这样的限制

因此，C# 提供了标准的 event 关键词和 EventHandler 委托，解决上述痛点:
#+begin_src csharp
  public class Teacher
  {
      public event EventHandler BiYe;
    
      public void Start()
      {
          var t1 = new Thread(() =>
          {
              while (true)
              {
                  if (DateTime.Now.Second % 10 == 5)
                  {
                      BiYe.Invoke(null, null);
                  }
                  Thread.Sleep(100);
              }
          });
          t1.Start();
      }
  }
#+end_src

上述的事件声明，可以扩展为属性:
#+begin_src csharp
  private EventHandler _biye;
  
  public event EventHandler BiYe;
  {
      add
      {
          Console.WriteLine("可以添加更多自己的逻辑");
          _biye += value;
      }
      remove
      {
          _biye -= value;  
      }
  }
#+end_src

** 接下来，要考虑的是，能不能在事件触发的时候，传递一些参数

EventHandler 两个参数:
- object sender，用来表示谁是订阅者
- EventArgs args，用来传递一些参数

#+begin_src csharp
  public class Teacher
  {
      public event EventHandler BiYe;
  
      public void Start()
      {
          var t1 = new Thread(() =>
          {
              while (true)
              {
                  if (DateTime.Now.Second % 10 == 5)
                  {
                      // BiYe(this, new MyEventArgs(5));
                      BiYe.Invoke(this, new MyEventArgs(5));
                  }
                  Thread.Sleep(100);
              }
          });
          t1.Start();
      }
  }
  
  public class MyEventArgs : EventArgs
  {
      public MyEventArgs(int canshu)
      {
          Canshu = canshu;
      }
  
      public int Canshu { get; }
  }
#+end_src

* 异常 (Exception)
** 传统方式

#+begin_src csharp
  // 不够直观，啥是 int，分别有啥含义
  // 代码变啰嗦了，不简洁了
  // 编码难度变大了，错误的处理，干扰主干逻辑
  // 调用这需要知道定义者，每个错误逻辑的含义
  // 错误的处理，不是强制性的，所以容易隐藏 BUG，很难排查
  static int Kuaijiang (string gender)
  {
      if (gender == "男")
      {
          Console.WriteLine("你真帅!");
          return 0;
      }
      if (gender == "女")
      {
          Console.WriteLine("能加你微信吗?");
          return 0;
      }
  
      return 111;
  }
#+end_src

** 通过 Exception 提供 *解耦合* 的处理方式

#+begin_src csharp
  class Program
  {
      static void Main(string[] args)
      {
          try
          {
              Kuaijiang("女孩儿");
          }
          catch(GenderTooLongException ex)
          {
              Console.WriteLine("怎么搞的，这都能错？" + ex.Message);
          }
          catch (Exception ex)
          {
              Console.WriteLine("调用失败: " + ex.Message);
          }
  
          Console.WriteLine("做其他事情");
      }
  
      static void Kuaijiang (string gender)
      {
          if (gender.Length > 2)
          {
              throw new GenderTooLongException("性别怎么可能大约2?");
          }
          if (gender != "男" && gender != "女")
          {
              Exception ex = new Exception("性别错误");
              throw ex;
          }
  
          if (gender == "男")
          {
              Console.WriteLine("你真帅!");
          }
          if (gender == "女")
          {
              Console.WriteLine("能加你微信吗?");
          }
      }
  }
  class GenderTooLongException : Exception
  {
      public GenderTooLongException(string message) : base(message)
      {
      }
  }
#+end_src

** 异常的嵌套，以及 finally

#+begin_src csharp
  using System;
  using System.Collections.Generic;
  using System.IO;
  
  namespace SampleOfException1
  {
      class Program
      {
          static List<string> validGenders = new() { "男", "女" };
  
          static void Main(string[] args)
          {
              try
              {
                  夸奖("女孩儿");
                  Console.WriteLine("1111");
                  return;
              }
              catch(GenderTooLongException ex)
              {
                  try
                  {
                      Console.WriteLine("怎么搞的，这都能错？" + ex.Message);
                      Console.WriteLine("22222");
                      return;
                  }
                  catch
                  {
                      Console.WriteLine("4444");
                  }
                  finally
                  {
                      Console.WriteLine("666");
                  }
              }
              catch (Exception ex)
              {
                  Console.WriteLine("调用失败: " + ex.Message);
                  Console.WriteLine("555");
              }
              finally
              {
                  Console.WriteLine("3333");
              }
  
              //try
              //{
              //    Kuaijiang("女2");
              //}
              //catch
              //{
  
              //}
          }
  
          static void 夸奖 (string  gender)
          {
              try
              {
                  Kuaijiang(gender);
              }
              catch
              {
                  Console.WriteLine("[爸爸] 哈哈，出错了吧");
                  throw;
              }
              finally
              {
                  Console.WriteLine("[爸爸] 我处理完了!");
              }
          }
  
          static void Kuaijiang (string gender)
          {
              if (gender.Length > 2)
                  throw new GenderTooLongException("性别怎么可能大约2?");
  
              if (!validGenders.Contains(gender))
                  throw new Exception("性别错误");
  
              if (gender == "男")
              {
                  Console.WriteLine("你真帅!");
              }
              if (gender == "女")
              {
                  Console.WriteLine("能加你微信吗?");
              }
          }
      }
      class GenderTooLongException : Exception
      {
          public GenderTooLongException(string message) : base(message)
          {
          }
      }
  }
#+end_src

* 反射和特性 (Reflection/Attribute)
** 反射 (Reflection)

- 反射就是运行时查看程序集 (Assembly) 元数据 (metadata) 的行为
- 元数据，就是程序集所包含的所有的类型、属性、参数等数据
- C# 通过 ~System.Reflection~ 这个命名空间下的类，给出了反射的实现
- 为了能够实现反射，运行时在运行的时候，会为每一个 Class 创建一个对应的 ~Type~ 类型的对象
  + typeof
  + GetType
  + assembly.GetTypes()
- 类 ~Assembly~ 中提供了加载程序集和操作元数据的相关方法
- 可以通过辅助类 ~Activator~ 快速创建一个实例

正大光明的类型使用方式:
#+begin_src csharp
  class Student {}
  // var typeofStudent = new Type(Student);
  
  var s1 = new Student();
  var s2 = new Student();
  var s3 = new Student();
  var s4 = new Student();
  
  s1.SayHello();
#+end_src

创建 Assembly 的若干方法:
#+begin_src csharp
  var ass1 = Assembly.Load("DAL");
  var ass2 = Assembly.LoadFile(@"e:\Model.dll");
  var ass3 = Assembly.LoadFrom("DAL");
  var ass4 = Assembly.LoadFrom(@"e:\Model.dll");
  var ass5 = Assembly.GetExecutingAssembly();
  
  Type[] types = ass1.GetTypes();
  foreach (var type in types)
  {
      Console.WriteLine($"Class: {type}");
  
      MethodInfo[] methods = type.GetMethods();
      foreach (var m in methods)
      {
          Console.WriteLine(m);
      }
      Console.WriteLine();
      Console.WriteLine();
      Console.WriteLine();
  }
#+end_src

获取 Type 的若干方法:
#+begin_src csharp
  int i = 0;
  Type type1 = i.GetType();
  
  Student s = new Student();
  Type type2 = s.GetType();
  
  Type type3 = typeof(Student);
  
  var ass = Assembly.GetExecutingAssembly();
  Type type4 = ass.GetTypes()[0];
#+end_src

通过反射的方式，动态调用方法的过程:
#+begin_src csharp
  var ass = Assembly.GetExecutingAssembly();
  object o = ass.CreateInstance("SampleOfReflection.X");
  MethodInfo m = o.GetType().GetMethod("SayHello");
  m.Invoke(o, null);
#+end_src

** [例子] ToModelList

版本 1:
#+begin_src csharp
  public static List<T> ToModelList<T>(this DataTable dt)
  {
      return 
          dt.Rows.Cast<DataRow>()
          .Select(r =>
          {
              T t = (T) Activator.CreateInstance(typeof(T));
              foreach (PropertyInfo p in typeof(T).GetProperties())
              {
                  p.SetValue(t, r[p.Name.ToLower()]);
              }
              return t;
          })
          .ToList();
  }
#+end_src

版本 2:
#+begin_src csharp
  public static List<T> ToModelList2<T>(this DataTable dt)
  {
      List<T> lst = (List<T>)Activator
          .CreateInstance(typeof(List<>).MakeGenericType(typeof(T)));
  
      foreach (DataRow r in dt.Rows)
      {
          T t = (T)Activator.CreateInstance(typeof(T));
          foreach (PropertyInfo p in typeof(T).GetProperties())
          {
              p.SetValue(t, r[p.Name.ToLower()]);
          }
          lst.GetType().GetMethod("Add").Invoke(lst, new object[] { t });
      }
  
      return lst;
  }
#+end_src

比较原版:
#+begin_src csharp
  public static List<Group> ToModelList(DataTable dt)
  {
      var list = new List<Group>();
  
      foreach (DataRow r in dt.Rows)
      {
          var g = new Group
          {
              Gno = (int)r["gno"],
              Name = (string)r["name"],
              Cs = (int)r["cs"],
              Fs = (int)r["fs"]
          };
          list.Add(g);
      }
  
      return list;
  }
#+end_src

** 特性 (Attribute)

- 特性是向程序集添加用户自定义元数据的方式
- 基本使用过程: [定义] -- 添加到 [目标 (target)] -- [消费 (consumer)]
- 定义特性，只需要继承 Attribute 即可。类的命名以 Attribute 结尾，如 MyIgnoreAttribute
- 特性的消费，需要使用反射的方式 (type.GetCustomerAttribute)
- 特性只有被消费才具备其存在的意义。其意义是在消费的时候，使用者赋予的
- 特性就像人生，定一个小目标，然后去实现它

*** 特性就是一个普通的类

*最好* 按照一定的命名规范来命名 (当然，你不按照命名规范，也拿你没办法):
#+begin_src csharp  
  class RainAttribute : Attribute {} 
#+end_src

特新本身是没有任何意义的，但是如果我们将其放到其他的地方。
程序在编译运行的过程中，会记录这些特性 (元数据中会保留特性的信息)。
#+begin_src csharp
  [Rain]
  [RainAttribute]
  class Xxx {}  // - Type - 反射 - 额外的信息，这个类上有个 RainAttribute
  
  
  class Yyy
  {
      [Rain]
      void A(){}
  }
#+end_src

*** 通过反射得到它的实例，然后就可以使用了

在使用反射方式，处理相关逻辑的时候，就可以借题发挥、指鹿为马了:
#+begin_src csharp
  var rt = type.GetCustomerAttribute<RainAttribute>();
  // 既然上面有这个，那么的话，说明这个类是不能被...的，能被...的
  
  if (rt) 不实例化;
  if (rt) 实例化的时候，记录日志;
  
  //// 获取方法上面的特性
  var mType = yType.GetMethod("A");
  var rt2 = mType.GetCustomerAttribute<RainAttribute>();
#+end_src

* 依赖注入 (DI/IoC)
** 正常手段

很多时候，创建一个对象，可能并没有你想象的那么简单:
#+begin_src csharp
  // Form1 可能存在大量的“依赖”
  var f = new Form1();
  
  // 为了构造出完整的 Form1，就需要先构造出它所有的以来，以及依赖的依赖
  var sbll = new StudentBLL();
  var sdal = new StudentDAL();
  var dbhelp = new DbHelper();
  var gbll = new GroupBLL();
  var gdal = new GroupDAL();
  sbll.dal = sdal;
  gbll.dal = gdal;
  sdal.dbhelper = dbhelp;
  gdal.dbhelper = dbhelp;
  f.sbll = sbll;
  f.gbll = gbll;
#+end_src

那么本着一个最基本，最朴素的愿望: 简化上述依赖对象的创建。于是就有了 DI 框架。

** DI/IoC

使用一个容器管理所有实例:
- DI: Dependency Injection, 依赖注入
- IoC: Inversion of Control, 控制反转

.NET 上相关的 DI 容器:
- Microsft Dependency Injection (.Net Core Container)
- Autofac
- DryIoc
- Grace
- LightInject
- Lamar
- Stashbox
- Unity

.Net Core Container 的特点:
- 轻量、高效
- 简单、快速
- 支持三种生命周期 (Transient/Singleton/Scope)
- 支持构造器注入 (Constructor Injection)

.Net Core Container 缺失的功能:
- 属性或方法注入 (Property/Method Injection)
- 通过名字注入 (Injection Base on name or key)
- 子容器 (child container)
- 定制生命周期 (custom lifetime)
- 基于规则注册 (Convention-based registration)
- 缺乏 Lazy Initialize 功能

** 基本使用

#+begin_src csharp
  var container = new ServiceCollection()
      .AddSingleton<Dog>()
      .AddSingleton<Cat>()
      .AddSingleton<Teacher>()
      .AddSingleton<Student>()
      .AddSingleton<Pet>()
      .AddTransient<Class>()
      .BuildServiceProvider();
  
  var c1 = container.GetService<Class>(); // ✓
  var c2 = container.GetService<Class>();
  
  c1.Say();
#+end_src

** 三种生命周期

Object Lifetime:
1. Transient, 暂时的
2. Singleton, 单例的，是在第一次 Get 的时候创建的
3. Scope, 基于作用域的，在同一作用域内，是单例的。作用域结束会释放掉

#+begin_src csharp
  ServiceCollection sc = new ServiceCollection();
  sc.AddSingleton<Teacher>();
  sc.AddSingleton(typeof(Student));
  sc.AddTransient<Dog>();
  sc.AddScoped<Cat>();
  ServiceProvider container = sc.BuildServiceProvider();
  
  // Singleton
  Teacher t1 = container.GetService<Teacher>();
  Teacher t2 = container.GetService<Teacher>();
  Console.WriteLine($"t1: {t1}, t2: {t2}, {object.ReferenceEquals(t1, t2)}");
  
  // Transient
  Dog d1 = container.GetService<Dog>();
  Dog d2 = container.GetService<Dog>();
  Console.WriteLine($"d1: {d1}, d2: {d2}, {d1 == d2}");
  
  // Scope
  using (var scope1 = container.CreateScope())
  {
      Cat s1 = scope1.ServiceProvider.GetService<Cat>();
      Console.WriteLine(s1.GetHashCode());
  
      Cat s2 = scope1.ServiceProvider.GetService<Cat>();
      Console.WriteLine(s2.GetHashCode());
  }
  using (var scope2 = container.CreateScope())
  {
      Cat s3 = scope2.ServiceProvider.GetService<Cat>();
      Console.WriteLine(s3.GetHashCode());
  }
  Cat s4 = container.GetService<Cat>();
  Console.WriteLine(s4.GetHashCode());
  Cat s5 = container.GetService<Cat>();
  Console.WriteLine(s5.GetHashCode());
#+end_src

** 高内聚低耦合

面向对象编程的基本方针 *高内聚*，*低耦合* (SOLID):
- 开闭原则 (Open-Close Principle)，对扩展开放，对修改关闭
- 单一职责原则 (Single-Responsibility Principle)，一个类，只干一件事
- 里氏替换原则 (Liskov Substitution Principle)
- 依赖倒置原则 (Dependence Inversion Principle), 程序要依赖于抽象接口，不要依赖于具体实现
- 接口分离原则 (Interface Segregation PrincipleISP)

OCP:
#+begin_src csharp
  class A
  {
      void Greet() { Console.WriteLine("Hello");}
      void GreetJP() { Console.WriteLine("wawawawa");}
  
      void Greet()
      {
          if (...)
              Console.WriteLine();
          else if (...)
              Console.WriteLine();
          else if (...)
              Console.WriteLine();
      }
  }
  
  // round-1
  class As
  {
      static Dictionary<string, string> dics = new();
      static As ()
      {
          dics.Add("jp", "wawawa");
          dics.Add("en", "hello");
      }
  }
  class A2
  {  
      void Greet(string message)
      {
          Console.WriteLine(message);
      }
      void GreetBy(string who)
      {
          string message = As.dics[who];
          Greet(message);
      }
  }
  
  // round-2
  interface IGreeter { void Greet(); }
  class EnglishGreeter : IGreeter
  {
      void Greet()
      {
          Console.WriteLine("hello");
      }
  }
  // new EnglishGreeter().Greet();
  class JPGreeter : IGreeter
  {
      void Greet()
      {
          Console.WriteLine("baga");
      }
  }
  // new JPGreeter().Greet();
#+end_src

LSP:
#+begin_src csharp
  class Banji161
  {
      Yanjiusheng xxx;
      public Banji161(Yanjiusheng x) => xxx = x; // 需要模糊化
  
      void Teach()
      {
          xxx.Teach();
      }
  }
  // new Banji161(xx).Teach();
  
  interface ITeachable { void Teach(); }
  class Yanjiusheng : ITeachable { void Teach() {...}; }
  class Banji161
  {
      ITeachable xxx;
      public Banji161(ITeachable x) => xxx = x;
  
      void Teach()
      {
          xxx.Teach();
      }
  }
  // new Banji161(new Yanjiusheng()).Teach();
  class Boshisheng : ITeachable { void Teach() {...}; }
  // new Banji161(new Boshisheng()).Teach();
#+end_src

* 异步编程
** Process

- 点击打开程序，会自动创建进程
- 通过代码的形式，创建进行

#+begin_src csharp
  Process np = Process.Start("notepad.exe");
  
  np.Kill();
  np.CloseMainWindow();
#+end_src

** Thread

C# 1.0 中加入的。

基本语法:
#+begin_src csharp
  Thread t = new Thread(() =>
  {
      Console.WriteLine("hello");
  });
  t.Start();
  Console.WriteLine("world");
  
  Thread tc = Thread.CurrentThread;
  Console.WriteLine($"{t.ManagedThreadId} / {t.Name} / {t.IsAlive} / {t.IsBackground}");
  Console.WriteLine($"{tc.ManagedThreadId} / {tc.Name} / {tc.IsAlive} / {tc.IsBackground}");
#+end_src

例子:
#+begin_src csharp
  Thread t = new Thread(() =>
  {
      for (int i = 0; i < 10000; i++)
      {
          Console.Write("-");
      }
  });
  t.Start();
  for (int i = 0; i < 10000; i++)
  {
      Console.Write("+");
  }
  
  Console.WriteLine();
#+end_src

线程之间可以共享数据:
#+begin_src csharp
  static void Main(string[] args)
  {
      bool isFinished = false;
  
      Thread t1 = new Thread(() =>
      {
          while (!isFinished) { }
  
          for (int i = 0; i < 10000; i++)
          {
              Console.Write("-");
          }
      });
  
      Thread t2 = new Thread(() =>
      {
          for (int i = 0; i < 10000; i++)
          {
              Console.Write("*");
          }
          isFinished = true;
      });
  
      t1.Start();
      t2.Start();
  
      for (int i = 0; i < 10000; i++)
      {
          Console.Write("+");
      }
  
      Console.WriteLine();
  }
#+end_src

线程是不是一定能让任务变快:
#+begin_src csharp
  Stopwatch sw = new Stopwatch();
  sw.Start();
  for (int i = 0; i < 100000000; i++)
  {
      int j = 111110;
      Math.Pow(j, j);
  }
  Console.WriteLine(sw.Elapsed);
    
  
  Stopwatch sw = new Stopwatch();
  sw.Start();
  Thread[] ts = new Thread[10000000];
  for (int i = 0; i < 10000000; i++)
  {
      var t = new Thread(() =>
      {
          for (int i = 0; i < 10; i++)
          {
              int j = 111110;
              Math.Pow(j, j);
          }
      });
      ts[i] = t;
      t.Start();
  }
  foreach (var t in ts) t.Join();
  Console.WriteLine(sw.Elapsed);
#+end_src

创建很多线程：
#+begin_src csharp
  for (int i = 0; i < 1000000; i++)
  {
      var t = new Thread(() =>
      {
          Thread.Sleep(2222222);
      });
      t.Start();
  }
  Console.WriteLine("...");
#+end_src

** ThreadPool

C# 2.0 出现线程池。(IoC/DI)

#+begin_src csharp
  ThreadPool.QueueUserWorkItem(() =>
  {
      Console.WriteLine("hello");
  });
  
  Console.WriteLine("world");
#+end_src

** TPL (Task-Parallel Libary)

C# 3/4 版本中，出现了更高一层的抽象:
- Thread 是一种昂贵的资源，创建和销毁和维护需要时间，而且需要空间 (1M)
- 因此，充分利用 Thread 的方式，就是创建一个 Pool 来反复使用
- 但是通过 Pool 的方式，不能够充分屏蔽线程的操作细节，但是 Pool 提供的 API 过于简陋
- 因此，通过进一步抽象，使用 Task 概念来暴露线程需要完成的工作。
  Task 交给背后的 Pool 之后，通过一定的线程调度机制，会使用 Pool 提供的某个线程，
  去执行 Task 中的逻辑。
- Task 对象用来表示包含了异步逻辑，以及异步的执行结果的对象。Task 可以组合。
  我们可以将大任务，分成若干小任务，小任务完成之后组合成大任务。

*** Task.Run

基本使用:
#+begin_src csharp
  Task t = Task.Run(() =>
  {
      for (int i = 0; i < 10000; i++)
      {
          Console.Write("-");
      }
  });
  
  //Task.WaitAll(t1, t2);
  //Task.WaitAny(t1, t2);
  //t1.Wait(); // 阻塞当前线程
  
  for (int i = 0; i < 10000; i++)
  {
      Console.Write("+");
  }
#+end_src

带返回值的使用:
#+begin_src csharp
  // Promise Style
  Task<string> t = Task.Run(() =>
  {
      StringBuilder sb = new StringBuilder();
      for (int i = 0; i < 10000; i++)
      {
          sb.Append("-");
      }
      return Task.FromResult(sb.ToString());
  });
  
  Console.WriteLine(t.Result); // 等待任务完成，阻塞当前
  
  for (int i = 0; i < 10000; i++)
  {
      Console.Write("+");
  }
#+end_src

简化:
#+begin_src csharp
  Task<string> t = Task.Run(() =>
  {
      var sb = new StringBuilder();
      for (int i = 0; i < 10000; i++)
      {
          sb.Append("-");
      }
      return sb.ToString(); // this one
  });
  
  for (int i = 0; i < 10000; i++)
  {
      Console.Write("+");
  }
  
  Console.WriteLine(t.Result); // 等待任务完成，阻塞当前
#+end_src

带 CancellationToken 的 Task.Run:
#+begin_src csharp
  var cts = new CancellationTokenSource();
  cts.CancelAfter(1000);
  cts.Token.Register(() => Console.WriteLine("jieshule"));
  
  Task t = Task.Run(() =>
  {
      // Task t = Task.Run(() =>
      // {
      //     for (int i = 0; i < 10000; i++)
      //     {
      //         cts.Token.ThrowIfCancellationRequested();
      //         Console.Write("O");
      //     }
      // }, cts.Token);
  
      var i = 0;
      //while (!cts.Token.IsCancellationRequested && i++ < 10000)
      //{ 
      //    Console.Write("O");
      //}
      
      do
      {
          cts.Token.ThrowIfCancellationRequested();
          Console.Write("O");
      } while (i++ < 1000);
  }, cts.Token);
  
  for (int i = 0; i < 10000; i++)
  {
      if (i == 5)
      {
          cts.Cancel();
      }
      Console.Write("+");
  }
#+end_src

*** 其他创建任务的方式

#+begin_src csharp
  Task t = new TaskFactory().StartNew(() =>
  {
      for (int i = 0; i < 10000; i++)
      {
          Console.Write("-");
      }
  });
  
  for (int i = 0; i < 10000; i++)
  {
      Console.Write("+");
  }
#+end_src

#+begin_src csharp
  Task t = new Task(() =>
  {
      for (int i = 0; i < 10000; i++)
      {
          Console.Write("-");
      }
  }, TaskCreationOptions.LongRunning);
  t.Start();
#+end_src

#+begin_src csharp
  Task t = Task.Run(() =>
  {
      for (int i = 0; i < 10000; i++)
      {
          Console.Write("-");
      }
      Task.Run(() =>
      {
          Console.Write("%");
          Task.Run(() =>
          {
              Console.Write("$");
          });
      });
  });
#+end_src

*** 任务协作

#+begin_src csharp
  Task t1 = Task.Run(() =>
  {
      Console.WriteLine("拿扫把");
      Task t2 = Task.Run(() =>
      {
          Console.WriteLine("扫地");
          Task t3 = Task.Run(() =>
          {
              Console.WriteLine("集合");
              Task t4 = Task.Run(() =>
              {
                  Console.WriteLine("吃饭");
              });
          });
      });
  });
  t1.Wait();
#+end_src

使用 ContinueWith 简化:
#+begin_src csharp
  Task.Run(() =>
  {
      Console.WriteLine("拿扫把");
  }).ContinueWith((s) =>
  {
      Console.WriteLine("扫地");
  }).ContinueWith((s) =>
  {
      Console.WriteLine("集合");
  }).ContinueWith((s) =>
  {
      Console.WriteLine("吃饭");
  }).Wait();
#+end_src

** TAL (Task-based Asyncronize Pattern)

C# 5 中，出现了 async/await 关键词:
- *异步方法*，需要使用 ~async~ 来修饰
  + 返回值必须是 Task 或者 Task<T> (有些情况下可以返回 void),
  + 参数不能是 ref/out 类型,
  + 方法名，按照约定，最好是以 Async 结尾
- ~await~ 关键词，只能用于 async 修饰的方法内:
  + await 关键词后面跟着的是 awaitable 类型 (实现了 GetAwaiter 方法的类型) 的对象
  + 我们一般来说，没有必要手动创建 awaitable 对象，而是直接使用 Task
  + await 会检查后面的 awaitable 对象的状态:
    * 如果它已经完成，那么拿到返回结果之后继续
    * 如果没有完成，将当前异步方法 *挂起*，然后返回调用这个异步方法的方法继续执行。
      如果后续 awaitable 状态变更为完成的话，异步方法将会被 *恢复*，并继续执行接下来的逻辑
- 异步方法的调用，本身不会创建任何线程的


#+begin_src csharp
  static async Task<int> GetUrlContentLengthAsync()
  {
      var client = new HttpClient();
  
      Task<string> getStringTask =
          client.GetStringAsync("https://docs.microsoft.com/dotnet");
  
      DoIndependentWork();
  
      string contents = await getStringTask; // 魔法之源。如果任务没结束，把方法挂起来
  
      string cbaidu = await client.GetStringAsync("https://www.baidu.com");
      Console.WriteLine($"百度的访问结束: {cbaidu.Length}");
  
      string cbing = await client.GetStringAsync("https://bing.com");
      Console.WriteLine($"bing的访问结束: {cbing.Length}");
  
      Console.WriteLine("Finished.");
  
      return contents.Length;
  }
  
  static async Task Main()
  {
      Console.WriteLine("111");
      Task<int> t = GetUrlContentLengthAsync();
      Console.WriteLine("222");
      Console.WriteLine(await t); // Console.WriteLine(t.Result);
  }
#+end_src  

** Parallel

#+begin_src csharp
  //for (int i = 0; i < 1000; i++)
  //{
  //    Console.WriteLine(i);
  //}
  
  //Task.WaitAll(
  //    Enumerable.Range(0, 1000)
  //        .Select(n => Task.Run(() => Console.WriteLine(n)))
  //        .ToArray()
  //        );
  
  //Parallel.For(0, 1000, (n) =>
  //{
  //    Console.WriteLine(n);
  //});
  
  List<int> numbers = Enumerable.Range(0, 1000).ToList();
  //foreach (var n in numbers) Console.WriteLine(n);
  //Parallel.ForEach(numbers, (n) => Console.WriteLine(n));
  
  Parallel.Invoke(
      () =>
      {
          double ii = 0;
          for (int i = 0; i < 100000; i++)
          {
              Task.Delay(10).Wait();
              ii += Math.Pow(i, new Random().Next(50));
          }
          Console.WriteLine($"{Task.CurrentId} 计算完毕: {ii}");
      },
      () =>
      {
          for (int i = 0; i < 100000; i++)
          {
              Task.Delay(10).Wait();
              double ii = Math.Pow(i, i * i + 3) - 1000;
          }
          Console.WriteLine($"{Task.CurrentId} 计算完毕");
      },
      () =>
      {
          for (int i = 0; i < 100000; i++)
          {
              Task.Delay(10).Wait();
              double ii = Math.Pow(i, i * i) / 3;
          }
          Console.WriteLine($"{Task.CurrentId} 计算完毕");
      });
#+end_src

** 任务的同步和协作
*** Monitor.Enter/Exit

锁的基本使用:
#+begin_src csharp
  // 1. 创建锁
  object o = new object(); // 将其当成一把锁，最好就是 object。尤其不要使用 this
  
  Task.Run(xxx);
  Task.Run(xxx);
  
  void xxx()
  {
      // 2. 抢夺锁
      Monitor.Enter(o); // 如果抢不到，那么等 (阻塞)
  
      // 3. 执行关键代码
      Console.WriteLine("执行关键区域的代码");
  
      // 4. 释放锁
      Monitor.Exit(o);          
  }
#+end_src

更加健壮一点的写法:
#+begin_src csharp
  // 1. 创建锁
  object o = new object(); // 将其当成一把锁，最好就是 object。尤其不要使用 this
  
  Task.Run(xxx);
  Task.Run(xxx);
  
  void xxx()
  {
      // 2. 抢夺锁
      Monitor.Enter(o); // 如果抢不到，那么等 (阻塞)
  
      try
      {
          // 3. 执行关键代码
          Console.WriteLine("执行关键区域的代码");
      }
      finally
      {
          // 4. 释放锁
          Monitor.Exit(o);
      }
  }
#+end_src

我不想等 (我只能等若干时间):
#+begin_src csharp
  // 1. 创建锁
  object o = new object();
  
  Task.Run(xxx);
  Task.Run(xxx);
  
  void xxx()
  {
      // 2. 抢夺锁
      bool isTaken = Monitor.TryEnter(o); // 我等不到，就拉倒 (非阻塞)
      bool isTaken = Monitor.TryEnter(o, 666); // 我只能等这么久
  
      // 3. 判断有没有拿到锁
      if (isTaken)
      {
          try
          {
              // 4. 执行关键代码
              Console.WriteLine("执行关键区域的代码");
          }
          finally
          {
              // 5. 释放锁
              Monitor.Exit(o);          
          }
      }
  }
#+end_src

另外，一定要避免死锁的产生:
#+begin_src csharp
  object lock1 = new();
  object lock2 = new();
  
  Task t1 = Task.Run(() =>
  {
      Monitor.Enter(lock1);
      Console.WriteLine("开始");
      Task.Delay(2000).Wait();
      Console.WriteLine("结束");
  
      Monitor.Enter(lock2);
      Console.WriteLine("其他事情");
      Monitor.Exit(lock2);
  
      Monitor.Exit(lock1);
  });
  
  Task t2 = Task.Run(() =>
  {
      Monitor.Enter(lock2);
      Console.WriteLine("My...");
  
      Monitor.Enter(lock1);
      Console.WriteLine("start");
      Task.Delay(1500).Wait();
      Console.WriteLine("end");
      Monitor.Exit(lock1);
  
      Monitor.Exit(lock2);
  });
  
  Task.WaitAll(t1, t2);
  Console.WriteLine("好了");
#+end_src

*** lock

是 Monitor 语法糖。胜在简单，败在不够灵活:
- lock 的行为是，如果获取不到锁，就等待
- 锁的争用会占用资源，拖慢速度
- 因此，一定要控制好锁的范围 (颗粒)

#+begin_src csharp
  object o = new ();
  
  void xxx()
  {
      lock(o) // 等待
      {
          Console.WriteLine("我是关键区域");
      }
  }
#+end_src

*** ManualResetEventSlim

多任务的简单协同。事件机制。

#+begin_src csharp
  var ev1 = new ManualResetEventSlim();
  var ev2 = new ManualResetEventSlim();
  
  Task t1 = Task.Run(() =>
  {
      Console.WriteLine("我来到教室");
      ev2.Wait();
      Console.WriteLine("我开始讲课");
      ev1.Set();
  });
  Task t2 = Task.Run(() =>
  {
      Console.WriteLine("你们来到教室");
      ev2.Set();
      ev1.Wait();
      Console.WriteLine("你们开始听课");
  });
  
  Task.WaitAll(t1, t2);
  Console.WriteLine("下课");
#+end_src

*** Interlock

即使 i++ 这样的代码，在 CPU 的角度，也不是原子性的 (从内存中拿取、计算、写入到内存):
#+begin_src csharp
  int money = 1000000;
  
  Task t1 = Task.Run(() =>
  {
      for (int i = 0; i < 100000; i++)
      {
          money++;
      }
  });
  Task t2 = Task.Run(() =>
  {
      for (int i = 0; i < 100000; i++)
      {
          money--;
      }
  });
  Task.WaitAll(t1, t2);
  Console.WriteLine($"现在我有钱: {money}");
#+end_src

遇到资源争用出现的问题，基本思路就是上锁:
#+begin_src csharp
  object _lock = new();
  int money = 1000000;
  
  Task t1 = Task.Run(() =>
  {
      for (int i = 0; i < 100000; i++)
      {
          lock (_lock)
          {
              money++;
          }
      }
  });
  Task t2 = Task.Run(() =>
  {
      for (int i = 0; i < 100000; i++)
      {
          lock(_lock)
          {
              money--;
          }
      }
  });
  
  Task.WaitAll(t1, t2);
  Console.WriteLine($"现在我有钱: {money}");
#+end_src

我们可以使用 Interlock 保证线程安全，它比使用上锁的方式，更快、更简单:
#+begin_src csharp
  object _lock = new();
  int money = 1000000000;
  
  Task t1 = Task.Run(() =>
  {
      for (int i = 0; i < 100000000; i++)
      {
          Interlocked.Increment(ref money);
      }
  });
  Task t2 = Task.Run(() =>
  {
      for (int i = 0; i < 100000000; i++)
      {
          Interlocked.Decrement(ref money);
      }
  });
  
  Task.WaitAll(t1, t2);
  Console.WriteLine($"现在我有钱: {money}");
#+end_src

*** Semaphore

可以看作是 Monitor 方式的增强版。可以控制同一时刻通过核心代码区域的任务数量:
#+begin_src csharp
  Semaphore sem = new Semaphore(3, 3);
  
  var random = new Random();
  void DoSomething(int n)
  {
      while (true)
      {
          if (sem.WaitOne(1000))
          {
              Console.WriteLine($"{n}: --- 恭喜我成功拿锁 :)");
              Console.WriteLine($"{n}: 我开始做事咯");
              Task.Delay(random.Next(2000) + 1000).Wait(); // 模拟做了点事
              Console.WriteLine($"{n}: 我做完咯");
              sem.Release();
              break;
          }
          else
          {
              Console.WriteLine($"{n}: --- 我拿锁失败了 :(");
          }
      }
  };
  
  //List<Task> tasks = new();
  //for (int i = 0; i < 10; i++)
  //{
  //    var task = Task.Run(() => DoSomething(i));
  //    tasks.Add(task);
  //}
  
  var tasks = Enumerable.Range(0, 10)
      .Select(n => Task.Run(() => DoSomething(n)));
  Task.WaitAll(tasks.ToArray());
#+end_src


*** CountdownEvent

看作是 ManualResetEventSlim 的增强版。

集齐 7 颗龙珠，召唤神龙:
#+begin_src csharp
  var cde = new CountdownEvent(7);
  
  var random = new Random();
  void SeekLongZhu()
  {
      Console.WriteLine($"{Task.CurrentId} 开始寻找...");
      while (cde.CurrentCount > 0)
      {
          Task.Delay(200).Wait();
          if (random.Next(100) == 0)
          {
              cde.Signal();
              Console.WriteLine($"{Task.CurrentId} 找到一颗龙珠");
          }
      }
  }
  
  var tasks = Enumerable.Range(0, 10)
      .Select(n => Task.Run(SeekLongZhu));
  
  Task.WaitAll(tasks.ToArray());
  
  cde.Wait();
  Console.WriteLine("七颗龙珠集齐，开始召唤神龙");
#+end_src

** 其他几种异步模式
*** BackgroundWorker

#+begin_src csharp
  //button1.Click += (s, e) =>
  //{
  //    label111.Text = "任务进行中...";
  //    Thread.Sleep(10000);
  //    label111.Text = "任务已完成!";
  //};
  
  //button1.Click += (s, e) =>
  //{
  //    label111.Text = "任务进行中...";
  //    Task.Run(() =>
  //    {
  //        Thread.Sleep(10000);
  //        label111.Text = "任务已完成!";
  //    });
  //};
  
  button1.Click += (s, e) =>
  {
      var bgw = new BackgroundWorker();
      bgw.DoWork += (s, e) =>
      {
          label111.Text = "任务进行中...";
          Thread.Sleep(10000);
      };
      bgw.RunWorkerCompleted += (s, e) =>
      {
          label111.Text = "任务已完成!";
      };
      bgw.RunWorkerAsync();
  };
#+end_src

*** System.Threading.Timer

#+begin_src csharp
  button1.Click += (s, e) =>
  {
      var timer = new System.Threading.Timer((o) =>
      {
          label111.Text += "+";
          Thread.Sleep(1000);
      }, null, 5000, 2000);
  };
#+end_src

对比一下 Winform 版本的 Timer，它是局部阻塞:
#+begin_src csharp
  var timer = new System.Windows.Forms.Timer();
  timer.Interval = 3000;
  timer.Tick += (s, e) =>
  {
      label111.Text += "+";
      Thread.Sleep(2000); // 在当前线程中，堵
  };
  button1.Click += (s, e) =>
  {
      timer.Start();
  };
#+end_src

* IO/Stream

驱动器、文件夹、文件的基本操作:
- 静态的 ~Path~ 类，用来处理路径 (路径是一个字符串)
- 处理驱动器，使用 ~DriveInfo~
- 处理文件夹和文件，使用 ~FileSystemInfo~ (抽象类)，实现类:
  + 文件夹，使用 ~DirectoryInfo~。静态的 ~Directory~
  + 文件，使用 ~FileInfo~。静态的 ~File~

文件内容的读写 (Stream):
- 抽象的 ~Stream~ 表示流，它是所有底层流的基类 (基于 byte)
- ~FileStream~ 用来读写文件的内容
- ~MemoryStream~ 用来将某些内容按照流的方式写到内存中 (从内存中读取)
- ~NetworkStream~ 从网络中进行读写
- ~GZipStream~ 用来进行压缩、解压的

通过不同的跟读写相关的辅助类 (Reader/Writer) 简化了对上述流的使用:
- 抽象 ~TextReader/TextWriter~，表示从流中读取若干字符 (基于 char)
  + ~StreamReader/StreamWriter~ 用来包装底层流，增加基于字符读取的能力
  + ~StringReader/StringWriter~ 用来从字符串中读写
- ~BinaryReader/BinaryWriter~ 用来读写现成的类型
- ~XmlReader/XmlWriter~ 专门用来处理 xml 文件

其他的一些流跟相关的类:
- ~ZipArchive/DeflateStream~
- ~MemoryMappedFiles~
- ~Pipes~ 管道流

** Path

#+begin_src csharp
  string fn = @"E:\Workdir\Chengji\Chengji\Program.cs";
  var s1 = Path.ChangeExtension(fn, "java");
  
  string d1 = @"E:\ddd\";
              string n1 = @"aaa.txt";
  var s2 = Path.Combine(d1, n1);
  
  bool b1 = Path.EndsInDirectorySeparator(d1);
  
  var s3 = Path.GetDirectoryName(fn);
  var s4 = Path.GetExtension(fn);
  var s5 = Path.GetFileName(fn);
  var s6 = Path.GetFileNameWithoutExtension(fn);
  
  var s7 = Path.GetFullPath("xxx.txt");
  var s8 = Path.GetFullPath(fn);
  var s9 = Path.GetRandomFileName();
  
  Console.WriteLine($"{s9}");
#+end_src

** Driver

#+begin_src csharp
  DriveInfo[] drives = DriveInfo.GetDrives();
  foreach (DriveInfo di in drives)
  {
      try
      {
          Console.WriteLine($"{di.Name}, {di.DriveType}, {di.DriveFormat}, {di.TotalSize}, {di.AvailableFreeSpace}");
      }
      catch { }
  }
#+end_src

** Directory

#+begin_src csharp
  var d1 = @"e:\demo1\hello";
  var d2 = @"e:\demo1\world";
  
  Directory.CreateDirectory(d1);
  Directory.CreateDirectory(d2);
  
  //Directory.Delete(Directory.GetParent(d).FullName);
  //Directory.Delete(Directory.GetParent(d).FullName, true);
  //Directory.Move(d2, d1);
  
  foreach (var f in Directory.GetDirectories(@"e:\Workdir"))
  {
      Console.WriteLine(f);
  }
  
  foreach (var f in Directory.GetFiles(@"e:\Workdir"))
  {
      Console.WriteLine(f);
  }
  
  IEnumerable<string> e1 = Directory.EnumerateFiles(d2);
  
  var s1 = Directory.GetCreationTime(d1);
  var s2 = Directory.GetCurrentDirectory();
  
  var b1 = Directory.Exists(d2);
  Directory.SetCreationTime(@"e:\Video", DateTime.Now);
  
  Console.WriteLine(s2);
#+end_src

** File

#+begin_src csharp
  string fn = @"E:\Workdir\Chengji\Chengji\Program.cs";
  
  //File.Exists(fn);
  //File.Delete(fn);
  //File.Move(fn, "xxx");
  //File.Copy(fn, "xxx");
  //File.Encrypt(fn);
  //File.Decrypt(fn);
  
  File.GetCreationTime(fn);
  Console.WriteLine(File.GetAttributes(fn));
#+end_src

** Stream
*** FileSteam

用完要释放; 使用 ReadByte 读取一个字节:
#+begin_src csharp
  string fn = @"E:\Workdir\Chengji\Chengji\Program.cs";
  
  FileStream stream = new FileStream(fn, FileMode.Open);
  
  Console.WriteLine($"{stream.CanRead}, {stream.CanWrite}");
  
  for (int i = 0; i < 10; i++)
  {
      var b = stream.ReadByte();
      Console.Write($"{b:x}");
  }
  Console.WriteLine();
  
  stream.Seek(5, SeekOrigin.Begin);
  Console.WriteLine($"{stream.ReadByte():x}");
  
  stream.Dispose();
#+end_src

使用 using 管理资源 / 使用 Read 进行批量读取:
#+begin_src csharp
  string fn = @"E:\Workdir\Chengji\Chengji\Program.cs";
  using (var stream = new FileStream(fn, FileMode.Open))
  {
      // byte[] bs = stream.Read(10);
  
      byte[] buf = new byte[10];
      int n = stream.Read(buf, 0, 10);
      Console.WriteLine($"读取成功了 {n} 个");
      for (int i = 0; i < n; i++)
      {
          Console.Write($"{buf[i]:x}-");
      }
  } 
#+end_src

全文读取:
#+begin_src csharp
  string fn = @"E:\Workdir\Chengji\Chengji\Program.cs";
  using var stream = new FileStream(fn, FileMode.Open);
  
  int n;
  byte[] buf = new byte[10]; // 缓冲数组
  while ((n = stream.Read(buf)) > 0)
  {
      PrintBuffer(buf, n);
  }
  
  private static void PrintBuffer(byte[] buf, int limit)
  {
      for (int i = 0; i < limit; i++)
      {
          Console.Write($"{buf[i]:x}-");
      }
  }
#+end_src

异步读取:
#+begin_src csharp
  string fn = @"E:\Workdir\Chengji\Chengji\Program.cs";
  using var stream = new FileStream(fn, FileMode.Open);
  
  int n;
  byte[] buf = new byte[1000000];
  int len = await stream.ReadAsync(buf);
#+end_src

写:
#+begin_src csharp
  string fn = @"E:\Workdir\Chengji\Chengji\Program.cs";
  using var stream = new FileStream(fn, FileMode.Open);
  
  // 最开始的位置
  // 覆盖
  stream.WriteByte(255);
  stream.WriteByte(255);
  stream.WriteByte(255);
  stream.WriteByte(255);
  stream.Flush();

  stream.Seek(100, SeekOrigin.Begin);
  var ba1 = Encoding.UTF8.GetBytes("hello");
  stream.Write(ba1, 0, ba1.Length);
  stream.Flush();
#+end_src

丰富多彩的构造参数:
#+begin_src csharp
  string fn = @"E:\Workdir\Chengji\Chengji\Program222.cs";
  //using var stream = new FileStream(fn, FileMode.OpenOrCreate);
  using var stream = new FileStream(fn,
                                    FileMode.OpenOrCreate,
                                    FileAccess.Write,
                                    FileShare.ReadWrite,
                                    200,
                                    FileOptions.DeleteOnClose);
  
  stream.WriteByte(255);
  stream.WriteByte(0x65);
#+end_src

在 File 中存在若干创建流的快捷方式:
#+begin_src csharp
  string fn = @"E:\Workdir\Chengji\Chengji\Program222.cs";
  //using var stream = new FileStream(fn, FileMode.Open, FileAccess.Read);
  //using var stream = File.Open(fn, FileMode.Open);
  //using var stream = File.OpenRead(fn);
  using var stream = File.OpenWrite(fn);
#+end_src

*** MemoryStream

#+begin_src csharp
  MemoryStream s = new MemoryStream();
  byte[] bs1 = Encoding.UTF8.GetBytes("中国");
  byte[] bs2 = Encoding.UTF8.GetBytes("yyds");
  s.Write(bs1, 0, bs1.Length);
  s.Write(bs2, 0, bs2.Length);
  s.ToArray();
#+end_src

*** NetworkStream

Socket!!!

** Reader/Writer
*** StreamReader/StreamWriter

#+begin_src csharp
  string fn = @"E:\Workdir\Chengji\Chengji\Program.cs";
  var s = File.OpenRead(fn);
  using var reader = new StreamReader(s);
  
  //Console.WriteLine(reader.ReadLine()); 
  //Console.WriteLine(reader.ReadLine()); 
  
  //reader.Peek();
  
  //Console.WriteLine(reader.ReadToEnd());
  
  reader.Read();
#+end_src

可以直接传入文件名:
#+begin_src csharp
  string fn = @"E:\Workdir\Chengji\Chengji\Program.cs";
  // using var reader = new StreamReader(File.OpenRead(fn));
  using var reader = new StreamReader(fn);
#+end_src

在 File 中提供了大量的快捷使用:
#+begin_src csharp
  string fn = @"E:\Workdir\Chengji\Chengji\Program.cs";
  using StreamReader sr = File.OpenText(fn);
  using StreamWriter sw1 = File.AppendText(fn);
  using StreamWriter sw2 = File.CreateText(fn);
  
  string s1 = File.ReadAllText(fn);
  string[] ar = File.ReadAllLines(fn);
  File.WriteAllText(fn, "dkjskdjfskdfjds");
#+end_src

*** StringReader/StringWriter

使用场景: xxxxx

优势劣势: xxxxx

#+begin_src csharp
  var reader = new StringReader("hello, world");
  //Console.WriteLine(reader.Read());
  //Console.WriteLine(reader.ReadToEnd());
  
  var writer = new StringWriter();
  //writer.WriteLine("hello");
  //writer.WriteLine("world");
  for (int i = 0; i < 1000; i++)
  {
      writer.WriteLine(i);
  }
  Console.WriteLine(writer.ToString());
#+end_src

*** BinaryReader/BinaryWriter

BinaryWriter:
#+begin_src csharp
  string fn = @"E:\x11111.bin";
  var writer = new BinaryWriter(File.OpenWrite(fn));
  writer.Write(123);
  writer.Write(true);
  writer.Write('X');
  writer.Write(33.3);
  writer.Flush();
  return writer;
#+end_src

BinaryReader:
#+begin_src csharp
  string fn = @"E:\x11111.bin";
  var reader = new BinaryReader(File.OpenRead(fn));
  int i = reader.ReadInt32();
  bool b = reader.ReadBoolean();
  char c = reader.ReadChar();
  Console.WriteLine(c);
#+end_src

*** XmlReader/XmlWriter

#+begin_src csharp
  var fn = @"e:\hello.xml";
  using var xw = XmlWriter.Create(File.OpenWrite(fn), new XmlWriterSettings { Indent = true });
  
  List<string> books = new()
  {
      "战争与和平",
      "悲惨的世界",
      "供货商打开",
      "jQuery",
      "Csharp"
  };
  
  xw.WriteStartDocument();
  xw.WriteStartElement("book");
  xw.WriteComment("我也不知道");
  foreach (var book in books)
  {
      xw.WriteElementString("name", book);
  }
  xw.WriteEndElement();
  xw.Flush();
#+end_src

** FileSystemWatching

#+begin_src csharp
  var dn = @"e:\Tmp";
  var watcher = new FileSystemWatcher
  {
      Path = dn,
      IncludeSubdirectories = true,
      EnableRaisingEvents = true
  };
  watcher.Changed += (s, e) =>
  {
      Console.WriteLine($"有东西发生了变化: {e.Name}, {e.ChangeType}");
  };
  watcher.Created += (s, e) =>
  {
      Console.WriteLine("创建了一点什么东西，我也不知都。可能是病毒把...");
  };
  Console.ReadKey();
#+end_src

* Socket
** OSI 模型

- 计算机网络刚起步的阶段，很多私有协议 (Protocol) 先后出现
- 后面 ISO (国际标准组织) 出面推出了 OSI (Open System Interconnection) 协议
  + 分为 7 层，每次都提供单独的服务，层与层之间紧密合作
  + 大而全，从底层的网线接口，到高层的应用协议，无所不包
  + 率先提出了服务、分层、协议、之类的概念

[[file:img/osi-1.png]]

但是:
- 它太复杂了 ([[file:img/tcpip-111.png][大而全的 OSI 模型图片]])
- 到现在为止, Windows 操作系统也没有完全实现 OSI 协议
- 反而在这个过程中，围绕着 TCP 和 IP 这两种协议，衍生出了 TCP/IP Protocol Stack (协议栈) 的概念，并且被广泛使用
- TCP/IP 协议栈慢慢就成为了事实上的标准；但是学习的时候，理论上还是以 OSI 为基准
- TCP/IP 出现在 OSI 模型之前，但是后面 OSI 出现之后，TCP/IP 借鉴了其中很多想法，包括分层
- 正因为如此，OSI 模型，现在变成了 *参考* 模型

** TCP/IP 协议栈


[[file:img/tcpipstack.png]]


[[file:img/tcpip-2222.png]]


[[file:img/tcpip-3332.png]]

** Uri/UriBuilder

URI (Uniform Resource Identifier), 统一资源标识符:
- url: Uniform Resource Locator, 统一资源定位器
- urn: Uniform Resource Name, 统一资源名称

示例:
#+begin_example
ftp://ftp.is.co.za/rfc/rfc1808.txt (also a URL because of the protocol)
http://www.ietf.org/rfc/rfc2396.txt (also a URL because of the protocol)
ldap://[2001:db8::7]/c=GB?objectClass?one (also a URL because of the protocol)
mailto:John.Doe@example.com (also a URL because of the protocol)
news:comp.infosystems.www.servers.unix (also a URL because of the protocol)
tel:+1-816-555-1212
telnet://192.0.2.16:80/ (also a URL because of the protocol)
urn:oasis:names:specification:docbook:dtd:xml:4.1.2
#+end_example

Uri 用于结构化 URL 地址:
#+begin_src csharp
  // 一个完整的 URL 地址包括若干部分:
  //   协议://[用户名@]地址[:端口]/路径?查询参数#段
  //   schema://host:port/path?query#fragment
  //   schema://host
  //   http://baidu.com
  
  var s = "http://wwww.baidu.com:80/aaa/index.html?name=张三#333";
  Uri uri = new Uri(s);
  Console.WriteLine(uri.Host);
  Console.WriteLine(uri.Port);
  Console.WriteLine(uri.LocalPath);
  Console.WriteLine(uri.AbsolutePath);
  Console.WriteLine(uri.Query);
  Console.WriteLine(uri.Fragment);
  
  Console.WriteLine();
  
  Console.WriteLine(Uri.EscapeDataString(s));
  Console.WriteLine(Uri.EscapeUriString(s));
  Console.WriteLine(Uri.EscapeDataString("张三"));
  Console.WriteLine(Uri.UnescapeDataString("%3d"));
#+end_src

UriBuilder:
#+begin_src csharp
  var ub = new UriBuilder();
  ub.Scheme = "https";
  ub.Host = "182.23.444.55";
  ub.Port = 444;
  ub.Path = "/index.html";
  ub.Query = "?name=zhangsan";
  ub.UserName = "admin";
  ub.Password = "admin2";
  
  var uri = ub.Uri;
  Console.WriteLine(uri);
#+end_src

** IpAddress/Dns

#+begin_src csharp
  var ipStr = "8.8.8.8"; // 1.1.1.1 DNS 服务器
  //IPAddress ip = new IPAddress(ipStr);
  IPAddress ip = IPAddress.Parse(ipStr);
  Console.WriteLine($"{ip.Address}, {ip.AddressFamily}");
  
  IPAddress[] ips = Dns.GetHostAddresses("www.baidu.com");
  foreach (var i in ips)
  {
      Console.WriteLine(i);
  }
  
  IPHostEntry ih = Dns.GetHostEntry("www.bing.com");
  Console.WriteLine(ih.HostName);
  foreach (var al in ih.Aliases)
  {
      Console.WriteLine(al);
  }
#+end_src

** Socket

插座来了。

*** TCP vs UDP

- TCP (Transmission Control Protocol) 传输控制协议:
  + 可靠的连接
  + 三次握手跟四次挥手的连接跟断开
  + 传输过程中，如果存在丢包的话
- UDP (User Datagram Protocol) 用户数据报协议:
  + 不需要握手、挥手，直接发数据
  + 具备不可靠性
  + 但是保障速度

[[file:img/tcp3333.png]]

*** Socket/TCP

- TCP/IP 协议栈是由操作系统 (内核) 实现的
- Socket 是由操作系统提供的面向 TCP/IP 协议编程的接口
- C# 中，使用 ~Socket~ 对象，来完成对系统 API 调用

**** 基本语法

#+begin_src csharp
  // TCP 编程三板斧:
  //  1. bind (绑定)
  //  2. listen (监听)
  //  3. accept (接受)
  
  Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
  // 绑定监听来自哪些 IP 地址的请求，监听哪个端口 (1024)
  server.Bind(new IPEndPoint(IPAddress.Any, 16789));
  // 开始监听
  server.Listen();
  // 等待来自用户的请求
  Socket s = server.Accept();
  Console.WriteLine($"接受到一个用户的请求 {s}");
#+end_src

**** 简单的 HTTP 服务器

#+begin_src csharp
  Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
  // 绑定监听来自哪些 IP 地址的请求，监听哪个端口 (1024)
  server.Bind(new IPEndPoint(IPAddress.Any, 16780));
  // 开始监听
  server.Listen(100);
  
  int count = 0;
  
  while (true)
  {
      // 等待来自用户的请求
      Socket s = server.Accept();
      Task.Run(() =>
      {
          Console.WriteLine($"-------- 第 {++count} 个请求 --------\n\n");
  
          // 数据的读取
  
          byte[] buf = new byte[1020000];
          int n = s.Receive(buf);
          Console.WriteLine($"接受到一个用户的请求 {s}");
          Console.WriteLine($"它发送的数据是 {Encoding.UTF8.GetString(buf, 0, n)}");
  
          // 响应内容
  
          var content = "hello, world";
          StringBuilder sb = new StringBuilder();
          sb.Append("HTTP/1.1 200 OK\n");
          sb.Append($"Content-Type: {content.Length}\n");
          sb.Append("Content-Type: text/html; charset=utf-8\n");
          sb.Append("\r\n");
          sb.Append(content);
  
          s.Send(Encoding.UTF8.GetBytes(sb.ToString()));
  
          s.Shutdown(SocketShutdown.Both);
          s.Close();
      });
  }
#+end_src

**** 简单的客户端实现

#+begin_src csharp
  Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
  
  socket.Connect(IPAddress.Loopback, 16780);
  
  socket.Send(Encoding.UTF8.GetBytes("hello"));
  
  byte[] res = new byte[1024];
  int n = socket.Receive(res);
  Console.WriteLine($"我得到的响应内容是 {Encoding.UTF8.GetString(res)}");
#+end_src

*** Socket/UDP

Sender:
#+begin_src csharp
  var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
  
  while (true)
  {
      Console.Write("请输入你要发送的内容: ");
      string content = Console.ReadLine();
      socket.SendTo(Encoding.UTF8.GetBytes(content), new IPEndPoint(IPAddress.Loopback, 9897));
      Console.WriteLine("发送成功!");
  }
#+end_src

Receiver:
#+begin_src csharp
  var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
  socket.Bind(new IPEndPoint(IPAddress.Any, 9897));
  
  Console.WriteLine("创建成功，准备工作...");
  
  byte[] buf = new byte[10023];
  var ep = (EndPoint) new IPEndPoint(IPAddress.Any, 9897);
  while (true)
  {
      int n = socket.ReceiveFrom(buf, ref ep);
      Console.WriteLine($"接收到来自 {(ep as IPEndPoint).Address} 的信息:");
      Console.WriteLine(Encoding.UTF8.GetString(buf, 0, n));
  }
#+end_src

*** 通过 NetworkStream 简化对 Socket 读写的操作

#+begin_src csharp
  using var s = new NetworkStream(socket);
  
  var sr = new StreamReader(s);
  Console.WriteLine($"我接收到了数据: {sr.ReadToEnd()}");
  
  var sw = new StreamWriter(s);
  sw.WriteLine("hello, world");
#+end_src

*** 飞鸽/FeiQ

https://blog.csdn.net/ufe_1/article/details/47170615

** TcpClient/TcpListener

服务器端:
#+begin_src csharp
  var listener = new TcpListener(IPAddress.Any, 8899);
  listener.Start();
              
  while (true)
  {
      TcpClient tc = listener.AcceptTcpClient();
      Task.Run(() =>
      {
          Console.WriteLine("---");
          while (true)
          {
              var reader = new StreamReader(tc.GetStream());
              Console.WriteLine($"接收到了信息: {reader.ReadLine()}");
              Task.Delay(1000).Wait();
          }
      });
  }
#+end_src

客户端:
#+begin_src csharp
  var tc = new TcpClient();
  tc.Connect(IPAddress.Loopback, 8899);
  using var sw = new StreamWriter(tc.GetStream());
  while (true)
  {
      Console.Write("内容: ");
      string c = Console.ReadLine();
  
      sw.WriteLine(c);
      sw.Flush();
  }
#+end_src

** UdpClient

#+begin_src csharp
  var uc = new UdpClient();
  var s = Encoding.UTF8.GetBytes("hello");
  uc.Send(s, s.Length, new IPEndPoint(IPAddress.Loopback, 4344));
#+end_src

** HttpClient/HttpListener
*** HttpListener

#+begin_src csharp
  var root = "e:/myhtml/";
  
  var webServer = new HttpListener();
  webServer.Prefixes.Add("http://localhost:8099/");
  webServer.Start();
  
  while (true)
  {
      HttpListenerContext context = webServer.GetContext();
  
      Task.Run(() =>
      {
          var req = context.Request;
          var resp = context.Response;
  
          Console.WriteLine(req.RemoteEndPoint.Address);
          using (var sw = new StreamWriter(resp.OutputStream))
          {
  
              var path = req.Url.LocalPath;
              var fullPath = Path.Combine(root, path.Substring(1));
              Console.WriteLine(fullPath);
              if (Path.GetExtension(path) == ".html")
              {
                  if (File.Exists(fullPath))
                  {
                      var content = File.ReadAllText(fullPath);
                      Console.WriteLine(content);
                      sw.WriteLine(content);
                  }
                  else
                  {
                      resp.ContentType = "text/html; charset=\"utf-8\"";
                      sw.WriteLine("没有找到网页");
                      resp.StatusCode = 404;
                  }
              }
          }
          resp.Close();
      });
  } 
#+end_src



*** HttpWebRequest/WebClient/HttpClient


* Database

勤学勤练，温故知新。

** ADO.NET
*** SqlConnection / SqlCommand / SqlDataReader

#+begin_src csharp
  static void Main()
  {
      // 第一步: 创建连接
      //using var conn = new SqlConnection("server=localhost;database=lagou;uid=sa;pwd=sa");
      //using var conn = new SqlConnection("server=.;database=lagou;uid=sa;pwd=sa");
      using var conn = new SqlConnection("server=.;database=lagou;integrated security=SSPI");
  
      // 第二步: 组织查询语句
      var command = new SqlCommand("select top 5 position, city, salary_min from lagou_position", conn);
  
      // 第三步: 打开数据库，准备查询
      conn.Open();
  
      // 第四步: 查询
      SqlDataReader reader = command.ExecuteReader();
      while (reader.Read())
      {
          var position = reader[0];
          var city = reader[1];
          var salary = reader[2];
          Console.WriteLine($"{position}: {city}/{salary}");
      }
  }
#+end_src

*** ExecuteScalar / SQL Injection / Parameters

在珠海，Salary_min 最高的 C# 岗位的 Salary_max 是多少:
#+begin_src csharp
  class Program
  {
      static void Main()
      {
          Console.WriteLine(GetSalayMaxFromCity("珠海"));
      }
  
      static void 这就是SQL注入问题()
      {
          var city = "珠海';drop table lagou_position;select * from lagou_position where 1='";
          var sql0 = $"select * from lagou_position where city = '{city}'";
          Console.WriteLine(sql0);
      }
  
      static double GetSalayMaxFromCity(string city)
      {
          // 第一步: 创建连接
          using var conn = new SqlConnection("server=.;database=lagou;uid=sa;pwd=sa");
  
          // 第二步: 组织语句
          var sql = $"select top 1 salary_max from lagou_position where city = '{city}' and (position like '%c#%' or position like '%.net%') order by salary_min desc";
          var command = new SqlCommand(sql, conn);
  
          // 第三步: 打开数据库
          conn.Open();
  
          // 第四步: 查询
          double salaryMax = (double)command.ExecuteScalar();
  
          return salaryMax;
      }
  }
#+end_src

解决 SQL 注入，最朴素的方式，是对传入的字符串中的特殊字符进行替换:
#+begin_src csharp
  // 但是要注意，这种方式绝对不可能 100% 防止注入
  city = city.Replace('-', '、');
  city = city.Replace('\'', '’');
#+end_src

Parameters 可以 a) 简化代码 b) 防止 SQL 注入:
#+begin_src csharp
  class Program
  {
      static void Main()
      {
          GetSalayMaxFromCity("珠海");
      }
  
      static void 这就是SQL注入问题()
      {
          var city = "珠海';drop table lagou_position;select * from lagou_position where 1='";
  
          var sql0 = $"select * from lagou_position where city = '{city}'";
          Console.WriteLine(sql0);
      }
  
      static void GetSalayMaxFromCity(string city)
      {
          // 第一步: 创建连接
          using var conn = new SqlConnection("server=.;database=lagou;uid=sa;pwd=sa");
  
          // 第二步: 组织语句
          var command = new SqlCommand("select top 5 city, position from lagou_position where city=@xxx and salary_min > @aaa", conn);
  
          //command.Parameters.AddWithValue("xxx", city); // 绑定到了 xxx 位置
          //command.Parameters.AddWithValue("aaa", 20);
  
          command.Parameters.AddRange(new[]
          {
              new SqlParameter("xxx", SqlDbType.VarChar) {Value = city},
              new SqlParameter("aaa", SqlDbType.Int) {Value = 20}
          });
  
  
          //command.Parameters.Add("xxx", SqlDbType.VarChar);
          //command.Parameters["xxx"].Value = city;
  
          //var param = new SqlParameter("xxx", SqlDbType.VarChar);
          //param.Value = city;
          //command.Parameters.Add(param);
  
          //command.Parameters.Add(new SqlParameter("xxx", SqlDbType.VarChar) {Value = city});
  
          // 第三步: 打开数据库
          conn.Open();
  
          // 第四步: 查询
          using var reader = command.ExecuteReader();
          while (reader.Read())
          {
              Console.WriteLine($"-- {reader[0]}: {reader["position"]}");
          }
      }
  }
#+end_src

*** SqlDataReader vs SqlDataAdapter/DataTable

#+begin_src csharp
  static void Main(string[] args)
  {
      using var conn = DbHelper.GetConnection();
      var command = new SqlCommand("select * from students", conn);
      using var reader = command.ExecuteReader();
  
      DataTable dataTable = new DataTable();
      dataTable.Load(reader);
  
      foreach (DataRow row in dataTable.Rows)
      {
          Console.WriteLine($"{row[0]}:{row[1]}:{row[2]}");
      }
  }
#+end_src

#+begin_src csharp
  static void Main(string[] args)
  {
      DataTable dataTable = new DataTable();
  
      using var conn = DbHelper.GetConnection();
      var adapter = new SqlDataAdapter("select name, tiwen_cishu, tiwen_fenshu from students where gid = @gid", conn);
      adapter.SelectCommand.Parameters.AddWithValue("gid", 2);
      adapter.Fill(dataTable);
  }
#+end_src

** Entity Framework

- https://docs.microsoft.com/zh-cn/ef/
- https://github.com/dotnet/EntityFramework.Docs

*** 历史

Entity Framework:
- 1.0，.NET 3.5，微软推出了自己的 *ORM* 框架，叫 Entity Framework，简称 EF
- 4.0，这个版本因为添加了太多内容，所以微软为了表示与以前不同，就直接跳过了 2/3 到了 4
- 6.0，这是当前最新的版本

随着 .net core 的发布，Entity Framework 被微软完全重写了。

*** EF6

https://docs.microsoft.com/zh-cn/ef/ef6/modeling/

优点:
- 漫长的积淀，非常成熟、非常稳定
- 功能上相对强大

**** 模型生成 (基于 edmx)

基于 edmx 和 VS Designer 的生成方式:
1. *Database First* 方式
   - 通过在 VS 中添加 [ADO.NET 实体数据模型] - [从数据库生成] 的方式，直接将数据库中的表映射为 edmx 文件
   - 通过修改 edmx 之后再保存，达到自动生成/更新相应的 Model 和相关类的目的
2. *Model First* 方式

实体数据模型 edms (Entity Data Model XML):
- edmx 主要分为三部分:
  1) SSDL (Store Schema Definition Language) 描述数据库中的实体结构
  2) CSDL (Conceptual Schema Definition Language) 描述 Csharp 模型
  3) MSL (Mapping Specification Language) 描述数据库中的对象跟模型对象之间的映射关系
- tt 后缀名的文件，表示的是 *t4* (Text Template Transformation Toolkit) 引擎的文件，它用来自动生成相关的类文件
- 在 Entity Framework Core 中，这种方式，已经被遗弃

留下在问题:
- edmx 是什么？包含哪几部分？请做描述
- 基于 edmx 的开发方式，有什么优点和缺点?

**** 模型生成 (Code First)

通过编码的方式，创建 Model 和 Database:
- https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/workflows/new-database

*** EFCore

官方文档:
- https://docs.microsoft.com/zh-cn/ef/

安装依赖:
- Microsoft.EntityFrameworkCore [必须依赖]
- Microsoft.EntityFrameworkCore.SqlServer [按照数据库选择相应的]

命令行添加:
#+begin_src sh
  dotnet new console
  dotnet add package Microsoft.EntityFrameworkCore.SqlServer
#+end_src

*** 上下文 (DbContext/DbSet)

DbContext 代表数据库的会话管理：
- 这个设计本身是轻量级的。new 后，使用，用完，释放。*using 必须要使用*
- 管理 Entity，需要实现自己的 DbContext
- 将要管理的 Entity，使用 DbSet<T> 的方式暴露出来  
- 使用 ~OnConfiguring~ 来进行 *初始配置*:
  + 配置数据库连接: options.UseSqlServer(connStr)
  + 配置日志的输出: options.LogTo(Console.WriteLine);
- 使用 ~OnModelCreating~ 方法，用来在模型对象创建之后，做一些 *后续调整*

*** 模型的三个层次

*约定*:
- CoC, Convention Over Configuration, 约定大于配置, Ruby, RoR, Ruby on Rails, Web: CoC
- Entity 对应的表的名字，默认为 DbSet 属性的名字
- Id 后缀名命名的 int/Guid 类型，会被当成数据库表的主键 (Id -> EntityId)
- 类型约定:
  : int -> int,
  : string -> nvarchar(max)
  : enum -> int,notnull
  : double -> float,notnull
  : DateTime -> datetime2
- 字段、只有 get 的属性，是不能被映射到数据库的

*[注解]* (System.ComponentModel.DataAnnotations):
- Table/Column/NotMapped
- ForeignKey/Key/DatatableGenerated
- Require/StringLength/MinLength/MaxLength/Range
- RegularExpression/Phone/EmailAddress/Url/CreditCard
- Index
- https://blog.csdn.net/a123_z/article/details/112279594

*Fluent API*:
- 写在 OnModelCreating 里面
- 它跟注解都能达到配置模型和映射的目的，但他们并不是互斥的关系，而是一种互相补充
- https://www.cnblogs.com/yanglang/p/7212203.html

*** 模型之间的关系

导航属性:
#+begin_example
  class Teacher // table teacher: id/name
  {
     Id;
     Name;
  }
  class Student // table student: id/name/teacherid
  {
     Id;
     Name;
     TeacherId; // 外键
  }
  
  class Blog
  {
    Id;
    Url;
    -----
    Posts; // 导航属性
  }
  class Post
  {
    Id;
    Title;
    Content;
    BlogId;
  }
#+end_example

基于约定和注解:
#+begin_src csharp
  public class BloggingContext : DbContext
  {
      protected override void OnConfiguring(DbContextOptionsBuilder options)
      {
          options.UseSqlServer(ConfigurationManager.ConnectionStrings["blogdb"].ConnectionString);
          options.LogTo(LogHelper.WriteToFile, Microsoft.Extensions.Logging.LogLevel.Information);
      }
  
      protected override void OnModelCreating(ModelBuilder modelBuilder)
      {
          base.OnModelCreating(modelBuilder);
      }
  
      public DbSet<Blog> Blogs { get; set; }
      public DbSet<Post> Posts { get; set; }
      public DbSet<Book> Books { get; set; }
      public DbSet<User> Users { get; set; }
  }
  
  // blog vs post
  
  public class Blog
  {
      public int BlogId { get; set; }
      public string Url { get; set; }
  
      public List<Post> Posts { get; set; } = new List<Post>();
  }
  public class Post
  {
      public int PostId { get; set; }
      public string Title { get; set; }
      public string Content { get; set; }
      public int BlogId { get; set; }
          
      public Blog Blog { get; set; }
  }
  
  // bookStore
  
  public class Book
  {
      public int BookId { get; set; }
      public string Name { get; set; }
      public DateTime PublishedAt { get; set; }
  
      public int AuthorId { get; set; }
      public int? ReviewerId { get; set; }
  
      [ForeignKey("AuthorId")]
      public User Author { get; set; }
  
      [ForeignKey("ReviewerId")]
      public User Reviewer { get; set; }
  
      public List<Chapter> Chapters { get; set; } = new List<Chapter>();
  
      [InverseProperty("Book")]
      public List<Comment> Comments { get; set; } = new List<Comment>();
  
  }
  public class Chapter
  {
      public int Id { get; set; }
      public string Title { get; set; }
      public int BookId { get; set; }
  
      public Book Book { get; set; }
  }
  public class Comment
  {
      public int Id { get; set; }
      public string Content { get; set; }
      public int BookId { get; set; }
  
      public Book Book { get; set; }
  }
  public class User
  {
      public int UserId { get; set; }
      public string Name { get; set; }
  
      [InverseProperty("Author")]
      public List<Book> WriteBooks { get; set; } = new List<Book>();
  
      [InverseProperty("Reviewer")]
      public List<Book> ReviewBooks { get; set; } = new List<Book>();
  }
#+end_src

错误:
#+begin_example
  Unhandled exception. Microsoft.Data.SqlClient.SqlException (0x80131904): 将 FOREIGN KEY 约束 'FK_Books_Users_ReviewerId' 引入表 'Books' 可能会导 致循环或多重级联路径。请指定 ON DELETE NO ACTION 或 ON UPDATE NO ACTION，或修改其他 FOREIGN KEY 约束。
  无法创建约束或索引。请参阅前面的错误。
  
  
  [Solution] 两种方案:
  第一种，将 AuthorId 或 ReviewId 设为可空类型
  第二种，使用 FluentAPI 禁止级联删除 .OnDelete(...)
#+end_example

*** 数据查询

Where/Find:
#+begin_src csharp
  //using var db = new BloggingContext();
  //List<Post> posts = db.Posts.ToList();
  //Console.WriteLine(posts.Count());
  
  //using var db = new BloggingContext();
  //List<Post> posts = await db.Posts.ToListAsync();
  //Console.WriteLine(posts.Count());
  
  //using var db = new BloggingContext();
  //List<Post> posts = db.Posts.ToList();
  //var postIdGt5 = posts.Where(p => p.PostId > 5).ToList();
  //Console.WriteLine(postIdGt5.Count());
  
  //using var db = new BloggingContext();
  //var posts = db.Posts;
  //var postIdGt5 = posts.Where(p => p.PostId > 5).ToList();
  //Console.WriteLine(postIdGt5.Count());
  
  //using var db = new BloggingContext();
  //DbSet<Post> posts = db.Posts;
  //IQueryable<Post> postIdGt5 = posts.Where(p => p.PostId > 5);
  //Console.WriteLine(postIdGt5.Count());
  
  //using var db = new BloggingContext();
  //var posts = db.Posts;
  //var postIdGt5 = posts.Where(p => p.PostId > 5);
  //Console.WriteLine(postIdGt5.Count());
  
  //using var db = new BloggingContext();
  //Console.WriteLine(db.Posts
  //    .Where(p => p.PostId > 5)
  //    .Where(p => p.Title.Length > 0)
  //    .Count());
  
  //using var db = new BloggingContext();
  //Console.WriteLine(db.Posts
  //    .Where(p => p.PostId > 5 && p.Title.Length > 2)
  //    .Where(p => p.Content != null)
  //    //.Pagination(5)
  //    .Count()) ;
  
  //using var db = new BloggingContext();
  //Post post = db.Posts.Where(p => p.PostId == 1).ToList()[0];
  //Console.WriteLine(post.BlogId);
  
  //using var db = new BloggingContext();
  //Post post = db.Posts.Where(p => p.PostId == 1).First();
  //Console.WriteLine(post.BlogId);
  
  //using var db = new BloggingContext();
  //Post post = db.Posts.Where(p => p.PostId == 1).Single();
  //Console.WriteLine(post.PostId);
  
  //using var db = new BloggingContext();
  //Post post = db.Posts.Find(1);
  //Console.WriteLine(post.PostId);
  
  using var db = new BloggingContext();
  Post p = db.Posts.FromSqlRaw("select * from Posts join xxx on xxx... where postid = 3").Single();
  Console.WriteLine(p.Title);
#+end_src

关联查询:
#+begin_src csharp
  // 显式、手动、主动加载
  
  //using var db = new BloggingContext();
  //Blog b = db.Blogs.Find(1);
  //db.Entry(b).Collection(b => b.Posts).Load();
  //db.Entry(b).Collection(b => b.Bs).Load();
  //db.Entry(b).Collection(b => b.Cs).Load();
  //Console.WriteLine($"{b.BlogId}, {b.Url}");
  //Console.WriteLine(b.Posts.Count());
  
  //using var db = new BloggingContext();
  //Post p = db.Posts.Find(1);
  //db.Entry(p).Reference(p => p.Blog).Load();
  //Console.WriteLine($"{p.Title}");
  //Console.WriteLine(p.Blog.Url);
  
  //using var db = new BloggingContext();
  //Post p = db.Posts.Find(1);
  //Console.WriteLine(p.Title);
  //Thread.Sleep(10000);
  //db.Entry(p).Reload();
  //Console.WriteLine(p.Title);
  
  // 动态、实时加载
  
  //using var db = new BloggingContext();
  //Post p = db.Posts
  //    .Where(p => p.PostId == 1)
  //    .Include(p => p.Blog)
  //    .Single();
  //Console.WriteLine(p.Blog.Url);
  
  using var db = new BloggingContext();
  Post p = db.Posts
      .Where(p => p.PostId == 1)
      .Include(p => p.Blog)
      .ThenInclude(b => b.Posts)
      .Single();
  Console.WriteLine(p.Blog.Posts.Count());
  
  //using var db = new BloggingContext();
  //Post p = db.Posts
  //    .Where(p => p.PostId == 1)
  //    .Include(p => p.Blog)
  //    .ThenInclude(b => b.Posts)
  //    .AsSplitQuery()
  //    .Single();
  //Console.WriteLine(p.Blog.Posts.Count());
  
  // 代理方式 Proxy
  
  using var db = new BloggingContext();
  Blog p1 = db.Blogs.Find(1);
  Console.WriteLine(p1.Posts.Count());
#+end_src

*** 数据修改
*** 日志
**** 使用 options.LogTo 方法

#+begin_src csharp
  // 记录到控制台
  options.LogTo(Console.WriteLine, Microsoft.Extensions.Logging.LogLevel.Information);
  
  // 记录到文件
  options.LogTo((string log) =>
  {
      File.AppendAllText(@"e:\log1111.txt", $"\n\n{log}");
      //Console.WriteLine(log);
  }, Microsoft.Extensions.Logging.LogLevel.Information);
  
  // 可以简化为:
  options.LogTo(log => File.AppendAllText(@"e:\log1111.txt", $"\n\n{log}"), Microsoft.Extensions.Logging.LogLevel.Information);
#+end_src

*** 集成容器

#+begin_src csharp
  //var di = new ServiceCollection()
  //    .AddTransient<BloggingContext>()
  //    .AddSingleton<PostService>()
  //    .BuildServiceProvider();
  
  //var di = new ServiceCollection()
  //    .AddDbContext<BloggingContext>()
  //    .AddSingleton<PostService>()
  //    .BuildServiceProvider();
  
  var di = new ServiceCollection()
      .AddDbContext<BloggingContext>(options => options.UseSqlServer("server=.;database=ccc;uid=sa;pwd=sa"))
      .AddSingleton<PostService>()
      .BuildServiceProvider();
  
  di.GetService<PostService>().Xxxx();
  //new PostService().Xxxx();
#+end_src

*** 三层架构

*** 随堂代码
**** 2021年11月10日 (基本使用)

#+begin_src csharp
  public class BloggingContext : DbContext
  {
      public DbSet<Blog> BlogSet { get; set; }
      public DbSet<Post> Posts { get; set; }
  
      protected override void OnConfiguring(DbContextOptionsBuilder options)
      {
          //options.UseSqlServer("server=.;database=ccc;uid=sa;pwd=sa");
          options.UseSqlServer("blogdb");
  
      }
  
      protected override void OnModelCreating(ModelBuilder modelBuilder)
      {
          base.OnModelCreating(modelBuilder);
      }
  }
  
  public class Blog
  {
      public int BlogId { get; set; }
      public string Url { get; set; }
  
      public List<Post> Posts { get; } = new List<Post>();
  
      public override string ToString()
      {
          return $"{{{nameof(BlogId)}={BlogId.ToString()}, {nameof(Url)}={Url}, {nameof(Posts)}={Posts}}}";
      }
  }
  
  public class Post
  {
      public int PostId { get; set; }
      public string Title { get; set; }
      public string Content { get; set; }
      public string Desc { get; set; }
  
      public int BlogId { get; set; }
      public Blog Blog { get; set; }
  }
  
  class Program
  {
      static void Main(string[] args)
      {
          NewMethod();
  
      }
  
      private static BloggingContext NewMethod()
      {
          var db = new BloggingContext();
  
          db.BlogSet.Where(b => b.BlogId == 99);
          db.BlogSet.Where(b => b.BlogId == 96);
          db.BlogSet.Where(b => b.BlogId == 95);
  
          //IQueryable<Blog> blogs = db.Blogs.Where(b => b.BlogId > 94);
  
          //Console.WriteLine(blogs.Count());
          //Console.WriteLine(blogs.Max(b => b.BlogId));
          //Console.WriteLine(blogs.OrderBy(b => b.Url).Last());
          //Console.WriteLine(blogs.Count());
  
          var blogs = db.BlogSet
              .Where(b => b.BlogId > 94)
              .Where(b => b.Url.Length > 3)
              .OrderByDescending(b => b.BlogId)
              .Where(b => b.Url.Length % 2 == 0 && b.BlogId % 2 == 1)
              .Where(b => b.Posts.Any(p => p.Title.Length > 20))
              .Where(b => b.Url.Length > 3)
              .OrderByDescending(b => b.Url)
              .Where(b => b.BlogId % 2 != 1)
              .Pagination(3)
              .Where(b => b.Posts.Any(p => p.Title.Length > 20));
  
          //blogs = Pagination(blogs, 3);
          //blogs = blogs.Where(b => b.Posts.Any(p => p.Title.Length > 20));
  
          foreach (var b in blogs)
              Console.WriteLine(b);
          return db;
      }
  
      static IQueryable<Blog> Pagination(IQueryable<Blog> query, int pageNum, int pageSize = 5)
      {
          return query.Skip((pageNum - 1) * pageSize).Take(pageSize);
      }
  }
  
  public static class MyExtendMethods1
  {
      public static IQueryable<T> Pagination<T>(this IQueryable<T> query, int pageNum, int pageSize = 5)
      {
          return query.Skip((pageNum - 1) * pageSize).Take(pageSize);
      }
  }
#+end_src

**** 2021年11月11日 (模型创建)

#+begin_src csharp
  public class BloggingContext : DbContext
  {
      public DbSet<Blog> BlogSet { get; set; }
      public DbSet<Post> Posts { get; set; }
      public DbSet<User> Users { get; set; }
  
      protected override void OnConfiguring(DbContextOptionsBuilder options)
      {
          //options.UseSqlServer("server=.;database=ccc;uid=sa;pwd=sa");
          options.UseSqlServer(ConfigurationManager.ConnectionStrings["blogdb"].ConnectionString);
          //options.UseSqlite(ConfigurationManager.ConnectionStrings["sqlite"].ConnectionString);
          options.LogTo(LogHelper.WriteToFile, Microsoft.Extensions.Logging.LogLevel.Information);
      }
  
      protected override void OnModelCreating(ModelBuilder modelBuilder)
      {
          base.OnModelCreating(modelBuilder);
  
          modelBuilder.Entity<Blog>()
              .ToTable("MyBlogs");
  
          modelBuilder
              .Entity<User>()
              .HasKey(u => u.Username);
  
          modelBuilder
              .Entity<User>()
              .Property("Username").HasColumnName("my_usernmae");
      }
  }
  
  
  [ComplexType]
  public class X
  {
      public int A { get; set; }
      public int B { get; set; }
  }
  
  [Table("Blogs")]
  public class Blog
  {
      public int BlogId { get; set; }
  
      [Column("BlogUrl")]
      public string Url { get; set; }
  
      public List<Post> Posts { get; } = new List<Post>();
  }
  
  public enum Zhiliang
  {
      Gao, Di
  }
  
  public class Post
  {
      [Key]
      public int PostId { get; set; }
  
      [Required]
      public string Title { get; set; }
  
      [StringLength(1000)]
      public string Content { get; set; }
  
      [Column("post_desc")]
      public string Desc { get; set; }
  
      public Zhiliang ZL { get; set; }
      [Range(0, 1000)]
      public double Price { get; set; } = 55.2;
      public DateTime CreatedAt { get; set; }
  
      [ForeignKey("fk_hello_blog")]
      [Column("xxxx")]
      public int BlogId { get; set; }
      public Blog Blog { get; set; }
  }
  
  public class User
  {
      public string  Username { get; set; }
      public string  Address { get; set; }
      public string  Weixin { get; set; }
  }
  
  class Program
  {
      static void Main(string[] args)
      {
          using var db = new BloggingContext();
          db.Database.EnsureDeleted();
          db.Database.EnsureCreated();
      }
  
      private static void NewMethod()
      {
          using var db = new BloggingContext();
          db.BlogSet.Add(new Blog { Url = "http://baidu.com" });
          db.SaveChanges();
      }
      static void NewMethod4()
      {
          var db = new BloggingContext();
  
          db.BlogSet.Where(b => b.BlogId == 99);
          db.BlogSet.Where(b => b.BlogId == 96);
          db.BlogSet.Where(b => b.BlogId == 95);
  
          //IQueryable<Blog> blogs = db.Blogs.Where(b => b.BlogId > 94);
  
          //Console.WriteLine(blogs.Count());
          //Console.WriteLine(blogs.Max(b => b.BlogId));
          //Console.WriteLine(blogs.OrderBy(b => b.Url).Last());
          //Console.WriteLine(blogs.Count());
  
          var blogs = db.BlogSet
              .Where(b => b.BlogId > 94)
              .Where(b => b.Url.Length > 3)
              .OrderByDescending(b => b.BlogId)
              .Where(b => b.Url.Length % 2 == 0 && b.BlogId % 2 == 1)
              .Where(b => b.Posts.Any(p => p.Title.Length > 20))
              .Where(b => b.Url.Length > 3)
              .OrderByDescending(b => b.Url)
              .Where(b => b.BlogId % 2 != 1)
              .Pagination(3)
              .Where(b => b.Posts.Any(p => p.Title.Length > 20));
  
          //blogs = Pagination(blogs, 3);
          //blogs = blogs.Where(b => b.Posts.Any(p => p.Title.Length > 20));
  
          foreach (var b in blogs)
              Console.WriteLine(b);
      }
  }
  
  public static class MyExtendMethods1
  {
      public static IQueryable<T> Pagination<T>(this IQueryable<T> query, int pageNum, int pageSize = 5)
      {
          return query.Skip((pageNum - 1) * pageSize).Take(pageSize);
      }
  }
#+end_src


*** 生成/Reverse

- Enable-Migrations
- Add-Migration
- Update-Database

*** 总结

请你简单叙述一下使用 EF 框架进行开发的优点和缺点。

** Dapper/SqlSugar/FreeSQL/NHibernate
*** Dapper

King of Micro ORM framework, on speed.

https://dapper-tutorial.net/dapper

使用只需要三步:
1. 创建 IDbConnection 对象
2. 写一个 query 进行 CRUD 操作
3. 在 Execute 方法中传入一个 parameter

*** SqlSugar

https://gitee.com/dotnetchina/SqlSugar

*** FreeSQL

http://www.freesql.net/

*** NHibernate

https://nhibernate.info/

*** MyBatis.NET

https://www.codeproject.com/articles/894127/mybatis-net

** 事务 (Transaction)

#+begin_src csharp
  var conn = DbHelper.GetConnection();
  SqlTransaction trans = conn.BeginTransaction(); // 1. 创建事务
  
  try
  {
      // 1. 
      var command1 = new SqlCommand(
          "insert into tiwen (stuid, score) values (@stuid, @score)",
          conn, trans);                           // 2. 绑定事务
      command1.Parameters.AddRange(new[]
      {
          new SqlParameter("stuid", stuid),
          new SqlParameter("score", score)
      });
      command1.ExecuteNonQuery();
  
      // 2
      var command2 = new SqlCommand(@"update students
          set tiwen_cishu = tiwen_cishu + 1, tiwen_fenshu = tiwen_fenshu + @score
          where id = @stuid", conn, trans);
      command2.Parameters.AddRange(new[]
      {
          new SqlParameter("stuid", stuid),
          new SqlParameter("score", score)
      });
      command2.ExecuteNonQuery();
  
      trans.Commit();                              // 3.提交事务
  }
  catch
  {
      trans.Rollback();                            // 4. 回撤事务
  }
#+end_src

环境事务:
#+begin_src csharp
  using (var ts = new TransactionScope())
  {
      foreach ((string id, int score) in scores)
      {
          dal.AddScore(id, score);
      }
  
      ts.Complete();
  } 
#+end_src

** 示例数据库

- Sakila: https://github.com/ivanceras/sakila
- Northwind/AdventureWorks: https://github.com/Microsoft/sql-server-samples
- 生成示例数据库: https://mockaroo.com/

* BCL (Base-Class Library) 基础类库
** Console/控制台

相关方法和属性:
- Console.Write/WriteLine，用来向控制台输出内容
- Console.Clear，用来清空屏幕内容
- Console.ForegroundColor/BackgroudColor/ResetColor，用来设置控制台颜色
- Console.ReadLine，用来从控制台读取用户输入的字符串
- Console.ReadKey，用来读取按键，返回一个 ConsoleKeyInfo 对象
- Console.Beep，用来让控制台发出声音

相关类和结构:
- Console
- ConsoleColor
- ConsoleKey/ConsoleKeyInfo

示例:
#+begin_src csharp -n
  Console.WriteLine();
  while (true) // 通过 while 循环可以实现不断输入不断看到输入结果的过程
  {
      // ReadKey 是微软封装在 Console 里的一个方法，用来读取控制台上的按键
      // 我们不需要关心它怎么实现的，我们只需要关心它如何使用
      // 微软在实现里，将我们按下的键的信息，封装到了一个叫 ConsoleKeyInfo 的数据包里 (实例对象)
      // 调用 ReadKey 之后，就可以通过这个实例对象 key 所提供的可访问接口判断按键信息了
      ConsoleKeyInfo key = Console.ReadKey(true); // true 的意思是，不在屏幕上显示键入的字符
      if (key.Key == ConsoleKey.D1)
      {
          Console.WriteLine("您输入了一个 1");
      }
      else if (key.Key == ConsoleKey.S)
      {
          Console.Beep(); // Beep 是微软实现在 Console 里的一个方法，用来让控制台发出声音
      }
      else if (key.KeyChar == 'd')
      {
          Console.Beep(600, 200); // Beep 方法是重载的，它可以携带参数
      }
      else if (key.KeyChar == 'f')
      {
          Console.Beep(200, 200);
      }
      else if (key.Key == ConsoleKey.Enter)
      {
          break;
      }
      else
      {
          Console.WriteLine($"key: {key}, keyChar: {key.KeyChar}, key: {key.Key}");
      }
  }
#+end_src

** Random/Thread

#+begin_src csharp
  ConsoleColor[] colors = new ConsoleColor[]
  {
      ConsoleColor.Red, ConsoleColor.Green, ConsoleColor.Yellow
  };

  int i = 0;
  while (true)
  {
      // Console.WriteLine("hello {0}", DateTime.Now);
      // var timer = new Timer(null, TimeSpan(1), TimeSpan(2));
      Thread.Sleep(1000); // 题外话，这个 1000 毫秒并不是非常准确
      // Task.Delay(1000).Wait();

      //Console.WriteLine(colors[i]);
      //i = i + 1;
      //if (i == 3) i = 0;

      //Console.WriteLine(colors[i]);
      //i = (i + 1) % 3;

      //Console.WriteLine(colors[(i++) % 3]);

      System.Random random = new System.Random();
      int r = random.Next(colors.Length); // Next(3): 0, 1, 2
      Console.WriteLine(colors[r]);

      Console.Clear(); // 清空屏幕
      Console.ResetColor(); // 重置颜色
  }
#+end_src

** IDisposable/资源

- 资源，是指需要在操作系统中打开，用完之后，需要手动释放的对象
- 为什么需要手动释放呢？因为 .NET 平台不是万能的。虽然 .NET 平台有垃圾回收器，你不再需要的
  对象，它会自动帮你清理掉，但是有些东西它是无法确定你到底还需不需要，所以无法帮助你自动处理。
  你也只能手动释放或关闭
- 对于一些资源，必须要手动释放或关闭

对于普通的对象，是可以被 GC 自动回收的:
#+begin_src csharp
  // 创建的任何对象，都是可以被垃圾回收器 (GC) 自动释放
  // 因此，我们只需要 new 然后使用就可以了，其他的内存管理无需你关心
  for (int i = 0; i < 100000000; i++)
  {
      var a = new Book(); // 创建多少个都会被自动释放，绝对安全
  }
#+end_src

但是对于一些依赖系统的资源，必须要手动释放:
#+begin_src csharp
  // 像文件这样的资源，打开之后，必须要手动释放
  var fs = File.OpenRead(fileName);
  Console.WriteLine(5/0); // 代表使用 (2)
  fs.Close();             // 手动关闭/释放

  // 上述的代码是有问题的，因为，如果 (2) 出现错误的话，那么释放的语句就无法执行
  // 为了解决这个问题，可以使用 finally 语法，对整个资源释放的代码进行重构
  FileStream fs = null;
  try
  {
      fs = File.OpenRead(fileName);
      Console.WriteLine(fs);
      Console.WriteLine(5/0);
      Console.WriteLine("其他你所需要做的事情");
  }
  finally
  {
      if (fs != null)
      {
          try
          {
              fs.Close();
          }
          catch
          {
              Console.WriteLine("关闭失败");
          }
      }
  }

  // 可以使用 using 对上述代码进行简化
  // 必须让 FileStream 里面实现一个叫 Dispose 的方法
  // 为了保证你必须实现一个 Dispose 方法，你必须要实现 IDisposable 接口
  using (FileStream fs = File.OpenRead(fileName))
  {
      Console.WriteLine(fs);
      Console.WriteLine(5/0);
  }

  // 最新的 C# 版本又给了新的糖
  using FileStream fs = File.OpenRead(fileName); // fs 在后面碰到 } 后，会自动释放
  Console.WriteLine(fs);
  Console.WriteLine(5/0);
#+end_src

** Stopwatch/秒表

#+begin_src cs
  using System.Diagnostics;
  
  Stopwatch sw = new Stopwatch();
  sw.Start();
  // .....
  Console.WriteLine(sw.ElapsedMillionseconds);  // 1111ms
  sw.Stop();
#+end_src

** ConfigurationManager/配置管理器

首先，需要引入包:
#+begin_src sh
  dotnet add package System.Configuration.ConfigurationManager
#+end_src

其次，在 App.config 或 Web.config 中添加相应配置信息:
#+begin_src xml
  <?xml version="1.0" encoding="utf-8" ?>
  <configuration>
    <connectionStrings>
      <clear/>
      <add name="blogdb" connectionString="server=.;database=ccc;uid=sa;pwd=sa"/>
    </connectionStrings>
  </configuration>
#+end_src

最后，在程序中使用:
#+begin_src csharp
  var dbString = ConfigurationManager.ConnectionStrings["blogdb"].ConnectionString;
#+end_src

** RegularExpression/正则表达式

https://regexlearn.com/

电话号码:
: ^1[3578][0-9]{9}$

邮箱地址:
: ^[a-zA-Z][a-zA-Z0-9_]{5,17}@[a-z0-9]+\.(com|net|edu.cn|org)$

#+begin_src csharp
  public string xxx1 (string input, string regexp)
  {
      // var r = new Regex("^1[3578][0-9]{9}$");
      var r = Regex.IsMatch(input, regexp);
      return $"{input}     {regexp}: {r}";
  }
  
  public string xxx2 (string input, string regexp)
  {
      //var m = Regex.Match(input, regexp);
      var ms = Regex.Matches(input, regexp);
      var r = string.Join(" ", ms);
      return $"{input}     {regexp}: {r}";
  }
  
  public string xxx3 (string input, string regexp)
  {
      return Regex.Replace(input, regexp, ""); 
  }
  
  public string xxx4 ()
  {
      var s = "hello   =   , world,  -      where _ , are";
      var ws = Regex.Split(s, "[^a-zA-Z]+");
      var r = string.Join("!!", ws);
      return $"{r}";
  }
#+end_src  

* Winform
** 布局相关
*** 基本属性

- 通过 Size 设置窗口大小/尺寸
- 通过 StartPosition 设置窗口的启动位置
- 通过 FormBorderStyle 设置窗口的风格
- 通过 MinimizeBox/MaximizeBox 来设置是否显示最大、最小按钮

*** Layout

- Anchor/锚

通过代码的方式，进行自适应布局:
#+begin_src csharp
  protected override void OnLayout(LayoutEventArgs levent)
  {
      base.OnLayout(levent);
      
      var ww = this.ClientSize.Width; // 窗口的宽度
      var labelW = 40;                // label 的宽度
      var buttonW = 100;              // button 的宽度
      var gap = 5;                    // 控件的间隔
      int inputW = (ww - labelW * 3 - buttonW - 8 * gap - 6 * 7) / 3;
  
      nameLabel.Width = labelW;
      label1.Width = labelW;
      priceLabel.Width = labelW;
      addBookBtn.Width = buttonW;
  
      nameInput.Width = inputW;
      authorInput.Width = inputW;
      priceInput.Width = inputW;
  
      nameLabel.Left = gap;
      nameInput.Left = nameLabel.Right + gap;
      label1.Left = nameInput.Right + gap;
      authorInput.Left = label1.Right + gap;
      priceLabel.Left = authorInput.Right + gap;
      priceInput.Left = priceLabel.Right + gap;
      addBookBtn.Left = priceInput.Right + gap;
  }
#+end_src

** 数据容器

- ListBox
- ListView
- TreeView
- DataGridView


添加数据到 ListBox 的方式:
#+begin_src csharp
  // 第一种
  this.lbStudents.Items.Add("张三");
  this.lbStudents.Items.Add("李四");
  this.lbStudents.Items.Add("王五");
  this.lbStudents.Items.Add("赵六");
  
  // 第二种
  this.lbStudents.Items.AddRange(new string[]
  {
      "Tom", "Jerry", "派大星", "奥特曼"
  });
  
  // 第三种
  List<string> students1 = new List<string>
  {
      "aaa", "bbb", "ccc"
  };
  //this.lbStudents.DataSource = students1;
  
  // 第四种
  var binding = new BindingSource();
  binding.DataSource = students1;
  binding.Add("ddd");
  this.lbStudents.DataSource = binding;
#+end_src

* 技巧和示例
** 求余

求余经常用来将某个数 *转换* 为 0-N 区间的一个数。

示例一，结合循环使用:
#+begin_src csharp -n
  for (int i = 0; i < 1000; i++)
  {
      int f = ((i % 8) * 30) + 100;
      Console.Beep(f, 50);
      Thread.Sleep(800 - (i % 8) * 50);
  }
#+end_src

示例二，求余和数组的结合使用:
#+begin_src csharp -n
  int[] freqs = new int[] { 200, 300, 100, 600 };

  for (int i = 0; i < 1000; i++)
  {
      int f = freqs[i % freqs.Length];
      Console.Beep(f, 50);
      Thread.Sleep(800 - (i % freqs.Length) * 50);
  }
#+end_src

示例三:
#+begin_src csharp -n
  // 除了声音外，添加视觉效果
  // 原理是一样的
  int[] freqs = new [] { 200, 300, 100, 600 };
  ConsoleColor[] colors = new[] { ConsoleColor.Red, ConsoleColor.Green, ConsoleColor.Blue, ConsoleColor.Yellow };

  for (int i = 0; i < 1000; i++)
  {
      int p = i % freqs.Length;
      for (int j = 0; j < freqs.Length; j++)
      {
          if (j == p)
          {
              Console.ForegroundColor = colors[p];
          }
          else
          {
              Console.ResetColor();
          }
          Console.SetCursorPosition(j * 3, 0);
          Console.Write("●");
      }
      Console.Beep(freqs[p], 50);

      Thread.Sleep(500 - (p) * 50);
  }
  Console.WriteLine();
#+end_src

* 模拟题
** 继承相关

请问下面程序的输出是什么:
#+begin_src csharp
  class A
  {
      public string name = "aaa";

      public void Name()
      {
          Console.WriteLine("我是 {0}", name);
      }

      public void 自我介绍()
      {
          Name();
      }
  }

  class B : A
  {
      void Name()
      {
          Console.WriteLine("你是 {0}", name);
      }

      string name = "bbb";

      public void 自我介绍()
      {
          this.Name();
          Console.WriteLine("----");
          base.Name();
      }
  }

  class Program
  {
      static void Main()
      {
          B b = new B();
          b.自我介绍();
      }
  }
#+end_src


** 重载 (overload) 和 重写 (override) 有啥区别 (15 分)

重构 = 重新构造 = 将代码进行重写，让结构发生变化的行为
= 一般来说，是因为现有的代码不合理，所以呢，重新调整一下
= 一般来说，重构只是为了改变代码结构或代码质量，它不会对程序的运行逻辑进行改变

* 问题 (仅作参考)
** string 和 StringBuilder 有什么区别

- string 是一种预定义类型，它表达的是字符的有序组合
- StringBuilder 是定义在 BCL 中的类型，它主要用来进行字符串的拼接
- string 是不可变的，所以在进行拼接等操作的时候，效率会非常低
- StringBuilder 是可变的一种类型，所以在字符串拼接的时候，效率相对高多了
- 因此，在进行字符串拼接的操作的时候，我们一般使用 StringBuilder 进行构建，从而提升效率

** 什么是抽象类，抽象类有什么用处
** 什么是接口，什么是面向接口编程，面向接口编程有什么好处
** 什么是静态类，什么是密封类，什么是分部类
** 什么是类，什么是对象，对象的实例化过程是怎么样的
** 什么是面向对象编程，面向对象有什么特点，有什么好处
** 什么是字段，什么是方法，什么是属性。属性有什么好处
** 什么是封装，什么是继承，什么是多态
** 什么是虚方法，它有什么用处
** 什么是组合，它跟继承有什么区别，分别用在什么场景
** 什么是 DRY，代码复用的手段有哪些
** Parse/TryParse 有啥区别

- 这两个都是用来将字符串转换为其他类型
- 遇到转换失败的时候
- Parse 会直接抛出异常
- 而 TryParse，会根据是否转换成功返回 True/False,
  它不会抛出异常

** 什么是装箱拆箱

- 装箱是将值类型转换为 object 的过程
- 拆箱是将装箱后的 object 转换为对应的值类型的过程

** 什么是值类型/引用类型

- 变量位置保存的是类型实例自身，这样的类型叫 *值类型*
- 变量位置保存的是类型实例的引用，这样的类型叫 *引用类型*  

** is/as 分别是干啥的

- is 用来判断左边的实例是否是右边的类型。是的 true，不是的话 false。
  它常用来跟显式转换配合使用
- as 和显式转换相似，但它不会抛出异常，如果成功返回转换结果，失败返回 null


* 代码生成器

- 动软代码生成器
- Codematic 

链接:
- https://www.cnblogs.com/huangguojin/p/5299153.html

* Miscellaneous
** 模拟 Path 寻找的方式

#+begin_src csharp
  var cmd = "sl3";
  
  var f1 = cmd; // 绝对路径 d:\xxx\sl3.exe
  var f2 = Directory.CurrentDirectory() + cmd;
  // 环境变量, 操作系统的全局变量，PATH
  // PATH: dir1;dir2;dir3;dir4  dir5
  string path = "dir1;dir2;dir3;dir4";
  var path_arr = ["dir1", "dir2", "dir3", "dir4"];
  for (var d in path_arr)
  {
      if (File.Exists(d + cmd))
      {
          // 执行
          break;
      }
  }
  // Windows
#+end_src

** 基本思想

方法论:
- 实践中碰都问题，找解决方案。
- 方案找到之后，推而广之，升华到一定的理论。
- 通过理论，再反哺到实践运用当中。

概念:
- OOP (Object-Oriented Programing)
- IoC (Inverse of Control) -- DI/Spring.NET
- ORM (Object-Relation Mapping) -- Entity Framework / NHibernate
- MVC (Model-View-Control) -- .NET MVC

** Relation-Database/SQL

Structured Query Language, 结构化查询语言。

它是操作关系型数据的标准语言。

发展简史:
- 1976 左右，IBM 发表了想法
- 1979 左右，Oracle 给出了实现 (爱里森)
- 1990 左右，SQL 成了工业标准

分类:
- DDL
- DML
- DCL
- TCL

问题:
- SQL 语句的分类有哪些？请做简单介绍
- 函数和存储过程有什么区别？分别用在什么场景
