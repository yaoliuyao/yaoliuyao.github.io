#+TITLE: C♯


* 类跟对象 (Class/Instance)
** 字段 (Field)

- 作为一个字段，最重要的是 (类型) (名字) = (值)
- 可以 *选择性* 使用其他修饰符，为字段增加 *额外* 的功能或限制:
  + 访问修饰符: private/public/protected/internal 等，用来给予外部的访问限制
  + 只读/常量修饰符: const/readonly，用来防止数据被误修改
  + 静态修饰符: static 的作用是，将这个字段的归属权给予类

** 方法 (Method)

方法是一个具备名字的代码块:
- 通过 ~方法名()~ 的方式实现方法调用，
  也就是在调用的地方将方法名代表的代码块里的代码进行运行
- 方法的三要素:
  1. 一个名字 (方法名)
  2. 传入的数据 (传入参数) 入参写在方法名后面的括号里。如果没有入参，括号保持为空即可
  3. 传出的数据 (返回值) 方法内部，使用 return 表示返回的数据。在方法名前面，添加返回的类型。
     如果方法内部没有任何 return 表示方法没有返回值，需要在方法前面添加 void 表示这种情况


方法的重载 (overload):
- 一个类中，可以有同名的方法。需要有不同的参数 (这样才能区分调用)
- 请叙述一下 overload 和 override 有什么区别

方法的示例:
#+begin_src csharp
  class Program
  {
      // 方法的声明、定义
      int 增加 (int a)  // 方法名为 [增加]，入参为 [a]
      {
          return a + 1;  // 返回值为 [a + 1]
      }
      double 加法 (double a, double b) // 可以有多个入参
      {
          return a + b;
      }
      double 没有入参 () // 可以没有入参
      {
          return 111.111; // 返回 double 类型的数据
      }
      void 没有返回数据 (string name) // 没有返回数据使用 void 表示
      {
          Console.WriteLine(name); // 方法体内，没有任何 return 语句，所以方法没有返回任何数据
      }
      void 没有返回值也没有入参 () // 这个方法，就是没有返回值也没有入参
      {
          Console.WriteLine("hello, world");
      }

      // 方法的调用
      // 使用方法的名字调用方法:
      // - 入参的个数和顺序要跟上述定义的一致
      // - 返回值的类型要跟上述定义的一致，如果 void 类型的函数是不能接受其返回值的
      // 上述方法定义中的参数，又叫形式参数 (形参)
      // 这里调用时传入的参数，又叫实际参数 (实参)
      // 也就是，实参要跟形参相对应!
      int a = 增加(11);
      double b = 加法(11, 33);
      double c = 没有入参();
      没有返回数据("H&M");
      没有返回值也没有入参();
  }
#+end_src

** 属性 (Property)

属性本身就是 [private Field + public Method] 一种语法糖:
- 它能减少太多冗余的模板代码；它能简化对实例中数据的可控性的访问，让代码更简洁
- 但是不要忘了，它跟 getter/setter 方法的本质是一样的。最后编译器还是将我们写的属性代码转换成了 getter/setter 方法的形式
- 也就是说 ~r.Width = 333~ 这样的属性赋值，本质就是方法调用

示例:
#+begin_src csharp
  class Rect
  {
      public double Width { get; set; }
      public double Height { get; set; }
      public double Area
      {
          get
          {
              return Width * Height;
          }
      }

      // private double Height;
      // public double GetHeight ()
      // {
      //     return Height;
      // }
      // public void SetHeight (double h);
      // {
      //     Height = h;
      // }
  }

  class Program
  {
      static void Main()
      {
          Rect r = new Rect();
          r.Width = 2000;
          r.Height = 333;
          Console.WriteLine("面积是: {0}", r.Area);
      }
  }
#+end_src

** 构造方法/构造器 (Constructor)

对象的实例化，分为下面几个步骤:
1. 在内存中，分配相应的空间
2. 按照类型进行相关字段的初始化工作
3. 调用相应的 *构造方法*，进行相关初始化工作

所谓的构造方法，就是类中定义的一个特殊方法。它用来对实例空间进行若干初始化工作:   
- 构造方法可以写多个，即可以重载 (overload)
- 我们也可以不写任何构造方法，那么编译器在编译的时候，会自动帮我们插入一个 *无参的空的*。
  但是，如果你在类中，定义了任何的构造方法，那么编译器就不会帮你再生成了

#+begin_src csharp
  class X
  {
      public X()
      {
      }
      public X(int a, int b) // 2
      {
      }
  }

  class Program
  {
      static void Main()
      {
          new X(); // 如果没有参数，那么会调用无参构造器 1
          new X(1, 2); // 回去调用相应的具备两个参数，并且类型正确的构造器 2
      }
  }
#+end_src

** 静态 (Static)

将归属权，交给类。调用的时候，使用 ~类名.xxx~ 方式。

** 将数据设置为不变的 (const/readonly)

: 通过 private 等操作符可以保护数据的外部访问安全
: 通过 const/readonly 可以防止内鬼

const:
- 即常量
- 基于编译期的替换，运行期是没有任何这个变量的信息的
- 相对来说，它不需要占用存储，而且不需要运行时检查，所以效率高
- 它的使用限制较多，比如，只能将一些简单的值赋予它
- 不能添加 static 修饰，但可以使用 ~类名.PI~ 来访问

readonly:
- 限定变量只能读，不能修改
- 可以修饰任何的字段，不管是不是静态的
- 相对来说，需要占用空间、需要运行时检查，效率会低一些
- *注意*，使用 readonly 修饰数组等变量，虽然可以防止数组被重新赋值，但不能避免里面的元素被修改

有内鬼，停止交易:
#+begin_src csharp
  class Congming
  {
      private const double PI = 3.1415926;
      private readonly double pppi = 3.14;

      public double QiuMianJi(double r)
      {
          pppi = 333;  // x
          PI = 333;    // x
          return pppi * r * r;
      }
  }
#+end_src

* BCL (Base-Class Library) 基础类库
** Console

Console.ReadKey:
#+begin_src csharp -n
  Console.WriteLine();
  while (true) // 通过 while 循环可以实现不断输入不断看到输入结果的过程
  {
      // ReadKey 是微软封装在 Console 里的一个方法，用来读取控制台上的按键
      // 我们不需要关心它怎么实现的，我们只需要关心它如何使用
      // 微软在实现里，将我们按下的键的信息，封装到了一个叫 ConsoleKeyInfo 的数据包里 (实例对象)
      // 调用 ReadKey 之后，就可以通过这个实例对象 key 所提供的可访问接口判断按键信息了
      ConsoleKeyInfo key = Console.ReadKey(true); // true 的意思是，不在屏幕上显示键入的字符
      if (key.Key == ConsoleKey.D1)
      {
          Console.WriteLine("您输入了一个 1");
      }
      else if (key.Key == ConsoleKey.S)
      {
          Console.Beep(); // Beep 是微软实现在 Console 里的一个方法，用来让控制台发出声音
      }
      else if (key.KeyChar == 'd')
      {
          Console.Beep(600, 200); // Beep 方法是重载的，它可以携带参数
      }
      else if (key.KeyChar == 'f')
      {
          Console.Beep(200, 200);
      }
      else if (key.Key == ConsoleKey.Enter)
      {
          break;
      }
      else
      {
          Console.WriteLine($"key: {key}, keyChar: {key.KeyChar}, key: {key.Key}");
      }
  }
#+end_src

* 其他

#+begin_src csharp
  string aFriend = "比尔";
  string bFriend = "小明";
  Console.WriteLine("Hello {1}, 我是 {0}", aFriend, bFriend);
  Console.WriteLine($"Hello {bFriend}, 我是 {aFriend}");
  Console.WriteLine("Hello " + bFriend + ", 我是 " + aFriend);

  Console.WriteLine("Hello " + bFriend + ", 我有 " + (aFriend.Length + 3) + " 长");
  Console.WriteLine($"Hello {bFriend}, 我有 {aFriend.Length + 3} 长");

  string greeting = "      Hello World!       ";
  string greetingTrimed = greeting.Trim();
  Console.WriteLine($"[{greetingTrimed},{greeting}]");

  string songLyrics = "You say goodbye, and I say hello";
  Console.WriteLine(songLyrics.Contains("goodbye"));
  Console.WriteLine(songLyrics.Contains("greetings"));
  Console.WriteLine(songLyrics.StartsWith("You"));
  Console.WriteLine(songLyrics.EndsWith("goodbye"));
#+end_src
