 #+TITLE: C♯


* 历史

- Visual J++ 被放弃，[[https://baike.baidu.com/item/%E5%AE%89%E5%BE%B7%E6%96%AF%C2%B7%E6%B5%B7%E5%B0%94%E6%96%AF%E4%BC%AF%E6%A0%BC][安德斯·海尔斯伯格]]带领团队从 2000 年左右开始开发了 C#，到 2002 年的的时候，开始提交给 ECMA 成为了标准
- 因为安德斯他的个人经历，所以 C# 深受 Pascal/C++/Java 的影响
- 到现在，C# 已经成为了一种多范式的语言。首先它是一门纯粹的面向对象的语言 (封装、继承、多态)，提供了面向组件编程的一些改进 (属性、委托、事件)

C# 版本演化:
- 1.0 纯粹的面向对象 (2002)
- 2.0 增加了泛型的概念 (2005)
- 3.0 增加了 LINQ 功能 (2008)
- 4.0 增加了命名参数和可选参数的功能，并添加了动态编程的支持 (2010)
- 5.0 增加了 async/await 的异步编程范式 (2012)
- 6.0 推进了跟 .NET Core 的语言共享 (2015)
- 7.0 添加了函数式编程的一些特性，如果模式匹配、元组等等，包括其他一些优化 (2017)
- 8.0 开始支持默认接口方法，可空引用类型，switch 表达式等 (2019)
- 9.0 增加了 Record 类型，继续对 switch 表达式等进行简化跟优化 (2021)

* [语言与类型]

在 C# 等面向对象的语言中，*类型 (Type)* 是第一位的
- 在 C# 中，不外乎做两件事，第一件是引入别人的类型，第二件是声明自己的类型
- 也就是说，整个 C# 项目，是由不同的 *类型声明* 组成的
- 在整个 C# 项目中，需要 *有且只有一个* 特殊的方法，就是 Main 方法。它是程序执行的起点
- 通过引入 *命名空间 (namespace)* 的概念，用来组织各种类型，从而避免命名冲突

#+ATTR_HTML: :width 400px
[[file:img/types.png]]

#+ATTR_HTML: :width 400px
[[file:img/types-2.png]]

** Main

#+begin_src csharp
  static int Main (string[] args)
  {
      return 如果正常返回则是 0，否则是一个整数代表错误编号;
  }

  static void Main (string[] args)
  {
      // 如果真的不关心返回的错误编号的话，可以将返回值设置为 void

      // 可以使用 args 来捕获从控制台输入的参数 (用空格分隔的元素)
      if (args.Length > 0 && args[0] == "--help")
      {
          Console.WriteLine("使用方式: ./Program");
      }
  }

  static void Main ()
  {
      // 如果你真的不在乎传入参数的话，那么将 args 省略掉也可以
  }

  static async void Main()
  {
      await CCCAync();
      await AAA();
      await BBB();
      DDD();
  }
#+end_src

args 使用的另一个示例:
#+begin_src csharp
  static void Main(string[] args)
  {
      if (args.Length == 1)
      {
          if (args[0] == "--help")
          {

              Console.WriteLine("使用方法: dotnet run 2223");
          }
          else
          {
              double bill = double.Parse(args[0]);
              var calc = new TipCalculator(bill);
              calc.PrintToConsole();
          }
      }
      else
      {
          Console.WriteLine("参数错误.");
      }
  }
#+end_src

** 命名空间

- 用来解决类型名字的冲突
- 用来合理组织类型

*** 使用

#+begin_src csharp
  // 类型的使用，可以通过 namespace.类型 来访问到 / full name
  System.String aaa = System.IO.File.ReadAllText("e:\\aaa.txt");
  System.Console.WriteLine(aaa);
  System.Console.WriteLine("hello");

  // 可以借助 using 命名空间的方式，简化类型的使用
  using System;
  using System.IO;
  string aaa = File.ReadAllText("e:\\aaa.txt");
  Console.WriteLine(aaa);
  Console.WriteLine("hello");

  // 可以使用 using static 的语法继续进行简化
  using static System.Console;
  using static System.IO.File;
  string aaa = ReadAllText("e:\\aaa.txt");
  WriteLine(aaa);
  WriteLine("hello");

  // 可以使用 using = 的方式，为命名空间起一个别名。这种方式一般用来解决冲突
  using SI = System.IO;
  using HisSystem;
  SI.File.xxx();  // System.IO.File.xxx();
  File.xxx();     // HisSystem.FIle.xxx();
#+end_src

*** 定义

支持嵌套，支持使用 . 的形式进行简写:
#+begin_src csharp
  using SI = System.IO; // File

  namespace TaxCalculator
  {
      namespace Hi
      {
          namespace Ih // TaxCalculator.Hi.Ih.Boy
          {
              class Boy
              {
              }
          }
          class Girl // TaxCalculator.Hi.Girl
          {
          }
      }

      namespace A.B.C.D.E.F
      {
          namespace G.H.X
          {
              using static System.Console;
              namespace Y
              {
                  class Hello
                  {
                      void Say()
                      {
                          WriteLine("hello");
                      }
                  }
              }
          }
      }

      namespace B
      {
          using System;
          class Program // TaxCalculator.Program
          {
              static void Main()
              {
                  string aaa = SI.File.ReadAllText("e:\\aaa.txt");
                  Console.WriteLine(aaa);
                  Console.WriteLine("hello");
              }
          }
      }
  }
#+end_src

*** BCL/System

System 命名空间:
- System.IO (Input/Output), 文件的处理
- System.Drawing, 绘制图片
- System.Collections，集合类型
- System.Net，网络访问
- System.Text，跟文本相关的内容，比如正则表达式
- System.Threading，多线程
- System.Threading.Tasks，异步编程

** 模板 vs 实例

类型就是用来创建数据结构的一种 *模板*：
- 类型本身并不是真正的数据，它只是描述了数据应该怎么被构造出来
- 类型它需要有名字，占用的空间，包括一系列的属性和行为

通过某个类型模板创建实际的对象，称作 *实例化* 该类型:
- 它就是真正的数据。类型的实例，类型的对象。所有的数据都是要根据类型创建出来的
- 类型的话，要么是平台预定义的，要么是 BCL/FCL 中定义的，要么是你自己声明的

#+begin_src csharp
  // 1 声明
  class xxx
  {
      int age;
      string name;
  }
  class yyy
  {
      int i;
      xxx xxx; // 2 使用
  }

  new yyy(); // 2 使用

  int a = 333; // 不需要声明，直接实例化
#+end_src

** 值类型 vs 引用类型

内存分为两部分:
- 栈 (Stack)，速度快
- 堆 (Heap)，容积大

#+ATTR_HTML: :width 500px
[[file:img/value-type-ref-type.png]]

** [条件判断/分支]

- 规则 (rule)

if:
#+begin_src csharp
  // if
  if (bool)
  {
  }

  // if / else
  if (bool)
  {
  }
  else
  {
  }

  // if / else if / ... / else
  if (bool)
  {
  }
  else if (bool)
  {
  }
  else if (bool)
  {
  }
  else if (bool)
  {
  }
  else if (bool)
  {
  }
  else
  {
  }
#+end_src

switch:
#+begin_src csharp
  switch (exp)
  {
      case a:
          做什么;
          break;
      case b:
          做什么;
          break;
  }
#+end_src

* 预定义/数值类型
** 整数

为了表示显示世界中的计算，人们发明了数字的记法:
- 通用的计算方式是 *十进制* (因为人自古来来，都有十根手指头)
- 计算机内部使用的是 *二进制* (因为使用电子元件状态表达 0/1 是最简单的)
- 人们一般使用 *十六进制* 来描述计算机中的二进制 (其表达能力更强，且能跟字节为单位的二进制形成对应关系)

为了能在计算机中有效存储整数，C# 中预定义了如下类型:
- byte (字节，使用 8bit 表示，它的表现能力最差，只有 0 ~ 255)
- short (短整数，使用 2Byte 表示，能表示到 3 万大小)
- int (整数，4B 长度，能表达到 20 多亿)
- long (长整数，16B 长度，能表达到亿亿的单位)

另外，考虑是否设置符号位 (Sign/Unsign)，上面的类型又有对应的类型:
- sbyte
- ushort
- uint
- ulong

上述的类型都是用来创建整数数据的模板，它们的区别在于占用空间和表达里。
选择类型的根据是:
- 占用小的，表达能力差；占用大的，表达能力强
- 在业务的允许范围内，尽量选择占用空间小的类型
- 如果不好决定使用声明类型，优先使用 int

整数:
#+begin_src csharp
  byte aa = 0;
  byte az = 255;
  sbyte ba = -128;
  sbyte bz = 127;

  short s1 = -32768;
  short s2 = 32767;
  ushort s3 = 0;
  ushort s4 = 65535;

  int i1 = -2147483648;
  int i2 = 21_4748_3647;
  uint i3 = 42_9496_7295;

  long l1 = 3232323232335555355;
  ulong l2 = 23333333333333333;

  Console.WriteLine(0.1 + 0.2);
  Console.WriteLine(100 * 0.28);
  Console.WriteLine(100 * 0.27);

  byte a = 1;
  short b = 1;
  int c = 1;
  long d = 1;

  // C# 现在允许使用分隔符描述数字，这样具备更好的可读性
  long xxx = 11_1161_1311_4441_2323;
  int yyy = 2323;
#+end_src

可以直接使用二进制/十六进制的方式描述数字:
#+begin_src csharp
  byte zzz = 0b11111111;
  Console.WriteLine(zzz);

  // 16 进制 10 2 
  // 0,1,10,11,100,101,110,111
  // 1,2,..9,10,11,12..19
  // 1, 2,...9, a, b, c, d, e, f / 15, 1111
  // 10, 11, 12 .. 1e, 1f     0001_1111
  // 20,...............2f
  // 30................3f
  //                   9f
  // a0................af
  // b0................bf
  // c0................cf
  // d0................df
  // e0................ef
  // f0..............fe.ff 256 1111_1111
  // 100 .. 101. .....

  Console.WriteLine(0b11111111_11111110_11111111);
  Console.WriteLine(0x1e);
  Console.WriteLine(0xff_fe_ab_12);
  Console.WriteLine(2222323);
#+end_src

#+ATTR_HTML: :width 400px
[[file:img/integers.png]]

** 浮点数

- 根据存储形式，分为单精度 (float) 和双精度 (double)
- *float* 使用 32bit 来存储 (1 个符号位 8 个指数位 23 个尾数)
- *double* 使用 64bit 来存储 (1 个符号位 11 个指数位 52 个尾数)
- 一个小数，转换为计算机存储的形式，难免会有精度的损失。因此
  + 0.1 + 0.2 ≠ 0.3
  + 0.6 + 0.7 = 1.2999999999999998
  + 0.28 * 100 = 28.000000000000004
- 可以使用 *decimal* 类型，来表示更加精确的数值计算
  + 它的优点是，可以进行精确的计算
  + 它的缺点是，它需要占用更大的存储空间 (128bit)

#+ATTR_HTML: :width 500px
[[file:img/float-type.png]]

** Literate (字面量表达)

#+begin_src csharp
  // 字面量
  // 1112 int
  // 1112L long
  // 1112UL Unsigned Long
  // 1112F float
  // 1112.0 double
  // 1112M decimal
  Console.WriteLine(0.1M + 0.2M);

  double a = 2222;
  float b1 = 33332332323233;
  float b2 = 2323F;
  decimal c = 3.222M;

  int x = 333;
  long y1 = 54444;
  long y2 = 54444L;
#+end_src

* 预定义/非数值·值类型
** 字符类型 (char)

字符集/编码格式:
+ 最原始的英文中的 *ASCII* 编码
+ 后来出现的，各个国家的，比如 *GBK*
+ 为了消除字符集冲突，出现的 *Unicode* 组织跟字符集。并根据字符集出现了 *UTF-16/UTF-8* 等编码格式

Q & A:
- ucs-2 vs UTF-16 ????
- UTF8 怎么的格式 ????

#+ATTR_HTML: :width 500px
[[file:img/unicode.png]]

因此，在 C# 中内部，字符是使用 UTF-16 格式存储的。
#+begin_src csharp
  char a = 'x';

  char a = 'x';
  char b = '中';
  char c = '☺';
  char d = '⁞';
#+end_src

** 布尔类型 (bool)

* 预定义/非数值·引用类型
** string

字符串，是由字符序列组成的一种数据结构。

*** 字符串的长度

#+begin_src csharp
  string s1 = "aaa";
  string s2 = "您好aaa";
  string s3 = "𠈓好aaa";

  Console.WriteLine(s1.Length); // 由多少个字符组成
  Console.WriteLine(s2.Length);
  Console.WriteLine(s3.Length); // 这个为什么是 6 ?

  string s4 = "中国𠈓您好𠈓blahblaah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjlah中华𠈓你们都是啥kdjfkdjkdfdkjf";
  Console.WriteLine(s4.Length);
  Console.WriteLine(new StringInfo(s4).LengthInTextElements);
#+end_src

*** 字符串的初始化

#+begin_src csharp
  string g1 = "Hello World!";
  System.String g2 = "Hello World!";
  var g3 = "Hello World!";

  string message1;
  string message2 = null;
  string message3 = String.Empty; // string message3 = "";
  string oldPath = "Path:\nc:\\Program Files\\Microsoft Visual Studio 8.0";
  string newPath = @"Path:
  c:\Program Files\Microsoft Visual Studio 9.0";

  char[] letters = { 'A', 'B', 'C' };
  string alphabet = new string(letters);
#+end_src

*** 字符串的不可变性 (Immutable)
**** what & why

#+begin_src csharp
  int a;
  string b;


  int i = 1; // int i; i = 1;
  int j = 23;
  i += j; // i = i + j; i = 24;

  string s = "h";
  string t = "w";
  s += t; // s = s + t;
#+end_src

#+ATTR_HTML: :width 400px
[[file:img/string-immute.png]]


字符串是不可更改的:
#+begin_src csharp
  string s = "hello";
  Console.WriteLine(s[1]); // 可以通过这种方式读取字符串的某个位置
  s[1] = 'x';              // 这一句是错误的
#+end_src

思考:
- 为什么要搞成不可变的 ?
- 不可变能带来什么好处 ?

**** System.Text.StringBuilder

这是 BCL 中提供的一个类，专门使用在 *字符串拼接* 的场景下。

因为，在预定义的字符串实现中，字符串拼接 (+=) 是非常低效的一种行为 (要去理解为什么)。

#+ATTR_HTML: :width 500px
[[file:img/string-vs-stringbuilder.png]]

#+begin_src csharp
  using System.Text;

  // 解析一下，为什么这段代码会为内存带来大量的垃圾
  string s = "hello";
  for (int i = 0; i < 1000; i++)
  {
      s += ".";
      Console.WriteLine(s);
  }

  // 要理解，为什么 StringBuilder 会占用更少的空间
  // 如何理性看待 String vs StringBuilder 两种类型
  StringBuilder sb = new StringBuilder("hello");
  for (int i = 0; i < 1000; i++)
  {
      sb.Append(".");
      Console.WriteLine(sb);
  }

  if (s == sb.ToString())
  {
      Console.WriteLine("哈哈，一样啊");
  }
#+end_src

**** String Intern Pool (字符串池)

因为字符串是不可变的，所以在字符串的操作中，会产生很多临时字符串 (垃圾)。

在实际使用中，有很多字符串我们会反复去使用的，所以为了避免重复进行字符串的创建，
会对字符串操作过程中产生的字符串进行缓存管理，即创建一个字符串池管理它们。

后续进行字符串的声明时，会优先到池中寻找，如果已经存在，那么直接使用它。

字符串池的根本原因是，字符串是不可变的。

#+begin_src csharp
  string a = "hello";
  string b = "hel";
  string c = "lo";
  string d = b + c;
  string e = "hello";
  
  // 使用 == 判断，两个字符串的值是不是一样的
  Console.WriteLine(a == d); // True
  Console.WriteLine(a == e); // True
  
  // 使用 object.ReferenceEquals 判定是否占用了相同的内存空间
  Console.WriteLine(object.ReferenceEquals(a, d)); // False
  Console.WriteLine(object.ReferenceEquals(a, e)); // True
  
  // 注意，类比 Java:
  // a == b 判断的是 a 跟 b 是否是同一个引用
  // a.equals(b) 用来判断 a 跟 b 的值是不是一样的
  //
  // string a = null;
  // string b = "hello";
  // a.equals(b) -> b.equals(a);
  // "hello".equal(a); (1)
  // if (a != null) a.equal("hello"); (2)
#+end_src

*** [API] 拼接 + 格式化

#+begin_src csharp
  string name = "tom";
  string friend = "jerry";
  int age = 30;
  decimal sal = 200.12345M;
  
  string r1 = name + "的朋友是"
                   + friend + "，它虽然只有" 
                   + age + "岁，但是它的收入能到达到"
                   + sal + "刀";
  
  string r2 = new StringBuilder()
      .Append(name)
      .Append("的朋友是")
      .Append(friend)
      .Append("，它虽然只有")
      .Append(age)
      .Append("岁，但是它的收入能到达到")
      .Append(sal)
      .Append("刀")
      .ToString();
  
  string r3 = string.Format("{0}的朋友是{1}，它虽然只有{2}岁，但是它的收入达到{3:C}", name, friend, age, sal);
  
  // {变量,对齐多少长度:格式}
  // [对齐] 正数表示右对齐，负数表示左对齐
  // [格式] P 百分比 C 货币 E 科学计数法 D 补齐长度 F/N 小数点多少位 X 十六进制
  string r4 = $"{name}的朋友是{friend}，它虽然只有{age:d5}岁，但是它的收入达到{sal:C}!";
  
  // 语言-国家或区域
  // zh-CN
  // en-US
  // en-EN
  string ss = sal.ToString("C", new CultureInfo("en-US"));
  string r5 = $"{name}的朋友是{friend}，它虽然只有{age:d5}岁，但是它的收入达到{ss}!";
  
  Console.WriteLine(r5);
#+end_src

*** [API] 子字符串

#+begin_src csharp
  string s1 = "000o。OOOoOO0O0Ooo000o";
  
  // 取
  char c = s1[1]; // 取字符
  string s2 = s1.Substring(1, 2); // 位置，长度 : el
  string s3 = s1.Substring(2);    // 从某个位置到最后
  string s4 = s1.Substring(2, 0); // String.Empty ""
  
  // 判
  bool b1 = s1.Contains("o0");    // 是否包含一个子字符串
  bool b2 = s1.StartsWith("o");   // 是不是以 x 开始
  bool b3 = s1.EndsWith("o");     // 是不是以 x 结束的
  
  // 序
  int i1 = s1.IndexOf("O");
  int i2 = s1.LastIndexOf("O");
  int i3 = s1.IndexOfAny(new []{'o', 'O'});
  
  // 结合
  string path = "C:/aaa/work.x/hello.txt";
  string drive = path.Substring(0, path.IndexOf(":"));
  string dir = path.Substring(0, path.LastIndexOf("/") + 1);
  string file = path.Substring(path.LastIndexOf("/") + 1);
  string ext = path.Substring(path.LastIndexOf(".") + 1);
  
  // 自定义版本的 LastIndexOf
  int p = 0;
  for (int i = path.Length - 1; i >= 0; i--)
  {
      if (path[i] == '/')
      {
          p = i;
          break;
      }
  }
  string dir2 = path.Substring(0, p);
  
  Console.WriteLine(dir2);
#+end_src

*** [API] 字符串的修改

#+begin_src csharp
  // 谨记:
  // 修改不会作用在原先的字符串上
  // 所有的修改，都是返回了一个完全崭新的字符串
  
  string s1 = "  000o。OOOoOO0O，0Ooo000o--";
  
  string s2 = s1.Insert(3, ">>>");
  string s3 = s1.Remove(2, 1);
  string s4 = s1.Replace("。", ".");
  string s5 = s1.Replace('，', '_');
  string s6 = s1.Replace("OoO", "111");
  string s7 = s1.Replace("OoO", "222", true, new CultureInfo("zh-CN"));
  
  string s8 = s1.PadLeft(100);
  string s9 = s1.PadLeft(100, '-');
  string sa = s1.PadRight(100, '-');
  
  string sb = s1.Trim();
  string sc = s1.Trim('-');
  string sd = s1.TrimStart();
  string de = s1.TrimStart().TrimEnd('-').PadLeft(50, ':');

  string df = s1.ToLower();
  string dg = s1.ToUpper();
  
  Console.WriteLine(de);
#+end_src

*** [API] String 跟 Array 的转换

#+begin_src csharp
  string s1 = "  000o。OOOoOO0O，0Ooo000o--";
  
  // 字符串到 [数组] 的转换
  char[] a1 = s1.ToCharArray();
  char[] a2 = s1.ToCharArray(2, 10);
  
  // [数组] 到字符串的转换
  char[] a3 = new[] {'a', 'o', 'e'};
  string s2 = new string(a3);
  
  // StringBuild vs String
  string s3 = new StringBuilder().Append("hello").ToString();
  StringBuilder sb = new StringBuilder(s1);
#+end_src

*** [API] 其他

#+begin_src csharp
  string s = "hello";
  s.Xxx();
#+end_src

子字符串:
#+begin_src csharp
  // 获取/创建一个子字符串 (3-5)
  string a = "longlonglonglonglong: string .. ";
  
  // 判断，某个字符串中是否包含某个字符串 a "world"
  // 寻找相应的位置
  // 判断出现的次数
  // 替换 WORLD
  // 分割 / 合并
#+end_src

** object
** dynamic
* [自定义类型]
** class

类

** interface

接口

** delegate

委托

** array

数组

** record

记录

** struct

结构体

** enum

枚举

* 类 (Class)
** 字段 (Field)

- 作为一个字段，最重要的是 (类型) (名字) = (值)
- 可以 *选择性* 使用其他修饰符，为字段增加 *额外* 的功能或限制:
  + 访问修饰符: private/public/protected/internal 等，用来给予外部的访问限制
  + 只读/常量修饰符: const/readonly，用来防止数据被误修改
  + 静态修饰符: static 的作用是，将这个字段的归属权给予类

** 方法 (Method)

方法是一个具备名字的代码块:
- 通过 ~方法名()~ 的方式实现方法调用，
  也就是在调用的地方将方法名代表的代码块里的代码进行运行
- 方法的三要素:
  1. 一个名字 (方法名)
  2. 传入的数据 (传入参数) 入参写在方法名后面的括号里。如果没有入参，括号保持为空即可
  3. 传出的数据 (返回值) 方法内部，使用 return 表示返回的数据。在方法名前面，添加返回的类型。
     如果方法内部没有任何 return 表示方法没有返回值，需要在方法前面添加 void 表示这种情况


方法的重载 (overload):
- 一个类中，可以有同名的方法。需要有不同的参数 (这样才能区分调用)
- 请叙述一下 overload 和 override 有什么区别

方法的示例:
#+begin_src csharp
  class Program
  {
      // 方法的声明、定义
      int 增加 (int a)  // 方法名为 [增加]，入参为 [a]
      {
          return a + 1;  // 返回值为 [a + 1]
      }
      double 加法 (double a, double b) // 可以有多个入参
      {
          return a + b;
      }
      double 没有入参 () // 可以没有入参
      {
          return 111.111; // 返回 double 类型的数据
      }
      void 没有返回数据 (string name) // 没有返回数据使用 void 表示
      {
          Console.WriteLine(name); // 方法体内，没有任何 return 语句，所以方法没有返回任何数据
      }
      void 没有返回值也没有入参 () // 这个方法，就是没有返回值也没有入参
      {
          Console.WriteLine("hello, world");
      }

      // 方法的调用
      // 使用方法的名字调用方法:
      // - 入参的个数和顺序要跟上述定义的一致
      // - 返回值的类型要跟上述定义的一致，如果 void 类型的函数是不能接受其返回值的
      // 上述方法定义中的参数，又叫形式参数 (形参)
      // 这里调用时传入的参数，又叫实际参数 (实参)
      // 也就是，实参要跟形参相对应!
      int a = 增加(11);
      double b = 加法(11, 33);
      double c = 没有入参();
      没有返回数据("H&M");
      没有返回值也没有入参();
  }
#+end_src

** 属性 (Property)

属性本身就是 [private Field + public Method] 一种语法糖:
- 它能减少太多冗余的模板代码；它能简化对实例中数据的可控性的访问，让代码更简洁
- 但是不要忘了，它跟 getter/setter 方法的本质是一样的。最后编译器还是将我们写的属性代码转换成了 getter/setter 方法的形式
- 也就是说 ~r.Width = 333~ 这样的属性赋值，本质就是方法调用

示例:
#+begin_src csharp
  class Rect
  {
      public double Width { get; set; }
      public double Height { get; set; }
      public double Area
      {
          get
          {
              return Width * Height;
          }
      }

      // private double Height;
      // public double GetHeight ()
      // {
      //     return Height;
      // }
      // public void SetHeight (double h);
      // {
      //     Height = h;
      // }
  }

  class Program
  {
      static void Main()
      {
          Rect r = new Rect();
          r.Width = 2000;
          r.Height = 333;
          Console.WriteLine("面积是: {0}", r.Area);
      }
  }
#+end_src

** 构造方法/构造器 (Constructor)
*** 对象的实例化

对象的实例化，分为下面几个步骤:
1. 在内存中，分配相应的空间
2. 按照类型进行相关字段的初始化工作
3. 调用相应的 *构造方法*，进行相关初始化工作

*** 构造器

所谓的构造方法，就是类中定义的一个特殊方法。它用来对实例空间进行若干初始化工作:   
- 构造方法可以写多个，即可以重载 (overload)
- 我们也可以不写任何构造方法，那么编译器在编译的时候，会自动帮我们插入一个 *无参的空的*。
  但是，如果你在类中，定义了任何的构造方法，那么编译器就不会帮你再生成了

#+begin_src csharp
  class X
  {
      public X()
      {
      }
      public X(int a, int b) // 2
      {
      }
  }

  class Program
  {
      static void Main()
      {
          new X(); // 如果没有参数，那么会调用无参构造器 1
          new X(1, 2); // 回去调用相应的具备两个参数，并且类型正确的构造器 2
      }
  }
#+end_src

*** 构造器链

- 如果不显式继承某个类，那么继承的将是 object。即可以忽略掉 ~: Object~
- 如果不显式添加构造器，那么编译器会自动插入一个无参的。即可以省略掉 ~public Son() {}~
- 如果不显式指定构造器顺序，那么任意构造器都会首先执行父类的无参构造器。即可以省略掉 ~: base()~
- 显式指定构造器顺序，需要手动添加 ~: base(xxx)~ 或者 ~: this(xxx)~
- 基本的规则是: 从下往上寻找，然后从上往下执行。这样就构成了 *构造器链*

#+begin_src csharp
  class GP
  {
      public GP() : base() // 4
      {
          Console.WriteLine("我是你爷爷");
      }
      public GP(string address) : base()
      {
          Console.WriteLine("爷爷我的地址是 {0}", address);
      }
      public GP(string name, string address) : base()
      {
          Console.WriteLine("爷爷 {0} 的地址是 {0}", name, address);
      }
  }
  class PP : GP
  {
      public PP() : base()
      {
          Console.WriteLine("我是爸爸");
      }
      public PP(string address) : base() // 3
      {
          Console.WriteLine("爸爸我的地址是 {0}", address);
      }
      public PP(string name, string address) : base()
      {
          Console.WriteLine("爸爸 {0} 的地址是 {0}", name, address);
      }

  }
  class You : PP
  {
      public You() : base()
      {
          Console.WriteLine("我的儿子");
      }
      public You(string name) : this(name, "广西") // 1
      {
          Console.WriteLine(name);
      }
      public You(string name, string addr) : base(addr) // 2
      {
          Console.WriteLine("{0} 的 {1}", addr, name);
      }

  }
  class Son : You
  {
  }

  You u = new You("张三");
#+end_src

*** 静态构造器

- 构造器是用来初始化 *对象* 的
- 静态构造器是用来初始化 *类* 的
- 对象的初始化工作，是在代码中通过 new Class 的方式触发的
- 类的初始化工作，是由 CLR 自动执行的，一般来说，你第一次使用到某个类的时候，这个类就会 *被* 自动加载
- 静态的构造器，只能有一个，而且不能带任何参数

#+begin_src csharp
  class TipCalculator : CalculatorBase
  {
      static TipCalculator()
      {
          Console.WriteLine("我是一个带 static 的构造器");
      }
  }
#+end_src

** 析构方法/析构器 (Deconstructor)

#+begin_src csharp
  ~TipCalculator()
  {
      Console.WriteLine("我死的好惨啊");
  }

  ~文件()
  {
      this.Close();
  }
#+end_src

** 静态方法 (Static)

将归属权，交给类。调用的时候，使用 ~类名.xxx~ 方式。

** 将数据设置为不变的 (const/readonly)

: 通过 private 等操作符可以保护数据的外部访问安全
: 通过 const/readonly 可以防止内鬼

const:
- 即常量
- 基于编译期的替换，运行期是没有任何这个变量的信息的
- 相对来说，它不需要占用存储，而且不需要运行时检查，所以效率高
- 它的使用限制较多，比如，只能将一些简单的值赋予它
- 不能添加 static 修饰，但可以使用 ~类名.PI~ 来访问

readonly:
- 限定变量只能读，不能修改
- 可以修饰任何的字段，不管是不是静态的
- 相对来说，需要占用空间、需要运行时检查，效率会低一些
- *注意*，使用 readonly 修饰数组等变量，虽然可以防止数组被重新赋值，但不能避免里面的元素被修改

有内鬼，停止交易:
#+begin_src csharp
  class Congming
  {
      private const double PI = 3.1415926;
      private readonly double pppi = 3.14;

      public double QiuMianJi(double r)
      {
          pppi = 333;  // x
          PI = 333;    // x
          return pppi * r * r;
      }
  }
#+end_src

** 继承 (Inheritance)

- 继承表示，我的是我的，你的也是我的。使用 ~:~ 语法表示继承关系
- 继承主要用来消除冗余，让逻辑得以 *复用*。逻辑上来说，跟自然界的分门别类是对应一致的
- new 对象的时候，会 *开辟空间、初始化字段、调用构造器*。如果存在继承关系的话，创建的实例是分为多部分的
- 调用实例上的某个方法 A，如果 A 调用了另一个方法 B，这时候，优先会使用 A 自身部分上面定义的 B。
  如果想让 A 调用的 B 是派生类 *最下面* 的 B 的话，使用 ~virutal/override~ 将 B 设置为 *虚函数* 即可。
  子类中存在的相同方法，如果不是 override 的，那么将会是 new 的。new 可以不写
- 在 C# 中，只允许有一个父类，即 *单继承*
- 所有类的根基类是 *object*。object 中定义了 ToString/GetType/Equal 等方法。因此，所有的对象都拥有这几个方法
- 在方法中，使用 *this* 表示当前的对象，使用 *base* 表示父类部分。base.Xxx 表示调用父类部分的 Xxx
- 使用 private 修饰的数据不能被继承使用，这时候应该使用 *protected*

基本语法:
#+begin_src csharp
  class A : object { void Say() {Console.WriteLine("hello");} }
  class B : A {}
  class C : B { void Say() {Console.WriteLine("world");} }
  class D : C {}
  D d = new D();
  d.Say();
#+end_src

*** 虚方法 (virtual/override)

虚函数:
#+begin_src csharp
  class A
  {
      public string Name() { return "hello"; }
      public void Say() { Console.WriteLine(this.Name()); }
  }
  class B : A
  {
      public virtual string Name() { return "world"; }
      public new void Say() { Console.WriteLine("heihei" + Name()); base.Say(); }
  }
  class C : B
  {
      public override string Name() { return "who"; }
      public virtual void Say() { Console.WriteLine("hahaha" + Name()); }
  }
  class D : C
  {
      public override string Name() { return "ryou"; }
  }
  var d = new D();
  d.Say();
#+end_src

虚不虚?
#+begin_src csharp
  class A
  {
      public string Name() { return "hello"; }
      public virtual void Say() { Console.WriteLine(this.Name()); }
  }
  class B : A
  {
      public new virtual string Name() { return "world"; }
      public override void Say() { Console.WriteLine("heihei" + Name()); base.Say(); }
  }
  class C : B
  {
      public override string Name() { return "who"; }
      public override void Say() { Console.WriteLine("hahaha" + Name()); }
  }
  class D : C
  {
      public override string Name() { return "ryou"; }
  }

  A a = new D();
  a.Say();
#+end_src

#+begin_src csharp
  class GrandPP
  {

  }
  class PP : GrandPP
  {

  }
  class You : PP
  {
      public You()
      {
          Console.WriteLine(".");
      }
      public You(string name)
      {
          Console.WriteLine(name);
      }
      public You(string name, string addr)
      {
          Console.WriteLine(name + ":" + addr);
      }

  }
  new You();
  new You("张三");
  new You("张三", "湖南");
#+end_src

*** 抽象方法 (abstract)

- 继承下来的，不一定是权利，也有可能是义务。俗语有云 *父债子偿*
- 通过在父类中，将某个方法用 ~abstract~ 修饰，表示它是债务...
- 抽象方法可以 (1) 约束子类的行为 (2) 将父类中无法实现的功能，交给子类去实现
- 抽象类是不能被实例化的

#+begin_src csharp
  abstract class Baba
  {
      public double Money = 0.1;

      public virtual void Sanjuhua()
      {
          Console.WriteLine("漂亮的女孩子都比较危险");
          Console.WriteLine("我有很多钱，藏在某个地方");
          Console.WriteLine("但我不告诉你在哪里");
      }

      public abstract void 花光这些钱();
  }

  class You : Baba
  {
      public override void Sanjuhua()
      {
          Console.WriteLine("漂亮的女孩子是值得我们花一生去追求的");
          Console.WriteLine("我有很多钱，就放在中国银行的钱库里");
          Console.WriteLine("但不要把钱放眼里，作为真男人，要敢于 996，奉献人生价值");
      }

      public override void 花光这些钱()
      {
          Console.WriteLine("第一天，花了 3 亿");
          Console.WriteLine("第二天，花了 33 亿");
          Console.WriteLine("第三天，花了 333 亿");
          Console.WriteLine("第四天，梦醒了");
      }
  }
#+end_src

** 多态 (Polymorphism)

多态是一个来自生物学上的概念，[[https://baike.baidu.com/item/%E5%A4%9A%E6%80%81%E7%8E%B0%E8%B1%A1][参见百度百科]]:
- 在语言中，多态指调用同一个类型的相同方法/属性，会产生不同结果的现象。
  产生不同结果的原因是方法实质调用了不同派生类中的不同实现。
- 虚方法是实现多态性的主要手段，接口和抽象类是多态的充分体现

#+begin_src csharp
  // 批量处理 (关心的是共性)

  Animal[] animals = new Animal[3];
  animals[0] = new Animal();
  animals[1] = new 美女();
  animals[2] = new 野兽();

  for (int i = 0; i < animals.Length; i++)
  {
      Animal a = animals[i];
      a.Eat();
      a.Sleep();
      a.WakeUp();
      a.Drink();
  }

  // 适配的参数类型
  interface 能干活的东西 { void 干活(); }
  class 人 : 能干活的东西 { void 干活 () { ... }; }
  class 猪 : 能干活的东西 { void 干活 () { ... }; }

  void 招聘 (能干活的东西 x) {
      x.干活();
  }
  招聘(人);
  招聘(猪);

  // 适配的返回值 (约定跟实现的和谐)

  Dog GiveADog()
  {
      return new 二哈();
  }
  Animal aaa = GiveADog();

  // 接口与多态

  IHelpable xxx = new TipCalculator(222);
  xxx.Help();
#+end_src

** 静态类/static

限制里面所有的方法，必须是静态的。典型的代表是 Math 类。

** 密封类/sealed

这就从语法上，避免了某个类被继承的可能。

** 分部类/partial

让类可以写成多部分。在编译的环节，编译器将会帮助我们自动合并之后再编译。

#+begin_src csharp
  partial class MyLove
  {
      public void 你想我吗()
      {
      }
  }

  partial class MyLove
  {
      public void 我想你()
      {
      }
  }
#+end_src

** 基类 Object
*** ToString

#+begin_src csharp
  class TipCalculator : CalculatorBase
  {
      public override string ToString()
      {
          return $"我是一个账单类，传入的参数是 {Bill}";
      }
  }
  Console.WriteLine("{0}", new TipCalculator(200));
#+end_src

* 接口 (Interface)

- 接口本质就是一个可以进行 *多继承* 的纯的抽象类。它是单继承的一种例外
- 使用 interface 关键词声明接口，接口里面只能包含方法。按照习惯，一般使用 IXxx 的方式命名接口
- 不需要使用 public 修饰符，因为接口里所有方法默认都是公开的。方法不需要有方法体
- 接口实际上就是一种 *合同*，它起到的作用是制定统一的 *规则*
- 接口有很多好处: blahblahblah... 面向接口编程是一种好的编程实践

** IComparable 接口使用示例

IComparable 用来为两个对象进行比较提供比较的规则:
#+begin_src csharp
  class Person : IComparable
  {
      public string Name { get; set; }
      public double Salary { get; set; }
      public int Age { get; set; }

      public Person(string name, double sal, int age)
      {
          Name = name;
          Salary = sal;
          Age = age;
      }

      public int CompareTo(object? obj)
      {
          var wo = this;
          var ni = (Person) obj;

          // if (wo.Salary > ni.Salary) return -1;
          // if (wo.Salary < ni.Salary) return 1;
          // return 0;
          return wo.Salary - ni.Salary;
      }
  }

  static void Main(string[] args)
  {
      var p1 = new Person("a-小明", 20000, 50);
      var p2 = new Person("c-小张", 7000, 25);
      var p3 = new Person("b-小王", 15000, 35);
      var p4 = new Person("d-小红", 7500, 19);
      var p5 = new Person("e-小强", 5000, 22);

      var persons = new Person[] {p1, p2, p3, p4, p5};

      Array.Sort(persons);

      foreach (var p in persons)
      {
          Console.WriteLine($"{p.Name}: {p.Age} 岁, 收入为 {p.Salary}");
      }
  }
#+end_src

* BCL (Base-Class Library) 基础类库
** Console/控制台

相关方法和属性:
- Console.Write/WriteLine，用来向控制台输出内容
- Console.Clear，用来清空屏幕内容
- Console.ForegroundColor/BackgroudColor/ResetColor，用来设置控制台颜色
- Console.ReadLine，用来从控制台读取用户输入的字符串
- Console.ReadKey，用来读取按键，返回一个 ConsoleKeyInfo 对象
- Console.Beep，用来让控制台发出声音

相关类和结构:
- Console
- ConsoleColor
- ConsoleKey/ConsoleKeyInfo

示例:
#+begin_src csharp -n
  Console.WriteLine();
  while (true) // 通过 while 循环可以实现不断输入不断看到输入结果的过程
  {
      // ReadKey 是微软封装在 Console 里的一个方法，用来读取控制台上的按键
      // 我们不需要关心它怎么实现的，我们只需要关心它如何使用
      // 微软在实现里，将我们按下的键的信息，封装到了一个叫 ConsoleKeyInfo 的数据包里 (实例对象)
      // 调用 ReadKey 之后，就可以通过这个实例对象 key 所提供的可访问接口判断按键信息了
      ConsoleKeyInfo key = Console.ReadKey(true); // true 的意思是，不在屏幕上显示键入的字符
      if (key.Key == ConsoleKey.D1)
      {
          Console.WriteLine("您输入了一个 1");
      }
      else if (key.Key == ConsoleKey.S)
      {
          Console.Beep(); // Beep 是微软实现在 Console 里的一个方法，用来让控制台发出声音
      }
      else if (key.KeyChar == 'd')
      {
          Console.Beep(600, 200); // Beep 方法是重载的，它可以携带参数
      }
      else if (key.KeyChar == 'f')
      {
          Console.Beep(200, 200);
      }
      else if (key.Key == ConsoleKey.Enter)
      {
          break;
      }
      else
      {
          Console.WriteLine($"key: {key}, keyChar: {key.KeyChar}, key: {key.Key}");
      }
  }
#+end_src

** Random/Thread

#+begin_src csharp
  ConsoleColor[] colors = new ConsoleColor[]
  {
      ConsoleColor.Red, ConsoleColor.Green, ConsoleColor.Yellow
  };

  int i = 0;
  while (true)
  {
      // Console.WriteLine("hello {0}", DateTime.Now);
      // var timer = new Timer(null, TimeSpan(1), TimeSpan(2));
      Thread.Sleep(1000); // 题外话，这个 1000 毫秒并不是非常准确
      // Task.Delay(1000).Wait();

      //Console.WriteLine(colors[i]);
      //i = i + 1;
      //if (i == 3) i = 0;

      //Console.WriteLine(colors[i]);
      //i = (i + 1) % 3;

      //Console.WriteLine(colors[(i++) % 3]);

      System.Random random = new System.Random();
      int r = random.Next(colors.Length); // Next(3): 0, 1, 2
      Console.WriteLine(colors[r]);

      Console.Clear(); // 清空屏幕
      Console.ResetColor(); // 重置颜色
  }
#+end_src

** IDisposable/资源

- 资源，是指需要在操作系统中打开，用完之后，需要手动释放的对象
- 为什么需要手动释放呢？因为 .NET 平台不是万能的。虽然 .NET 平台有垃圾回收器，你不再需要的
  对象，它会自动帮你清理掉，但是有些东西它是无法确定你到底还需不需要，所以无法帮助你自动处理。
  你也只能手动释放或关闭
- 对于一些资源，必须要手动释放或关闭

对于普通的对象，是可以被 GC 自动回收的:
#+begin_src csharp
  // 创建的任何对象，都是可以被垃圾回收器 (GC) 自动释放
  // 因此，我们只需要 new 然后使用就可以了，其他的内存管理无需你关心
  for (int i = 0; i < 100000000; i++)
  {
      var a = new Book(); // 创建多少个都会被自动释放，绝对安全
  }
#+end_src

但是对于一些依赖系统的资源，必须要手动释放:
#+begin_src csharp
  // 像文件这样的资源，打开之后，必须要手动释放
  var fs = File.OpenRead(fileName);
  Console.WriteLine(5/0); // 代表使用 (2)
  fs.Close();             // 手动关闭/释放

  // 上述的代码是有问题的，因为，如果 (2) 出现错误的话，那么释放的语句就无法执行
  // 为了解决这个问题，可以使用 finally 语法，对整个资源释放的代码进行重构
  FileStream fs = null;
  try
  {
      fs = File.OpenRead(fileName);
      Console.WriteLine(fs);
      Console.WriteLine(5/0);
      Console.WriteLine("其他你所需要做的事情");
  }
  finally
  {
      if (fs != null)
      {
          try
          {
              fs.Close();
          }
          catch
          {
              Console.WriteLine("关闭失败");
          }
      }
  }

  // 可以使用 using 对上述代码进行简化
  // 必须让 FileStream 里面实现一个叫 Dispose 的方法
  // 为了保证你必须实现一个 Dispose 方法，你必须要实现 IDisposable 接口
  using (FileStream fs = File.OpenRead(fileName))
  {
      Console.WriteLine(fs);
      Console.WriteLine(5/0);
  }

  // 最新的 C# 版本又给了新的糖
  using FileStream fs = File.OpenRead(fileName); // fs 在后面碰到 } 后，会自动释放
  Console.WriteLine(fs);
  Console.WriteLine(5/0);
#+end_src

* 技巧和示例
** 求余

求余经常用来将某个数 *转换* 为 0-N 区间的一个数。

示例一，结合循环使用:
#+begin_src csharp -n
  for (int i = 0; i < 1000; i++)
  {
      int f = ((i % 8) * 30) + 100;
      Console.Beep(f, 50);
      Thread.Sleep(800 - (i % 8) * 50);
  }
#+end_src

示例二，求余和数组的结合使用:
#+begin_src csharp -n
  int[] freqs = new int[] { 200, 300, 100, 600 };

  for (int i = 0; i < 1000; i++)
  {
      int f = freqs[i % freqs.Length];
      Console.Beep(f, 50);
      Thread.Sleep(800 - (i % freqs.Length) * 50);
  }
#+end_src

示例三:
#+begin_src csharp -n
  // 除了声音外，添加视觉效果
  // 原理是一样的
  int[] freqs = new [] { 200, 300, 100, 600 };
  ConsoleColor[] colors = new[] { ConsoleColor.Red, ConsoleColor.Green, ConsoleColor.Blue, ConsoleColor.Yellow };

  for (int i = 0; i < 1000; i++)
  {
      int p = i % freqs.Length;
      for (int j = 0; j < freqs.Length; j++)
      {
          if (j == p)
          {
              Console.ForegroundColor = colors[p];
          }
          else
          {
              Console.ResetColor();
          }
          Console.SetCursorPosition(j * 3, 0);
          Console.Write("●");
      }
      Console.Beep(freqs[p], 50);

      Thread.Sleep(500 - (p) * 50);
  }
  Console.WriteLine();
#+end_src

* 模拟题
** 继承相关

请问下面程序的输出是什么:
#+begin_src csharp
  class A
  {
      public string name = "aaa";

      public void Name()
      {
          Console.WriteLine("我是 {0}", name);
      }

      public void 自我介绍()
      {
          Name();
      }
  }

  class B : A
  {
      void Name()
      {
          Console.WriteLine("你是 {0}", name);
      }

      string name = "bbb";

      public void 自我介绍()
      {
          this.Name();
          Console.WriteLine("----");
          base.Name();
      }
  }

  class Program
  {
      static void Main()
      {
          B b = new B();
          b.自我介绍();
      }
  }
#+end_src


** 重载 (overload) 和 重写 (override) 有啥区别 (15 分)

重构 = 重新构造 = 将代码进行重写，让结构发生变化的行为
= 一般来说，是因为现有的代码不合理，所以呢，重新调整一下
= 一般来说，重构只是为了改变代码结构或代码质量，它不会对程序的运行逻辑进行改变

* 问题 (仅作参考)
** string 和 StringBuilder 有什么区别

- string 是一种预定义类型，它表达的是字符的有序组合
- StringBuilder 是定义在 BCL 中的类型，它主要用来进行字符串的拼接
- string 是不可变的，所以在进行拼接等操作的时候，效率会非常低
- StringBuilder 是可变的一种类型，所以在字符串拼接的时候，效率相对高多了
- 因此，在进行字符串拼接的操作的时候，我们一般使用 StringBuilder 进行构建，从而提升效率

** 什么是抽象类，抽象类有什么用处
** 什么是接口，什么是面向接口编程，面向接口编程有什么好处
** 什么是静态类，什么是密封类，什么是分部类
** 什么是类，什么是对象，对象的实例化过程是怎么样的
** 什么是面向对象编程，面向对象有什么特点，有什么好处
** 什么是字段，什么是方法，什么是属性。属性有什么好处
** 什么是封装，什么是继承，什么是多态
** 什么是虚方法，它有什么用处
** 什么是组合，它跟继承有什么区别，分别用在什么场景
** 什么是 DRY，代码复用的手段有哪些
