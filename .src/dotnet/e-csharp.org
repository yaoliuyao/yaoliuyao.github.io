#+TITLE: C♯


* 控制流程
** 条件判断/分支

- 规则 (rule)

if:
#+begin_src csharp
  // if
  if (bool)
  {
  }

  // if / else
  if (bool)
  {
  }
  else
  {
  }

  // if / else if / ... / else
  if (bool)
  {
  }
  else if (bool)
  {
  }
  else if (bool)
  {
  }
  else if (bool)
  {
  }
  else if (bool)
  {
  }
  else
  {
  }
#+end_src

switch:
#+begin_src csharp
  switch (exp)
  {
      case a:
          做什么;
          break;
      case b:
          做什么;
          break;
  }
#+end_src

* 类跟对象 (Class/Instance)
** 字段 (Field)

- 作为一个字段，最重要的是 (类型) (名字) = (值)
- 可以 *选择性* 使用其他修饰符，为字段增加 *额外* 的功能或限制:
  + 访问修饰符: private/public/protected/internal 等，用来给予外部的访问限制
  + 只读/常量修饰符: const/readonly，用来防止数据被误修改
  + 静态修饰符: static 的作用是，将这个字段的归属权给予类

** 方法 (Method)

方法是一个具备名字的代码块:
- 通过 ~方法名()~ 的方式实现方法调用，
  也就是在调用的地方将方法名代表的代码块里的代码进行运行
- 方法的三要素:
  1. 一个名字 (方法名)
  2. 传入的数据 (传入参数) 入参写在方法名后面的括号里。如果没有入参，括号保持为空即可
  3. 传出的数据 (返回值) 方法内部，使用 return 表示返回的数据。在方法名前面，添加返回的类型。
     如果方法内部没有任何 return 表示方法没有返回值，需要在方法前面添加 void 表示这种情况


方法的重载 (overload):
- 一个类中，可以有同名的方法。需要有不同的参数 (这样才能区分调用)
- 请叙述一下 overload 和 override 有什么区别

方法的示例:
#+begin_src csharp
  class Program
  {
      // 方法的声明、定义
      int 增加 (int a)  // 方法名为 [增加]，入参为 [a]
      {
          return a + 1;  // 返回值为 [a + 1]
      }
      double 加法 (double a, double b) // 可以有多个入参
      {
          return a + b;
      }
      double 没有入参 () // 可以没有入参
      {
          return 111.111; // 返回 double 类型的数据
      }
      void 没有返回数据 (string name) // 没有返回数据使用 void 表示
      {
          Console.WriteLine(name); // 方法体内，没有任何 return 语句，所以方法没有返回任何数据
      }
      void 没有返回值也没有入参 () // 这个方法，就是没有返回值也没有入参
      {
          Console.WriteLine("hello, world");
      }

      // 方法的调用
      // 使用方法的名字调用方法:
      // - 入参的个数和顺序要跟上述定义的一致
      // - 返回值的类型要跟上述定义的一致，如果 void 类型的函数是不能接受其返回值的
      // 上述方法定义中的参数，又叫形式参数 (形参)
      // 这里调用时传入的参数，又叫实际参数 (实参)
      // 也就是，实参要跟形参相对应!
      int a = 增加(11);
      double b = 加法(11, 33);
      double c = 没有入参();
      没有返回数据("H&M");
      没有返回值也没有入参();
  }
#+end_src

** 属性 (Property)

属性本身就是 [private Field + public Method] 一种语法糖:
- 它能减少太多冗余的模板代码；它能简化对实例中数据的可控性的访问，让代码更简洁
- 但是不要忘了，它跟 getter/setter 方法的本质是一样的。最后编译器还是将我们写的属性代码转换成了 getter/setter 方法的形式
- 也就是说 ~r.Width = 333~ 这样的属性赋值，本质就是方法调用

示例:
#+begin_src csharp
  class Rect
  {
      public double Width { get; set; }
      public double Height { get; set; }
      public double Area
      {
          get
          {
              return Width * Height;
          }
      }

      // private double Height;
      // public double GetHeight ()
      // {
      //     return Height;
      // }
      // public void SetHeight (double h);
      // {
      //     Height = h;
      // }
  }

  class Program
  {
      static void Main()
      {
          Rect r = new Rect();
          r.Width = 2000;
          r.Height = 333;
          Console.WriteLine("面积是: {0}", r.Area);
      }
  }
#+end_src

** 构造方法/构造器 (Constructor)

对象的实例化，分为下面几个步骤:
1. 在内存中，分配相应的空间
2. 按照类型进行相关字段的初始化工作
3. 调用相应的 *构造方法*，进行相关初始化工作

所谓的构造方法，就是类中定义的一个特殊方法。它用来对实例空间进行若干初始化工作:   
- 构造方法可以写多个，即可以重载 (overload)
- 我们也可以不写任何构造方法，那么编译器在编译的时候，会自动帮我们插入一个 *无参的空的*。
  但是，如果你在类中，定义了任何的构造方法，那么编译器就不会帮你再生成了

#+begin_src csharp
  class X
  {
      public X()
      {
      }
      public X(int a, int b) // 2
      {
      }
  }

  class Program
  {
      static void Main()
      {
          new X(); // 如果没有参数，那么会调用无参构造器 1
          new X(1, 2); // 回去调用相应的具备两个参数，并且类型正确的构造器 2
      }
  }
#+end_src

** 静态 (Static)

将归属权，交给类。调用的时候，使用 ~类名.xxx~ 方式。

** 将数据设置为不变的 (const/readonly)

: 通过 private 等操作符可以保护数据的外部访问安全
: 通过 const/readonly 可以防止内鬼

const:
- 即常量
- 基于编译期的替换，运行期是没有任何这个变量的信息的
- 相对来说，它不需要占用存储，而且不需要运行时检查，所以效率高
- 它的使用限制较多，比如，只能将一些简单的值赋予它
- 不能添加 static 修饰，但可以使用 ~类名.PI~ 来访问

readonly:
- 限定变量只能读，不能修改
- 可以修饰任何的字段，不管是不是静态的
- 相对来说，需要占用空间、需要运行时检查，效率会低一些
- *注意*，使用 readonly 修饰数组等变量，虽然可以防止数组被重新赋值，但不能避免里面的元素被修改

有内鬼，停止交易:
#+begin_src csharp
  class Congming
  {
      private const double PI = 3.1415926;
      private readonly double pppi = 3.14;

      public double QiuMianJi(double r)
      {
          pppi = 333;  // x
          PI = 333;    // x
          return pppi * r * r;
      }
  }
#+end_src

* BCL (Base-Class Library) 基础类库
** Console/控制台

相关方法和属性:
- Console.Write/WriteLine，用来向控制台输出内容
- Console.Clear，用来清空屏幕内容
- Console.ForegroundColor/BackgroudColor/ResetColor，用来设置控制台颜色
- Console.ReadLine，用来从控制台读取用户输入的字符串
- Console.ReadKey，用来读取按键，返回一个 ConsoleKeyInfo 对象
- Console.Beep，用来让控制台发出声音

相关类和结构:
- Console
- ConsoleColor
- ConsoleKey/ConsoleKeyInfo

示例:
#+begin_src csharp -n
  Console.WriteLine();
  while (true) // 通过 while 循环可以实现不断输入不断看到输入结果的过程
  {
      // ReadKey 是微软封装在 Console 里的一个方法，用来读取控制台上的按键
      // 我们不需要关心它怎么实现的，我们只需要关心它如何使用
      // 微软在实现里，将我们按下的键的信息，封装到了一个叫 ConsoleKeyInfo 的数据包里 (实例对象)
      // 调用 ReadKey 之后，就可以通过这个实例对象 key 所提供的可访问接口判断按键信息了
      ConsoleKeyInfo key = Console.ReadKey(true); // true 的意思是，不在屏幕上显示键入的字符
      if (key.Key == ConsoleKey.D1)
      {
          Console.WriteLine("您输入了一个 1");
      }
      else if (key.Key == ConsoleKey.S)
      {
          Console.Beep(); // Beep 是微软实现在 Console 里的一个方法，用来让控制台发出声音
      }
      else if (key.KeyChar == 'd')
      {
          Console.Beep(600, 200); // Beep 方法是重载的，它可以携带参数
      }
      else if (key.KeyChar == 'f')
      {
          Console.Beep(200, 200);
      }
      else if (key.Key == ConsoleKey.Enter)
      {
          break;
      }
      else
      {
          Console.WriteLine($"key: {key}, keyChar: {key.KeyChar}, key: {key.Key}");
      }
  }
#+end_src

** Random/Thread

#+begin_src csharp
  ConsoleColor[] colors = new ConsoleColor[]
  {
      ConsoleColor.Red, ConsoleColor.Green, ConsoleColor.Yellow
  };

  int i = 0;
  while (true)
  {
      // Console.WriteLine("hello {0}", DateTime.Now);
      // var timer = new Timer(null, TimeSpan(1), TimeSpan(2));
      Thread.Sleep(1000); // 题外话，这个 1000 毫秒并不是非常准确
      // Task.Delay(1000).Wait();

      //Console.WriteLine(colors[i]);
      //i = i + 1;
      //if (i == 3) i = 0;

      //Console.WriteLine(colors[i]);
      //i = (i + 1) % 3;

      //Console.WriteLine(colors[(i++) % 3]);

      System.Random random = new System.Random();
      int r = random.Next(colors.Length); // Next(3): 0, 1, 2
      Console.WriteLine(colors[r]);

      Console.Clear(); // 清空屏幕
      Console.ResetColor(); // 重置颜色
  }
#+end_src

** IDisposable/资源

- 资源，是指需要在操作系统中打开，用完之后，需要手动释放的对象
- 为什么需要手动释放呢？因为 .NET 平台不是万能的。虽然 .NET 平台有垃圾回收器，你不再需要的
  对象，它会自动帮你清理掉，但是有些东西它是无法确定你到底还需不需要，所以无法帮助你自动处理。
  你也只能手动释放或关闭
- 对于一些资源，必须要手动释放或关闭

对于普通的对象，是可以被 GC 自动回收的:
#+begin_src csharp
  // 创建的任何对象，都是可以被垃圾回收器 (GC) 自动释放
  // 因此，我们只需要 new 然后使用就可以了，其他的内存管理无需你关心
  for (int i = 0; i < 100000000; i++)
  {
      var a = new Book(); // 创建多少个都会被自动释放，绝对安全
  }
#+end_src

但是对于一些依赖系统的资源，必须要手动释放:
#+begin_src csharp
  // 像文件这样的资源，打开之后，必须要手动释放
  var fs = File.OpenRead(fileName);
  Console.WriteLine(5/0); // 代表使用 (2)
  fs.Close();             // 手动关闭/释放

  // 上述的代码是有问题的，因为，如果 (2) 出现错误的话，那么释放的语句就无法执行
  // 为了解决这个问题，可以使用 finally 语法，对整个资源释放的代码进行重构
  FileStream fs = null;
  try
  {
      fs = File.OpenRead(fileName);
      Console.WriteLine(fs);
      Console.WriteLine(5/0);
      Console.WriteLine("其他你所需要做的事情");
  }
  finally
  {
      if (fs != null)
      {
          try
          {
              fs.Close();
          }
          catch
          {
              Console.WriteLine("关闭失败");
          }
      }
  }

  // 可以使用 using 对上述代码进行简化
  // 必须让 FileStream 里面实现一个叫 Close 的方法
  // 为了保证你必须实现一个 Close 方法，你必须要实现 IDisposable 接口
  using (FileStream fs = File.OpenRead(fileName))
  {
      Console.WriteLine(fs);
      Console.WriteLine(5/0);
  }

  // 最新的 C# 版本又给了新的糖
  using FileStream fs = File.OpenRead(fileName); // fs 在后面碰到 } 后，会自动释放
  Console.WriteLine(fs);
  Console.WriteLine(5/0);
#+end_src

* 技巧和示例
** 求余

求余经常用来将某个数 *转换* 为 0-N 区间的一个数。

示例一，结合循环使用:
#+begin_src csharp -n
  for (int i = 0; i < 1000; i++)
  {
      int f = ((i % 8) * 30) + 100;
      Console.Beep(f, 50);
      Thread.Sleep(800 - (i % 8) * 50);
  }
#+end_src

示例二，求余和数组的结合使用:
#+begin_src csharp -n
  int[] freqs = new int[] { 200, 300, 100, 600 };

  for (int i = 0; i < 1000; i++)
  {
      int f = freqs[i % freqs.Length];
      Console.Beep(f, 50);
      Thread.Sleep(800 - (i % freqs.Length) * 50);
  }
#+end_src

示例三:
#+begin_src csharp -n
  // 除了声音外，添加视觉效果
  // 原理是一样的
  int[] freqs = new [] { 200, 300, 100, 600 };
  ConsoleColor[] colors = new[] { ConsoleColor.Red, ConsoleColor.Green, ConsoleColor.Blue, ConsoleColor.Yellow };

  for (int i = 0; i < 1000; i++)
  {
      int p = i % freqs.Length;
      for (int j = 0; j < freqs.Length; j++)
      {
          if (j == p)
          {
              Console.ForegroundColor = colors[p];
          }
          else
          {
              Console.ResetColor();
          }
          Console.SetCursorPosition(j * 3, 0);
          Console.Write("●");
      }
      Console.Beep(freqs[p], 50);

      Thread.Sleep(500 - (p) * 50);
  }
  Console.WriteLine();
#+end_src

* 模拟题
** 继承相关

请问下面程序的输出是什么:
#+begin_src csharp
  class A
  {
      public string name = "aaa";

      public void Name()
      {
          Console.WriteLine("我是 {0}", name);
      }

      public void 自我介绍()
      {
          Name();
      }
  }

  class B : A
  {
      void Name()
      {
          Console.WriteLine("你是 {0}", name);
      }

      string name = "bbb";

      public void 自我介绍()
      {
          this.Name();
          Console.WriteLine("----");
          base.Name();
      }
  }

  class Program
  {
      static void Main()
      {
          B b = new B();
          b.自我介绍();
      }
  }
#+end_src

